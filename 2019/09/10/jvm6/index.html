<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="由于JVM规范本身就是个虚拟概念，因此JVM执行引擎也是个标准，具体实现时会有优化，但要保证执行语义符合规范：即从外观（facade）上看，所有JVM虚拟机的执行引擎都是一致的。 运行时栈帧结构栈帧（stack frame）是用于支持JVM进行方法调用和方法执行的数据结构，是运行时数据区中虚拟机栈（virtual machine stack）的栈数据，栈帧保存了方法的局部变量表、操作数栈、动态连接">
<meta name="keywords" content="JVM,lambda表达式,invokedynamic">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习（6）JVM字节码执行引擎">
<meta property="og:url" content="https://maxiaoxin.github.io/2019/09/10/jvm6/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:description" content="由于JVM规范本身就是个虚拟概念，因此JVM执行引擎也是个标准，具体实现时会有优化，但要保证执行语义符合规范：即从外观（facade）上看，所有JVM虚拟机的执行引擎都是一致的。 运行时栈帧结构栈帧（stack frame）是用于支持JVM进行方法调用和方法执行的数据结构，是运行时数据区中虚拟机栈（virtual machine stack）的栈数据，栈帧保存了方法的局部变量表、操作数栈、动态连接">
<meta property="og:locale" content="cn">
<meta property="og:image" content="https://maxiaoxin.github.io/images/jvm_stack_frame.png">
<meta property="og:image" content="https://maxiaoxin.github.io/images/jvm_stack_share_vars.png">
<meta property="og:image" content="https://maxiaoxin.github.io/images/jvm_vtable.jpg">
<meta property="og:updated_time" content="2019-09-12T09:11:08.678Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM学习（6）JVM字节码执行引擎">
<meta name="twitter:description" content="由于JVM规范本身就是个虚拟概念，因此JVM执行引擎也是个标准，具体实现时会有优化，但要保证执行语义符合规范：即从外观（facade）上看，所有JVM虚拟机的执行引擎都是一致的。 运行时栈帧结构栈帧（stack frame）是用于支持JVM进行方法调用和方法执行的数据结构，是运行时数据区中虚拟机栈（virtual machine stack）的栈数据，栈帧保存了方法的局部变量表、操作数栈、动态连接">
<meta name="twitter:image" content="https://maxiaoxin.github.io/images/jvm_stack_frame.png">
  <link rel="canonical" href="https://maxiaoxin.github.io/2019/09/10/jvm6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>JVM学习（6）JVM字节码执行引擎 | 读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/10/jvm6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">JVM学习（6）JVM字节码执行引擎

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-10T00:00:00+08:00">2019-09-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-12 17:11:08" itemprop="dateModified" datetime="2019-09-12T17:11:08+08:00">2019-09-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>由于JVM规范本身就是个虚拟概念，因此JVM执行引擎也是个标准，具体实现时会有优化，但要保证执行语义符合规范：即从外观（facade）上看，所有JVM虚拟机的执行引擎都是一致的。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧（stack frame）是用于支持JVM进行方法调用和方法执行的数据结构，是运行时数据区中虚拟机栈（virtual machine stack）的栈数据，栈帧保存了方法的局部变量表、操作数栈、动态连接、方法返回地址等信息。之前提到方法表Code属性，里面有栈帧大小的限制，因此一个栈帧占用内存大小在编译期就决定了，具体占多大内存取决于JVM实现。</p>
<p><img src="/images/jvm_stack_frame.png" alt="栈帧结构"></p>
<p>对于某个线程而言，只有栈顶的栈帧是有效的（称为当前栈帧<code>current stack frame</code>），与其相关联的方法称为当前方法<code>current method</code>，所有字节码指令都只针对当前栈帧操作。</p>
<p>与大多数物理机使用基于寄存器的指令框架不同，JVM使用的是基于栈的架构，比如两个数相加需要先把两个数入栈，然后<code>iadd</code>指令把栈顶两个数拿出来相加再入栈，而寄存器就没这么麻烦。一般来说基于栈的指令集会慢一些，好处是可移植，比如上图中的各个区域的大小都可以随便调整（相对的，同一物理机的每个寄存器的特性都不太一样，不同物理机可能寄存器数目都不一样），所以JVM实际执行的时候会对这些指令进行优化。</p>
<h3 id="局部变量表（local-variable-table）"><a href="#局部变量表（local-variable-table）" class="headerlink" title="局部变量表（local variable table）"></a>局部变量表（local variable table）</h3><p>用于存放方法参数和方法内部定义的局部变量，方法的Code属性的<code>max_locals</code>数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表的基本单位是slot，规范没有指明一个slot有多大，只是说每个slot都可以存放一个<code>boolean, byte, char, shot, int, float, reference, returnAddress</code>类型，那么具体实现的时候，一个slot可以用32位，也可以用64位来存。其中，JVM没有指定<code>reference</code>长度一定要多少，甚至可以不是指针，但要求它能做到：</p>
<ul>
<li>从这个引用可以直接或间接地查找到对象在java堆中的数据存放的起始地址索引</li>
<li>从这个引用可以直接或间接地查找到对象所属数据类型在方法区中存储的类型信息（RTTI）</li>
</ul>
<p><code>returnAddress</code>现在用的比较少，较早的JVM使用这条指令实现异常处理，现在由异常表代替。</p>
<p><code>long</code>和<code>double</code>要求是64位，因此一般会占两个slot。对局部变量表的索引从0开始，以slot为单位，如果遇到连在一起的slot却分开用时应该抛出异常。JVM通过局部变量表来实现参数传递的，如果方法不是静态方法，那么会先把<code>this</code>传为第0号局部变量，之后的参数顺序写入。参数分配完后再根据方法体内部定义的变量顺序和作用域分配其余slot。</p>
<p>可以通过重复利用slot来节省栈帧空间，比如当前字节码PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的slot就可以交给其他变量使用。更进一步，如果之前的变量所在的slot被复写了，那么它所指的object就可以被回收，相反如果没被复写，即使超出了它的作用域也不一定会被及时回收。一个技巧是可以及时为变量赋值为<code>null</code>来加快GC。</p>
<p>最后，java不会为局部变量预设初始值，因此开发人员必须手动为局部变量设初值，否则编译不过，也通不过JVM字节码校验。</p>
<h3 id="操作数栈（operand-stack）"><a href="#操作数栈（operand-stack）" class="headerlink" title="操作数栈（operand stack）"></a>操作数栈（operand stack）</h3><p>用于进行具体运算，方法的Code属性的<code>max_stack</code>定义了操作数栈的最大深度，且单位也是slot。方法开始执行的时候操作数栈为空，随着方法运行会有各种入栈出栈操作，且操作数栈中的数据类型必须和字节码指令的序列严格匹配，不过这个是在编译期和校验期做的。</p>
<p>另外，理论上栈帧之间是完全独立的，实际上可以做一些优化，让两个栈帧部分重叠，这样就避免了额外的参数传递。</p>
<p><img src="/images/jvm_stack_share_vars.png" alt="两个栈帧之间数据共享"></p>
<h3 id="动态连接（dynamic-linking）"><a href="#动态连接（dynamic-linking）" class="headerlink" title="动态连接（dynamic linking）"></a>动态连接（dynamic linking）</h3><p>每个栈帧都包含一个指向常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态调用（dynamic linking）。C++是通过虚函数表来实现多态的，而JAVA则是通过先查找所属类、再解析符号引用/函数表来确定调用哪个方法。</p>
<h3 id="方法返回地址（Normal-Abrupt-Method-Invocation-Completion）"><a href="#方法返回地址（Normal-Abrupt-Method-Invocation-Completion）" class="headerlink" title="方法返回地址（Normal/Abrupt Method Invocation Completion）"></a>方法返回地址（Normal/Abrupt Method Invocation Completion）</h3><p>方法返回分为两种，一种是正常遇到返回指令结束方法调用，另一种是抛出异常且没有被正确处理（此时没有返回值）。无论如何退出，都需要在栈帧中保存一些信息，以便返回值上层调用位置。</p>
<p>方法退出时需要将栈帧出栈，需要恢复上层方法的局部变量表和操作数栈，将返回值（如果有）压入上层的操作数栈，调整PC计数器的值以指向方法调用指令后的一条指令等。</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>JVM允许添加一些附加信息到栈帧（比如调试信息），取决于JVM具体实现。一般把动态连接、方法返回地址和其他附加信息全部归位一类，称为栈帧信息。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用在方法执行之前，目的是找到应当调用哪个方法。由于class文件没有类似C的连接步骤，一切方法调用都是符号引用，因此需要先将符号引用解析为直接引用，而实际上可能需要在类加载期间、甚至在运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析（resolution）"><a href="#解析（resolution）" class="headerlink" title="解析（resolution）"></a>解析（resolution）</h3><p>首先，JVM提供了5中调用字节码的指令，分别是：</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用实例构造器<code>&lt;init&gt;</code>、私有方法、父类方法</li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</li>
</ul>
<p>在之前的章节提到过，类加载过程中有解析的步骤，其中会把一部分符号引用转换为直接引用，而能够转换的前提是在执行前就能确定是哪个方法，且在运行中不可变。符合这一条件的方法有：静态方法、私有方法、实例构造器、父类方法、final方法这几种。关于final方法，可以参考<a href="https://juejin.im/entry/58c4811161ff4b005d94fed2" target="_blank" rel="noopener">Final of Java，这一篇差不多了</a>，简单来说即final方法还是用<code>invokevirtual</code>调用，但可以在编译期确定，且可以被内联。</p>
<h3 id="分派（dispatch）"><a href="#分派（dispatch）" class="headerlink" title="分派（dispatch）"></a>分派（dispatch）</h3><p>解析调用可以在编译阶段唯一确定，而分派调用则可以是静态的或动态的，且根据宗量（argument，个人理解是方法签名）可以分为单分派和多分派，两两组合可以分为静态单分派、静态多分派、动态单分派、动态多分派。</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>编译期根据调用时的类型来确定使用哪个签名，值得注意的地方有两点：</p>
<ol>
<li>是编译器“看到”的参数类型，而不是实际类型。比如<code>foo((A)B)</code>和<code>foo(B)</code>可能调用了两个完全不同的方法。这个类型称为静态类型（static type）或外观类型（apparent type）</li>
<li>如果没有严格匹配的方法，那么编译器会尝试类型转换，选择一个更为“合适”的方法，比如对于<code>foo(char)</code>、<code>foo(int)</code>、<code>foo(Character)</code>、<code>foo(char...)</code>这几个方法时，如果输入参数是<code>&#39;a&#39;</code>，那么调用优先级依次降低。</li>
</ol>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派，Java的动态分派主要通过<code>invokevirtual</code>指令来实现，这个指令运行时解析过程大致分为以下几步：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C</li>
<li>从这个类开始，按照继承关系从下到上查找匹配的方法，如果找到则进行权限校验，通过则返回这个方法的直接引用，否则抛出<code>java.lang.illegalAccessError</code></li>
<li>如果一直没找到，则抛出<code>java.lang.AbstractMethodError</code></li>
</ol>
<h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><p>简单来说就是根据一个参数还是多个参数来进行分派（包括<code>this</code>）。事实上，java只支持静态多分派和动态单分派，即的动态分派只根据<code>this</code>来选择方法版本。C# 4.0后通过<code>dynamic</code>关键字可以支持动态多分配，参考<a href="https://chodounsky.net/2014/01/29/dynamic-dispatch-in-c-number/" target="_blank" rel="noopener">Dynamic Dispatch in C#</a>，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface IBar &#123;&#125;</span><br><span class="line">public class Bar : IBar &#123;&#125;</span><br><span class="line">public sealed class FooBar : Bar &#123;&#125;</span><br><span class="line"></span><br><span class="line">// Simple helper for demonstration</span><br><span class="line">public static class ConsolePrinter</span><br><span class="line">&#123;</span><br><span class="line">    public static void Print(IBar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;IBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Print(Bar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Print(FooBar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;FooBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new Bar();</span><br><span class="line">var foo = new FooBar();</span><br><span class="line">IBar ibar = new FooBar();</span><br><span class="line"></span><br><span class="line">IBar[] items = &#123; bar, foo, ibar &#125;;</span><br></pre></td></tr></table></figure>

<p>定义了三个不同的实例，放到同一个数组里，那么执行的结果应当是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach (var item in items)</span><br><span class="line">&#123;</span><br><span class="line">    ConsolePrinter.Print(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints IBar</span><br><span class="line">// prints IBar</span><br><span class="line">// prints IBar</span><br></pre></td></tr></table></figure>

<p>而如果在foreach循环中用dynamic来解释，结果就不同了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach (dynamic item in items)</span><br><span class="line">&#123;</span><br><span class="line">    ConsolePrinter.Print(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints Bar</span><br><span class="line">// prints FooBar</span><br><span class="line">// prints FooBar</span><br></pre></td></tr></table></figure>

<p>这意味着C#中会在运行时解析dynamic类型，拿到具体的对应类型后再决定方法签名，也就实现了动态多分派（虽然这个例子只有一个参数，还是单分配）</p>
<h4 id="动态分派的实现"><a href="#动态分派的实现" class="headerlink" title="动态分派的实现"></a>动态分派的实现</h4><p>理论上可以在运行时解析方法的符号链接，不过一般在实现中会用虚方法表（virtual method table, vtable，类似在<code>invokeinterface</code>时会用到interface method table, itable），如下图所示：</p>
<p><img src="/images/jvm_vtable.jpg" alt="JVM 虚方法表"></p>
<p>每个类维护了一个虚表，如果没有重写某个方法，就和父类的入口地址保持一致，这些可以在载入时实现。</p>
<h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>动态类型语言的关键特征是，它的类型检查的主体过程在运行期而非编译期。JVM中<code>invokespecial、invokevirtual、invokeinterface、invokestatic</code>的“参数”实际上都包含了“哪个类中的哪个方法”这一信息。比如<code>foo.bar()</code>这个调用，如果<code>foo</code>所声明的类型没有实现<code>bar()</code>方法，那么就无法编译通过；而在动态类型语言中，甚至可以不要求<code>bar()</code>被定义过都有可能正常执行，即使<code>foo</code>确实没定义过这个方法、也没有相关的语法糖，只要没执行到这条语句也不会报错。</p>
<p>JDK1.7后引入了<code>invokedynamic</code>指令和<code>java.lang.invoke</code>包，用以实现动态调用，而在JDK1.8里引入的lambda表达式使用了<code>invokedynamic</code>，具体可以参考<a href="https://colobu.com/2014/11/06/secrets-of-java-8-lambda/" target="_blank" rel="noopener">Java 8 Lambda 揭秘</a>和<a href="https://my.oschina.net/haogrgr/blog/367391" target="_blank" rel="noopener">JDK8中Lambda表达式底层实现浅析(一)</a>。在学习<code>invokedynamic</code>之前，需要先了解<code>MethodHandle</code>。</p>
<h4 id="MethodHandle"><a href="#MethodHandle" class="headerlink" title="MethodHandle"></a>MethodHandle</h4><p>简单来说<code>MethodHandle</code>有点像C/C++的函数指针，在此之前java为了实现函数指针需要用<code>interface</code>，而使用<code>interface</code>时需要先实例化一个类再调用这个类的某个方法，<code>MethodHandle</code>相对来说会“轻量级”一些，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"foo1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"foo2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? <span class="keyword">new</span> Foo1() : <span class="keyword">new</span> Foo2();</span><br><span class="line">    getPrintlnMH(obj).invokeExact();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">    <span class="keyword">return</span> MethodHandles.lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodHandles.lookup().findVirtual()</code>用以查找在指定类中符合给定方法签名且符合调用权限的方法句柄，并且由于这个方法不是静态方法，需要绑定<code>this</code>，所以要把<code>reveiver</code>传给<code>bindTo()</code>。</p>
<p>可以看到Foo1和Foo2之间没有继承关系，也可以通过方法签名找到并调用指定方法：这和反射有些相似，但反射（reflection）和MethodHandle实际区别很大：</p>
<ol>
<li>反射是在模拟java代码层次的方法调用，而MethodHandle是在模拟字节码层次的调用，比如<code>MethodHandles.lookup()</code>中的<code>findStatic()、findVirtual()、findSpecial()</code>分别对应字节码<code>invokestatic、invokevirtual&amp;invokeinterface、invokespecial</code>这几个字节码指令的执行权限调用行为，这在使用反射时不需要关心</li>
<li>反射中的<code>java.lang.reflect.Method</code>对象远比<code>MethodHandle</code>机制中的<code>java.lang.invoke.MethodHandle</code>对象所含的信息多，前者是方法在java一端的全面映像，包含了方法的签名、描述符、方法属性表中的各种属性的java端表示方式、执行权限等信息，而后者只包含与执行该方法相关的信息。</li>
<li>原则上由于<code>MethodHandle</code>是字节码调用的模拟，理论上可以在这方面做一些优化。</li>
<li>反射API设计目标是为java语言服务的，而<code>MethodHandle</code>则设计为可以为所有JVM支持的语言服务。</li>
</ol>
<h4 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h4><p>某种程度上<code>invokedynamic</code>和<code>MethodHandle</code>的目标类似，都是为了解决<code>invoke*</code>的分派规则由JVM决定的问题，让开发者有更高的查找目标方法的自由度。JDK1.8实现lambda表达式时使用了<code>invokedynamic</code>，下面是一段代码和它对应的反编译数据，生成的.class在<a href="/files/HelloWorld.class">这里</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    Runnable r = ()-&gt; System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">#1 = Methodref          #8.#27         // java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">   <span class="comment">#2 = InvokeDynamic      #0:#32         // #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">   <span class="comment">#3 = InterfaceMethodref #33.#34        // java/lang/Runnable.run:()V</span></span><br><span class="line">   <span class="comment">#4 = Fieldref           #35.#36        // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   <span class="comment">#5 = String             #37            // hello</span></span><br><span class="line">   <span class="comment">#6 = Methodref          #38.#39        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   <span class="comment">#7 = Class              #40            // HelloWorld</span></span><br><span class="line">   <span class="comment">#8 = Class              #41            // java/lang/Object</span></span><br><span class="line">   <span class="comment">#9 = Utf8               &lt;init&gt;</span></span><br><span class="line">  <span class="comment">#10 = Utf8               ()V</span></span><br><span class="line">  <span class="comment">#11 = Utf8               Code</span></span><br><span class="line">  <span class="comment">#12 = Utf8               LineNumberTable</span></span><br><span class="line">  <span class="comment">#13 = Utf8               LocalVariableTable</span></span><br><span class="line">  <span class="comment">#14 = Utf8               this</span></span><br><span class="line">  <span class="comment">#15 = Utf8               LHelloWorld;</span></span><br><span class="line">  <span class="comment">#16 = Utf8               main</span></span><br><span class="line">  <span class="comment">#17 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#18 = Utf8               args</span></span><br><span class="line">  <span class="comment">#19 = Utf8               [Ljava/lang/String;</span></span><br><span class="line">  <span class="comment">#20 = Utf8               r</span></span><br><span class="line">  <span class="comment">#21 = Utf8               Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#22 = Utf8               Exceptions</span></span><br><span class="line">  <span class="comment">#23 = Class              #42            // java/lang/Throwable</span></span><br><span class="line">  <span class="comment">#24 = Utf8               lambda$main$0</span></span><br><span class="line">  <span class="comment">#25 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#26 = Utf8               HelloWorld.java</span></span><br><span class="line">  <span class="comment">#27 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span></span><br><span class="line">  <span class="comment">#28 = Utf8               BootstrapMethods</span></span><br><span class="line">  <span class="comment">#29 = MethodHandle       #6:#43         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#30 = MethodType         #10            //  ()V</span></span><br><span class="line">  <span class="comment">#31 = MethodHandle       #6:#44         // invokestatic HelloWorld.lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#32 = NameAndType        #45:#46        // run:()Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#33 = Class              #47            // java/lang/Runnable</span></span><br><span class="line">  <span class="comment">#34 = NameAndType        #45:#10        // run:()V</span></span><br><span class="line">  <span class="comment">#35 = Class              #48            // java/lang/System</span></span><br><span class="line">  <span class="comment">#36 = NameAndType        #49:#50        // out:Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#37 = Utf8               hello</span></span><br><span class="line">  <span class="comment">#38 = Class              #51            // java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#39 = NameAndType        #52:#53        // println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#40 = Utf8               HelloWorld</span></span><br><span class="line">  <span class="comment">#41 = Utf8               java/lang/Object</span></span><br><span class="line">  <span class="comment">#42 = Utf8               java/lang/Throwable</span></span><br><span class="line">  <span class="comment">#43 = Methodref          #54.#55        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#44 = Methodref          #7.#56         // HelloWorld.lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#45 = Utf8               run</span></span><br><span class="line">  <span class="comment">#46 = Utf8               ()Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#47 = Utf8               java/lang/Runnable</span></span><br><span class="line">  <span class="comment">#48 = Utf8               java/lang/System</span></span><br><span class="line">  <span class="comment">#49 = Utf8               out</span></span><br><span class="line">  <span class="comment">#50 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#51 = Utf8               java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#52 = Utf8               println</span></span><br><span class="line">  <span class="comment">#53 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#54 = Class              #57            // java/lang/invoke/LambdaMetafactory</span></span><br><span class="line">  <span class="comment">#55 = NameAndType        #58:#62        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#56 = NameAndType        #24:#10        // lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#57 = Utf8               java/lang/invoke/LambdaMetafactory</span></span><br><span class="line">  <span class="comment">#58 = Utf8               metafactory</span></span><br><span class="line">  <span class="comment">#59 = Class              #64            // java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  <span class="comment">#60 = Utf8               Lookup</span></span><br><span class="line">  <span class="comment">#61 = Utf8               InnerClasses</span></span><br><span class="line">  <span class="comment">#62 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#63 = Class              #65            // java/lang/invoke/MethodHandles</span></span><br><span class="line">  <span class="comment">#64 = Utf8               java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  <span class="comment">#65 = Utf8               java/lang/invoke/MethodHandles</span></span><br><span class="line">&#123;</span><br><span class="line">  public HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LHelloWorld;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.Throwable;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: invokedynamic <span class="comment">#2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">         5: astore_1</span><br><span class="line">         6: aload_1</span><br><span class="line">         7: invokeinterface <span class="comment">#3,  1            // InterfaceMethod java/lang/Runnable.run:()V</span></span><br><span class="line">        12: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 6</span><br><span class="line">        line 5: 12</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      13     0  args   [Ljava/lang/String;</span><br><span class="line">            6       7     1     r   Ljava/lang/Runnable;</span><br><span class="line">    Exceptions:</span><br><span class="line">      throws java.lang.Throwable</span><br><span class="line"></span><br><span class="line">  private static void lambda<span class="variable">$main</span><span class="variable">$0</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line">         0: getstatic     <span class="comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         3: ldc           <span class="comment">#5                  // String hello</span></span><br><span class="line">         5: invokevirtual <span class="comment">#6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"HelloWorld.java"</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     public static final <span class="comment">#60= #59 of #63; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: <span class="comment">#29 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">    Method arguments:</span><br><span class="line">      <span class="comment">#30 ()V</span></span><br><span class="line">      <span class="comment">#31 invokestatic HelloWorld.lambda$main$0:()V</span></span><br><span class="line">      <span class="comment">#30 ()V</span></span><br></pre></td></tr></table></figure>

<p><code>invokedynamic</code>的操作形式是<code>invokedynamic indexbyte1 indexbyte2 0 0</code>，其中后两个0是写死的以便之后扩展，前两个参数联合起来<code>(indexbyte1 &lt;&lt; 8) | indexbyte2</code>指向常量池中的一项被称为动态调用点（call site）的符号引用，这里为字节码为<code>ba 0002 00 00</code>，即CallSite为第二个常量，其结构体声明为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_InvokeDynamic_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 bootstrap_method_attr_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>bootstrap_method_attr_index</code>指向了<code>bootstrap_methods</code>数组中的某个<code>bootstrap method</code>，从反编译出的信息可以看到这个<code>invokedynamic</code>的字节码指令为<code>12 0000 0020</code>，标明它的引导方法是第0个，方法类型参考第32个常量<code>run:()Ljava/lang/Runnable;</code>。引导方法<code>Bootstrap Method</code>被保存在新增的<code>BootstrapMethods</code>属性中，其完整定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 num_bootstrap_methods;</span><br><span class="line">    &#123;   u2 bootstrap_method_ref;</span><br><span class="line">        u2 num_bootstrap_arguments;</span><br><span class="line">        u2 bootstrap_arguments[num_bootstrap_arguments];</span><br><span class="line">    &#125; bootstrap_methods[num_bootstrap_methods];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里相关的二进制代码为<code>1c 00 00 00 0c 00 01 00 1d 00 03 00 1e 00 1f 00 1e</code>，表示只有一个引导方法，对应的<code>MethodHandle</code>为<code>java/lang/invoke/LambdaMetafactory.metafactory</code>这一静态方法，其完整签名为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">metafactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MethodHandles.Lookup caller, // 代表查找上下文与调用者的访问权限, 使用invokedynamic指令时, JVM会自动自动填充这个参数, 这里JVM为我们填充为Lookup(HelloWorld.class, (PUBLIC | PRIVATE | PROTECTED | PACKAGE)</span>) 意思是这个Lookup实例可以访问HelloWorld类的所有成员.</span></span><br><span class="line"><span class="function">    String invokedName,  <span class="comment">//  要实现的方法的名字, 使用invokedynamic时, JVM自动帮我们填充(填充内容来自常量池InvokeDynamic.NameAndType.Name), 这里填充为run</span></span></span><br><span class="line"><span class="function">    MethodType invokedType,  <span class="comment">// 调用点期望的方法参数的类型和返回值的类型(方法signature). 使用invokedynamic指令时, JVM会自动自动填充这个参数，填充内容来自常量池InvokeDynamic.NameAndType.Type), 在这里参数为空, 返回值类型为java/lang/Runnable, 表示这个调用点的目标方法的参数为空, 然后invokedynamic执行完后会返回一个Runnable实例</span></span></span><br><span class="line"><span class="function">    MethodType samMethodType,  <span class="comment">// 函数对象将要实现的接口方法类型, 这里运行时, 值为()V，即Runnable.run()方法的类型</span></span></span><br><span class="line"><span class="function">    MethodHandle implMethod, <span class="comment">// 一个直接方法句柄(DirectMethodHandle), 描述在调用时将被执行的具体实现方法 (包含适当的参数适配, 返回类型适配,和在调用参数前附加上捕获的参数), 在这里为 HelloWorld.lambda$main$0:()V 方法的方法句柄. </span></span></span><br><span class="line"><span class="function">    MethodType instantiatedMethodType) <span class="comment">// 函数接口方法替换泛型为具体类型后的方法类型, 通常和samMethodType一样，除非发生了类型擦除</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> LambdaConversionException</span></span><br></pre></td></tr></table></figure>

<p>在执行<code>invokedynamic</code>时会执行其关联的引导方法，前三个参数由JVM自动填充，后三个参数来自属性表中的<code>bootstrap_arguments</code>。可以看到，lambda表达式的具体实现被编译成了<code>HelloWorld.lambda$main$0:()V</code>这样一个静态方法。执行完引导方法后，会返回一个<code>CallSite</code>对象，它的<code>target</code>属性关联了所调用的方法句柄，最后执行这个方法句柄。</p>
<p>值得一提的是，lambda表达式只是在“生成”的时候调用了<code>invokedynamic</code>，比如上面那个例子，即使没有<code>r.run();</code>这句，也会产生一条<code>invokedynamic</code>指令，换句话说实际上这里<code>invokedynamic</code>产生了一个<code>Runnable</code>对象，然后把它赋值到了一个局部变量。</p>
<h2 id="基于栈的字节码解释引擎"><a href="#基于栈的字节码解释引擎" class="headerlink" title="基于栈的字节码解释引擎"></a>基于栈的字节码解释引擎</h2><p>这段内容其实没啥好说的，举个例子，比如这样一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">4</span>;</span><br><span class="line">c = (a-c)*b;</span><br></pre></td></tr></table></figure>

<p>会翻译为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_1</span><br><span class="line">1: istore_1</span><br><span class="line">2: iconst_2</span><br><span class="line">3: istore_2</span><br><span class="line">4: iconst_4</span><br><span class="line">5: istore_3</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_3</span><br><span class="line">8: isub</span><br><span class="line">9: iload_2</span><br><span class="line">10: imul</span><br><span class="line">11: istore_3</span><br></pre></td></tr></table></figure>

<p>意思是把常量1入栈，出栈后保存到局部变量1；常量2入栈，出栈后保存到局部变量2；常量4入栈，出栈后保存到局部变量3；局部变量1和3分别入栈，出栈两个int、相减后入栈，将变量2入栈，出栈两个变量、相乘后出栈，此时栈里只有一个int（-6），最后出栈并保存到变量3。</p>
<p>可以看出真的这么跑的化执行效率很低，一般JVM都会对此进行优化。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/JVM/" rel="tag"># JVM</a>
            
              <a href="/tags/lambda表达式/" rel="tag"># lambda表达式</a>
            
              <a href="/tags/invokedynamic/" rel="tag"># invokedynamic</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/06/jvm5/" rel="next" title="JVM学习（5）类加载机制">
                  <i class="fa fa-chevron-left"></i> JVM学习（5）类加载机制
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/09/16/jvm7/" rel="prev" title="JVM学习（7）编译期优化">
                  JVM学习（7）编译期优化 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时栈帧结构"><span class="nav-number">1.</span> <span class="nav-text">运行时栈帧结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#局部变量表（local-variable-table）"><span class="nav-number">1.1.</span> <span class="nav-text">局部变量表（local variable table）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作数栈（operand-stack）"><span class="nav-number">1.2.</span> <span class="nav-text">操作数栈（operand stack）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态连接（dynamic-linking）"><span class="nav-number">1.3.</span> <span class="nav-text">动态连接（dynamic linking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法返回地址（Normal-Abrupt-Method-Invocation-Completion）"><span class="nav-number">1.4.</span> <span class="nav-text">方法返回地址（Normal/Abrupt Method Invocation Completion）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附加信息"><span class="nav-number">1.5.</span> <span class="nav-text">附加信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法调用"><span class="nav-number">2.</span> <span class="nav-text">方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析（resolution）"><span class="nav-number">2.1.</span> <span class="nav-text">解析（resolution）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分派（dispatch）"><span class="nav-number">2.2.</span> <span class="nav-text">分派（dispatch）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态分派"><span class="nav-number">2.2.1.</span> <span class="nav-text">静态分派</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态分派"><span class="nav-number">2.2.2.</span> <span class="nav-text">动态分派</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单分派和多分派"><span class="nav-number">2.2.3.</span> <span class="nav-text">单分派和多分派</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态分派的实现"><span class="nav-number">2.2.4.</span> <span class="nav-text">动态分派的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态类型语言支持"><span class="nav-number">2.3.</span> <span class="nav-text">动态类型语言支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MethodHandle"><span class="nav-number">2.3.1.</span> <span class="nav-text">MethodHandle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invokedynamic指令"><span class="nav-number">2.3.2.</span> <span class="nav-text">invokedynamic指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于栈的字节码解释引擎"><span class="nav-number">3.</span> <span class="nav-text">基于栈的字节码解释引擎</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
