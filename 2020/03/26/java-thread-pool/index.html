<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta name="description" content="线程池简单来说就是静态或动态的创建一些线程，需要以线程为单位执行任务时，交给已创建好的线程去执行即可。 吐个槽，不得不说if后面无论是否是单条语句，都加上{}还是很有必要的，标准库相关的代码没花括号看得人头疼。 需要实现的接口Java的线程池实例类型一般是ThreadPoolExecutor，继承关系是ThreadPoolExecutor&amp;lt;-AbstractExecutorService&amp;l">
<meta name="keywords" content="Java,Thread Pool">
<meta property="og:type" content="article">
<meta property="og:title" content="Java线程池学习（1）">
<meta property="og:url" content="https://maxiaoxin.github.io/2020/03/26/java-thread-pool/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:description" content="线程池简单来说就是静态或动态的创建一些线程，需要以线程为单位执行任务时，交给已创建好的线程去执行即可。 吐个槽，不得不说if后面无论是否是单条语句，都加上{}还是很有必要的，标准库相关的代码没花括号看得人头疼。 需要实现的接口Java的线程池实例类型一般是ThreadPoolExecutor，继承关系是ThreadPoolExecutor&amp;lt;-AbstractExecutorService&amp;l">
<meta property="og:locale" content="cn">
<meta property="og:image" content="https://maxiaoxin.github.io/images/thread_pool_state_trans.jpg">
<meta property="og:updated_time" content="2020-04-01T10:54:50.283Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java线程池学习（1）">
<meta name="twitter:description" content="线程池简单来说就是静态或动态的创建一些线程，需要以线程为单位执行任务时，交给已创建好的线程去执行即可。 吐个槽，不得不说if后面无论是否是单条语句，都加上{}还是很有必要的，标准库相关的代码没花括号看得人头疼。 需要实现的接口Java的线程池实例类型一般是ThreadPoolExecutor，继承关系是ThreadPoolExecutor&amp;lt;-AbstractExecutorService&amp;l">
<meta name="twitter:image" content="https://maxiaoxin.github.io/images/thread_pool_state_trans.jpg">
  <link rel="canonical" href="https://maxiaoxin.github.io/2020/03/26/java-thread-pool/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java线程池学习（1） | 读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2020/03/26/java-thread-pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java线程池学习（1）

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-26T00:00:00+08:00">2020-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-01 18:54:50" itemprop="dateModified" datetime="2020-04-01T18:54:50+08:00">2020-04-01</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>线程池简单来说就是静态或动态的创建一些线程，需要以线程为单位执行任务时，交给已创建好的线程去执行即可。</p>
<p>吐个槽，不得不说<code>if</code>后面无论是否是单条语句，都加上<code>{}</code>还是很有必要的，标准库相关的代码没花括号看得人头疼。</p>
<h2 id="需要实现的接口"><a href="#需要实现的接口" class="headerlink" title="需要实现的接口"></a>需要实现的接口</h2><p>Java的线程池实例类型一般是<code>ThreadPoolExecutor</code>，继承关系是<code>ThreadPoolExecutor</code>&lt;-<code>AbstractExecutorService</code>&lt;-<code>ExecutorService</code>&lt;-<code>Executor</code>，对外暴露了这些接口：</p>
<p><b>Executor</b>：最上层的线程池接口</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void execute(Runnable)</code></td>
<td>要求线程池执行<code>Runnable</code>指向的任务</td>
</tr>
</tbody></table>
<p><b>ExecutorService</b>：暴露了一些通用的线程池接口</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>shutdown()</code></td>
<td>停止线程池，并拒绝添加新任务，但对已提交的任务（包括正在执行的和在阻塞队列中的）没有影响；可以重复执行</td>
</tr>
<tr>
<td><code>shutdownNow()</code></td>
<td>立即停止线程池，并拒绝添加新任务，包括已提交的任务。会尝试中断所有线程</td>
</tr>
<tr>
<td><code>isTerminated()</code></td>
<td>判断所有线程是否已停止执行。只有在调用<code>shutdown</code>和<code>shutdownNow</code>后才可能返回true</td>
</tr>
<tr>
<td><code>boolean awaitTermination(long, TimeUnit)</code></td>
<td>阻塞并等待所有线程执行完毕，带超时判断。同样的，只有在调用<code>shutdown</code>和<code>shutdownNow</code>后才可能返回true</td>
</tr>
<tr>
<td><code>submit(Callable)</code><br><code>submit(Runnable)</code><br><code>submit(Runnable,T)</code></td>
<td>提交一个带Future的任务。第三个方法由于<code>Runnable</code>没有返回值，但某些时候又需要一个返回值，就可以当参数传进去，该参数可以为<code>null</code></td>
</tr>
<tr>
<td><code>invokeAll(Collection&lt;Callable)</code><br><code>invokeAll(Collection&lt;Callable&gt;,long,TimeUnit)</code></td>
<td>提交一批任务，事实上底层还是依次调用<code>execute</code>，所以这个命名有点让人产生疑惑</td>
</tr>
<tr>
<td><code>invokeAny(Collection&lt;Callable&gt;)</code><br><code>invokeAny(Collection&lt;Callable&gt;, long, TimeUnit)</code></td>
<td>提交一批任务，其中只要一个结束就返回</td>
</tr>
</tbody></table>
<p><b>AbstractExecutorService</b>：对部分接口做了一些简单实现，比如<code>Future&lt;?&gt; submit(Runnable)</code>最终会通过<code>execute(Runnable)</code>实现</p>
<p><b>ThreadPoolExecutor</b>：线程池的最终实现类</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>setThreadFactory(ThreadFactory)</code><br><code>getThreadFactory()</code></td>
<td>设置/获取线程工厂</td>
</tr>
<tr>
<td><code>setRejectedExecutionHandler(RejectedExecutionHandler)</code><br><code>getRejectedExecutionHandler()</code></td>
<td>设置/获取拒绝任务时的回调函数</td>
</tr>
<tr>
<td><code>setCorePoolSize(int)</code><br><code>getCorePoolSize()</code></td>
<td>设置/获取核心线程数，如果比当前的小，则尝试停掉空闲的线程；如果比当前的值大，则尝试添加线程</td>
</tr>
<tr>
<td><code>prestartCoreThread()</code><br><code>prestartAllCoreThreads()</code></td>
<td>预启动一个/所有核心线程</td>
</tr>
<tr>
<td><code>allowCoreThreadTimeOut(boolean)</code><br><code>allowsCoreThreadTimeOut()</code></td>
<td>设置/获取是否允许在一段时间后销毁核心线程</td>
</tr>
<tr>
<td><code>setMaximumPoolSize(int)</code><br><code>getMaximumPoolSize()</code></td>
<td>设置/获取最大线程数</td>
</tr>
<tr>
<td><code>setKeepAliveTime(long,TimeUnit)</code><br><code>getKeepAliveTime(TimeUnit)</code></td>
<td>设置/获取线程在终止前可以保持空闲的时间限制</td>
</tr>
<tr>
<td><code>getQueue()</code></td>
<td>获取等待队列</td>
</tr>
<tr>
<td><code>remove(Runnable)</code><br><code>purge()</code></td>
<td>移除并尝试停止一个/所有任务</td>
</tr>
<tr>
<td><code>getPoolSize()</code></td>
<td>获取当前线程数量</td>
</tr>
<tr>
<td><code>getActiveCount()</code></td>
<td>获取当前正在运行的线程数，但不是准确值</td>
</tr>
<tr>
<td><code>getLargestPoolSize()</code></td>
<td>获取线程池迄今为止同时运行的最大线程数</td>
</tr>
<tr>
<td><code>getTaskCount()</code><br><code>getCompletedTaskCount()</code></td>
<td>获取已提交/完成的所有任务数，但不是准确值</td>
</tr>
</tbody></table>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>可以看出线程池实际上完全由<code>ThreadPoolExecutor</code>实现，其私有变量包括：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctl</code></td>
<td><code>AtomicInteger</code></td>
<td>保存线程池状态和执行线程数</td>
</tr>
<tr>
<td><code>workQueue</code></td>
<td><code>BlockingQueue&lt;Runnable&gt;</code></td>
<td>用来保存已提交待执行的任务</td>
</tr>
<tr>
<td><code>mainLock</code></td>
<td><code>ReentrantLock</code></td>
<td>主锁</td>
</tr>
<tr>
<td><code>termination</code></td>
<td><code>Condition</code></td>
<td>由<code>mainLock</code>生成，用来支持<code>awaitTermination()</code></td>
</tr>
<tr>
<td><code>workers</code></td>
<td><code>HashSet&lt;Worker&gt;</code></td>
<td>保存所有的工作线程</td>
</tr>
<tr>
<td><code>largestPoolSize</code></td>
<td><code>int</code></td>
<td>线程池最大容量</td>
</tr>
<tr>
<td><code>corePoolSize</code></td>
<td><code>int</code></td>
<td>核心线程数限制</td>
</tr>
<tr>
<td><code>maximumPoolSize</code></td>
<td><code>int</code></td>
<td>最大线程数限制</td>
</tr>
<tr>
<td><code>completedTaskCount</code></td>
<td><code>int</code></td>
<td>已完成的任务数</td>
</tr>
<tr>
<td><code>threadFactory</code></td>
<td><code>ThreadFactory</code></td>
<td>用以生成线程</td>
</tr>
<tr>
<td><code>handler</code></td>
<td><code>RejectedExecutionHandler</code></td>
<td>用以任务被拒绝时回调</td>
</tr>
<tr>
<td><code>keepAliveTime</code></td>
<td><code>long</code></td>
<td>线程在终止前可以保持空闲的时间限制</td>
</tr>
<tr>
<td><code>allowCoreThreadTimeOut</code></td>
<td><code>boolean</code></td>
<td>是否允许在一段时间后销毁核心线程</td>
</tr>
<tr>
<td><code>acc</code></td>
<td><code>AccessControlContext</code></td>
<td>访问控制的上下文</td>
</tr>
</tbody></table>
<h2 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h2><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>之前提到，线程池的状态保存在<code>ctl</code>变量中，它保存了两部分信息，其高位3位用来表示线程池状态，后29位表示正在运行中的线程数，放一起可以保证线程池状态和数量一致。线程池支持的状态包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>以<code>int</code>表示状态的一个好处是，在某些情况下这些状态是可以“比较”的，比如<code>runStateLessThan()</code>静态方法可以判断两个状态的顺序，<code>runStateAtLeast()</code>用以判断“至少”处于哪一个状态。事实上线程池的状态迁移规则也是一个偏序图，如下：</p>
<p><img src="/images/thread_pool_state_trans.jpg" alt="线程池状态迁移图"></p>
<p>笼统的说，线程池以<code>RUNNING</code>状态起始，在<code>shutdown()</code>方法执行后进入<code>SHUTDOWN</code>状态，在所有已提交的任务执行结束且所有线程结束后进入<code>TIDYING</code>状态；<code>RUNNING</code>或<code>SHUTDOWN</code>状态的线程池也可以在<code>shutdownNow()</code>方法后进入<code>STOP</code>状态，在所有线程结束后进入<code>TIDYING</code>。<code>TIDYING</code>状态的线程池通过调用<code>terminated()</code>进入<code>TERMINATED</code>状态，至此线程池彻底运行结束。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">      keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">  <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">  <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">  <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">  <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">  <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">  <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上是参数合法性检查和初始化一些稀有变量。不过<code>ctl</code>的<code>mainLock</code>没在这初始化，直接写在定义里了，其中<code>ctl</code>被初始化为<code>RUNNING</code>。</p>
<h3 id="任务执行逻辑"><a href="#任务执行逻辑" class="headerlink" title="任务执行逻辑"></a>任务执行逻辑</h3><p>无论是<code>submit()</code>还是<code>invoke*()</code>，最终都是调用<code>execute()</code>，它是执行任务的的底层接口，先来看一下它的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();  <span class="comment">// 当前线程池运行状态</span></span><br><span class="line">  <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 如果正在运行的线程小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 那么添加一个线程，这里以corePoolSize作为线程池大小限制的判断标准</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get(); <span class="comment">// 由于addWorker()可能失败，执行时间又比较长，所以再拿一次</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 如果当前线程池还在运行，并且添加到任务等待队列里</span></span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 再检查一下运行状态，如果处于非运行状态，则尝试移除该任务，并回调拒绝接口</span></span><br><span class="line">      reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// 否则的话，要么线程池还在运行，要么移除该任务失败，而由于这一时刻worker数量为0，就尝试创建一个空线程，这样就会有新的线程有可能执行该command</span></span><br><span class="line">      addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 走到这里，要么线程池不在运行，要么添加到等待队列失败，那么尝试再调用addWorker()，以maximumPoolSize作为限制标准，如果失败则执行拒绝逻辑</span></span><br><span class="line">    reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以核心还是<code>addWorker()</code>的流程，第二个参数如果为<code>true</code>，则以<code>corePoolSize</code>作为限制添加worker的标准，否则以<code>maximumPoolSize</code>为标准。那么反推回<code>execute()</code>，可以看出线程池在添加一个任务时，如果当前实际运行的线程数小于<code>corePoolSize</code>，那么就尝试创建一个worker；否则会在尝试添加进任务队列后，以<code>maximumPoolSize</code>为标准尝试添加worker</p>
<p><code>corePoolSize</code>可以为0，比如常见的<code>Executors.newCachedThreadPool()</code>就会创建一个<code>corePoolSize</code>为0且<code>maximumPoolSize</code>为<code>Integer.MAX_VALUE</code>的线程池。不过这个线程池的第一个线程不是通过<code>(workerCountOf(recheck) == 0</code>分支创建的，而是通过<code>!addWorker(command, false)</code>创建，这是因为<code>newCachedThreadPool()</code>使用的队列为<code>synchronousQueue</code>，这个queue没有缓存，只在有线程<code>take</code>/<code>poll</code>的时候，<code>offer</code>才能返回<code>true</code>，否则无法将任务入队，意味着只有存在空闲线程的时候第一个分支才能通过。在这种机制下添加任务时，要么立即创建一个新的线程去执行，要么由一个空闲的线程去执行，不会使用等待队列作为任务缓存，所以一般最好别用<code>newCachedThreadPool()</code>创建线程池。</p>
<p><code>addWorker</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  retry:</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c); <span class="comment">// 当前线程池运行状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">      ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">      firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">      ! workQueue.isEmpty()))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">      <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) <span class="comment">// 这里core判断应该用corePoolSize限制还是用maximumPoolSize限制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">// 尝试对当前线程数自增，如果成功，则跳出最外层循环</span></span><br><span class="line">        <span class="keyword">break</span> retry;</span><br><span class="line">      c = ctl.get(); <span class="comment">// 重新拿到线程池运行状态</span></span><br><span class="line">      <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// 如果发现不一致，则重新执行外层循环</span></span><br><span class="line">        <span class="keyword">continue</span> retry;</span><br><span class="line">      <span class="comment">// 如果一致，说明是CAS操作失败，重试内层循环即可</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">  Worker w = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">// 创建一个Worker实例，firstTask是第一个要运行的命令</span></span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread; <span class="comment">// Worker实例会初始化一个Thread对象</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123; <span class="comment">// t不为空意味着一个线程已经被创建好了</span></span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;  <span class="comment">// 拿到mainLock</span></span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新检查线程池状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">        <span class="keyword">if</span> (rs &lt; SHUTDOWN || <span class="comment">// 如果线程池仍处于RUNNING状态</span></span><br><span class="line">            (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123; <span class="comment">// 或者已经是running了，但firstTask为空</span></span><br><span class="line">          <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 如果这个线程已启动且没有结束，这是非法状态</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">          workers.add(w); <span class="comment">// 添加worker</span></span><br><span class="line">          <span class="keyword">int</span> s = workers.size(); <span class="comment">// 可能需要更新最大值</span></span><br><span class="line">          <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = s;</span><br><span class="line">          workerAdded = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (workerAdded) &#123; <span class="comment">// 在这里启动t</span></span><br><span class="line">        t.start();</span><br><span class="line">        workerStarted = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">      addWorkerFailed(w); <span class="comment">// 如果失败了，那么走失败流程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加worker失败的流程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">      workers.remove(w); <span class="comment">// 从列表中移除worker</span></span><br><span class="line">    decrementWorkerCount(); <span class="comment">// 减少worker数</span></span><br><span class="line">    tryTerminate(); <span class="comment">//尝试停止线程，之后解释</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是根据线程池当前状态，尝试添加一个新线程，只是很多地方使用了CAS以提高并发度，导致一些代码阅读起来比较麻烦</p>
<p>线程池会将创建好的Worker添加进<code>workers</code>散列表中，它保存了所有实际运行的线程，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Thread thread; <span class="comment">// 对应的线程实例</span></span><br><span class="line">  Runnable firstTask; <span class="comment">// 第一个要运行的任务，可以为null</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks; <span class="comment">// 已完成的任务数</span></span><br><span class="line"></span><br><span class="line">  Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// 设置锁状态为-1,直到开始运行</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写Runnable.run()接口</span></span><br><span class="line">    runWorker(<span class="keyword">this</span>); <span class="comment">// 实际上调用的是ThreadPoolExecutor.runWorker()</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123; <span class="comment">// 复写排他锁判断逻辑</span></span><br><span class="line">    <span class="keyword">return</span> getState() != <span class="number">0</span>; <span class="comment">// 只要不为0就表示已上锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; <span class="comment">// 复写获取锁的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; <span class="comment">// 尝试将状态CAS为1</span></span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 设置排他锁的持有线程为当前线程</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; <span class="comment">// 释放锁</span></span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 复写其他的锁逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面搞那么麻烦，主要是为了这里</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// 只有拿到排他锁后才能对线程发送中断信号</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        t.interrupt();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂且不论<code>AbstractQueuedSynchronizer</code>的原理，简单来说继承AQS的类可以提供互斥/共享锁的操作。<code>Worker</code>类将实际线程进行了包装，并维持了一个排他锁来保证线程操作的原子性。</p>
<p><code>Worker</code>的构造函数会初始化并运行一个线程，这个线程启动后会执行<code>worker.run()</code>，进而调用<code>runWorker()</code>方法，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread(); <span class="comment">// 当前线程，会不会某些情况下Thread.currentThread() != w.thread ？</span></span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>; <span class="comment">// 获取并清空worker的第一个任务</span></span><br><span class="line">  w.unlock(); <span class="comment">// 释放worker的锁</span></span><br><span class="line">  <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>; <span class="comment">// 是否因任务抛出的异常导致该线程异常退出</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有必要，则从任务队列里拿一个task出来</span></span><br><span class="line">      w.lock(); <span class="comment">// 获得worker的锁</span></span><br><span class="line">      <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || <span class="comment">// 如果线程池的状态是非STOP以上的状态（STOP，TIDYING，TERMINATED）</span></span><br><span class="line">        (Thread.interrupted() &amp;&amp; <span class="comment">// 或者本线程已被中断，（再检查一下线程池状态），并且当前线程还没有被中断</span></span><br><span class="line">        runStateAtLeast(ctl.get(), STOP))) &amp;&amp; <span class="comment">// 看文档的意思是，操作系统为每个线程维持了一个flag，来标明线程是否中断</span></span><br><span class="line">        !wt.isInterrupted()) <span class="comment">// Thread.interrupted()方法和wt.isInterrupted()底层调用的都是native方法isInterrupted(boolean)，但参数不一样，入参用以判断是否清空flag</span></span><br><span class="line">        wt.interrupt(); <span class="comment">// 那么尝试中断当前线程</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        beforeExecute(wt, task); <span class="comment">// ThreadPoolExecutor允许子类重写beforeExecute()，可以在一个任务执行前做一些事情</span></span><br><span class="line">        Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          task.run(); <span class="comment">// 执行任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException x) &#123; <span class="comment">// 异常处理</span></span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterExecute(task, thrown); <span class="comment">// 与beforeExecute()类似</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task = <span class="keyword">null</span>;</span><br><span class="line">        w.completedTasks++;</span><br><span class="line">        w.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    processWorkerExit(w, completedAbruptly); <span class="comment">// 最后做一些收尾工作，之后解释</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是每个<code>worker</code>的主循环，它不断的从任务队列里拉一个任务出来并执行，并根据线程池状态判断是否应当终止。取任务的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// 超时标志</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前线程池状态为SHUTDOWN以上，并且如果处于STOP以上或者任务队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">      decrementWorkerCount(); <span class="comment">// 减少worker数量？个人感觉这个逻辑应该扔到外层，但可能考虑到返回值只有空和非空两种情况，不好判断，因此放在这里了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(c); <span class="comment">// 当前线程数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; <span class="comment">// 是否允许延迟停止核心线程</span></span><br><span class="line">    <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) <span class="comment">// 如果线程数超过了最大线程数，或者超时</span></span><br><span class="line">        &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123; <span class="comment">// 并且线程数大于1或者任务队列为空</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="comment">// 那么就尝试减少worker数量，并返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// CAS失败了就重试</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Runnable r = timed ? <span class="comment">// 是否带超时的取队列元素</span></span><br><span class="line">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">        workQueue.take();</span><br><span class="line">      <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">      timedOut = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">      timedOut = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池终止逻辑"><a href="#线程池终止逻辑" class="headerlink" title="线程池终止逻辑"></a>线程池终止逻辑</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><p>停止线程池一般通过<code>shutdown()</code>或<code>shutdownNow()</code>。这里先看一下<code>shutdown()</code>及相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkShutdownAccess(); <span class="comment">// 检查是否有权限shutdown每一个worker</span></span><br><span class="line">    advanceRunState(SHUTDOWN);  <span class="comment">// 提升线程池状态至SHUTDOWN</span></span><br><span class="line">    interruptIdleWorkers(); <span class="comment">// 尝试中断所有空闲线程，它最终会调用interruptIdleWorkers(false)</span></span><br><span class="line">    onShutdown(); <span class="comment">// 空方法，允许子类复写</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提升线程池的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateAtLeast(c, targetState) || <span class="comment">// 终止条件</span></span><br><span class="line">        ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))) <span class="comment">// CAS</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断空闲线程，可以选择中断一个或者终止所有空闲线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">      Thread t = w.thread;</span><br><span class="line">      <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; <span class="comment">// 当线程处于非中断状态，并且立即拿到锁后</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          t.interrupt(); <span class="comment">// 尝试中断</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (onlyOne) <span class="comment">// 不管成没成功，只要flag为true就停止循环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试终止线程池</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) || <span class="comment">// 如果当前线程池处于RUNNING</span></span><br><span class="line">        runStateAtLeast(c, TIDYING) || <span class="comment">// 或者在TIDYING或TERMINATED</span></span><br><span class="line">        (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) <span class="comment">// 或者处于SHUTDOWN且任务队列不为空</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// 要求正在运行的worker数量为0</span></span><br><span class="line">      interruptIdleWorkers(ONLY_ONE); <span class="comment">// 否则的话就尝试中断一个空闲的worker</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走到这说明当前线程池状态在SHUTDOWN或STOP，并且worker数量为0</span></span><br><span class="line">    <span class="comment">// 那么就可以进一步将线程池状态迁移至TIDYING，再迁移至TERMINATED</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123; <span class="comment">// CAS，这保证了?-&gt;TIDYING-&gt;TERMINATED的操作只做一次</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          terminated(); <span class="comment">// 一个空方法，允许子类自定义当线程池终止时做一些事情</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ctl.set(ctlOf(TERMINATED, <span class="number">0</span>)); <span class="comment">// 最后将线程池状态转移到TERMINATED</span></span><br><span class="line">          termination.signalAll(); <span class="comment">// 并通知所有等待termination的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>checkShutdownAccess()</code>主要是检查当前线程是否有权限shutdown掉所有运行中的线程。</p>
<p><code>advanceRunState()</code>相对比较简单，就是不停的CAS去改变<code>ctl</code>的值，直到将状态“提升”至指定的状态或以上。</p>
<p><code>interruptIdleWorkers()</code>会尝试中断所有空闲线程。这里“空闲”的判断标准是<code>w.tryLock()</code>是否成功。在<code>runWorker()</code>方法中可以看到，在执行一个任务前会获取该worker的锁，因此可以用<code>tryLock()</code>来判断线程是否空闲。</p>
<p><code>shutdown()</code>是空方法，允许子类在<code>shutdown()</code>后可以做一些额外的事情</p>
<p><code>tryTerminate()</code>尝试将线程池状态从<code>SHUTDOWN</code>或<code>STOP</code>迁移至<code>TERMINATED</code>，并唤醒等待<code>termination</code>的线程。<code>termination</code>只会被<code>awaitTermination()</code>等待，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED)) <span class="comment">// 如果已经处于TERMINATED状态，则可以直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) <span class="comment">// 如果等待时间非法，则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      nanos = termination.awaitNanos(nanos); <span class="comment">// 设置超时并等待</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前看起来如果被<code>termination</code>唤醒，那么其实就说明已经<code>TERMINATED</code>了，不过可能考虑到扩展性，还是用循环包了起来。</p>
<p>接下来我们可以总结当调用<code>shutdown()</code>时发生了什么。假设线程池有若干线程在运行，其中有些线程空闲，并且任务队列不为空。当调用<code>shutdown()</code>和<code>awaitTermination()</code>后，线程池状态提升为<code>SHUTDOWN</code>，然后空闲的线程被中断，但由于任务队列不为空，因此<code>tryTerminate()</code>就直接返回了，主线程由于调用<code>awaitTermination()</code>进入等待状态。之后我们看每个线程的动作，也就是<code>runWorker()</code>方法，由于线程池状态没有到达<code>STOP</code>，因此还可以正常从任务队列里拿任务。在任务队列为空后，会执行<code>processWorkerExit()</code>，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly) <span class="comment">// 参数为true，说明该worker因为用户抛出的异常而终止</span></span><br><span class="line">    decrementWorkerCount(); <span class="comment">// 那么减少worker数量</span></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    completedTaskCount += w.completedTasks; <span class="comment">// 增加总完成数</span></span><br><span class="line">    workers.remove(w); <span class="comment">// 从workers里移除</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryTerminate(); <span class="comment">// 调用tryTerminate()，尝试停止线程池，不管结果如何</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123; <span class="comment">// 如果线程池状态为RUNNING或SHUTDOWN</span></span><br><span class="line">    <span class="comment">// 这里逻辑比较麻烦，大致上是判断要不要再创建一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123; <span class="comment">// 如果该线程是正常退出的</span></span><br><span class="line">      <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;  <span class="comment">// 如果允许回收线程，那么判断标准为0，否则为corePoolSize</span></span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty()) <span class="comment">// 如果判断标准为0，并且任务队列非空，则设为1</span></span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min) <span class="comment">// 如果已运行的线程数超过判断标准，则不继续创建worker</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 总的来说，如果线程异常退出，或者正在运行的线程数比需要的少，就再拉起一个线程</span></span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processWorkerExit()</code>除了更新统计数据外，会尝试调用<code>tryTerminate()</code>。在<code>SHUTDOWN</code>状态下，任务队列为空时能进入下面的处理逻辑，也就意味着该状态下正在运行的线程还会消费任务队列，直至任务队列为空。在任务队列为空后，该线程会更新线程池状态，再唤醒所有等待<code>termination</code>的线程，最后退出。被唤醒的线程就会发现此时线程池已结束，并且所有已提交的任务都被处理完成，因此有些说法将这种停止线程池的方式为“优雅地”。</p>
<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><p>和<code>shutdown()</code>相比，<code>shutdownNow()</code>就比较粗暴了，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Runnable&gt; tasks;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkShutdownAccess(); <span class="comment">// 权限检查</span></span><br><span class="line">    advanceRunState(STOP); <span class="comment">// 将线程池状态提升至STOP</span></span><br><span class="line">    interruptWorkers(); <span class="comment">// 中断所有worker</span></span><br><span class="line">    tasks = drainQueue(); <span class="comment">// 获取剩余的任务列表</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  tryTerminate(); <span class="comment">// 尝试终止线程池</span></span><br><span class="line">  <span class="keyword">return</span> tasks; <span class="comment">// 返回未处理完的任务列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">      w.interruptIfStarted(); <span class="comment">// 无论线程池的状态和worker的状态，都尝试发送中断信号</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将工作队列的任务全部返回回去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">  ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">  q.drainTo(taskList);</span><br><span class="line">  <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">        taskList.add(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾<code>runWorker()</code>方法，在线程池状态提升至<code>STOP</code>后，worker最终会因为无法通过<code>getTask()</code>获得任务从而退出执行，而<code>tryTerminate()</code>也会忽略工作队列长度去尝试改变线程池状态至<code>TERMINATED</code>，最后返回未执行的任务队列。</p>
<p>当然，即使执行<code>shutdownNow()</code>，也不能保证所有线程立即结束，只是worker不能取新的任务了；同样的，只有当所有任务都结束后才能唤醒<code>awaitTermination()</code>，这是因为<code>tryTerminate</code>使用<code>ctl.compareAndSet(c, ctlOf(TIDYING, 0))</code>作为CAS标准，显然只有所有线程都结束后才能使得<code>ctlOf(TIDYING, 0)</code>为真，从而执行<code>signalAll()</code>。</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Java/" rel="tag"># Java</a>
            
              <a href="/tags/Thread-Pool/" rel="tag"># Thread Pool</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2020/03/24/ceph3/" rel="next" title="Ceph学习（3） RGW简介">
                  <i class="fa fa-chevron-left"></i> Ceph学习（3） RGW简介
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#需要实现的接口"><span class="nav-number">1.</span> <span class="nav-text">需要实现的接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#私有变量"><span class="nav-number">2.</span> <span class="nav-text">私有变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心算法"><span class="nav-number">3.</span> <span class="nav-text">核心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池状态"><span class="nav-number">3.1.</span> <span class="nav-text">线程池状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">3.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务执行逻辑"><span class="nav-number">3.3.</span> <span class="nav-text">任务执行逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池终止逻辑"><span class="nav-number">3.4.</span> <span class="nav-text">线程池终止逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown"><span class="nav-number">3.4.1.</span> <span class="nav-text">shutdown()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdownNow"><span class="nav-number">3.4.2.</span> <span class="nav-text">shutdownNow()</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
