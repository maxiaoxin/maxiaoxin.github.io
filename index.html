<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="读书笔记">
<meta property="og:url" content="https://maxiaoxin.github.io/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记">
  <link rel="canonical" href="https://maxiaoxin.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2020/04/08/java-thread-local/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/04/08/java-thread-local/" class="post-title-link" itemprop="url">Java ThreadLocal学习</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-04-08 00:00:00 / Modified: 16:56:51" itemprop="dateCreated datePublished" datetime="2020-04-08T00:00:00+08:00">2020-04-08</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>之前因为一些情况希望每个线程有唯一上下文用以保存某些独享变量，所以学习了一下<code>ThreadLocal</code>，其简单用法大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;List&lt;String&gt;&gt; buffer = <span class="keyword">new</span> ThreadLocal&lt;&gt;(); <span class="comment">// 每个线程的buffer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  ThreadPool pool = <span class="keyword">new</span> ThreadPool();</span><br><span class="line">  pool.submit(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// 获取本线程的buffer</span></span><br><span class="line">    List&lt;String&gt; list = buffer.get();</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">      buffer.set(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用buffer做一些工作</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式一般是声明一个<code>static final</code>的静态变量，每个线程通过调用它的<code>set()</code>或<code>get()</code>方法就能拿到本线程独立的副本。</p>
<p>实现线程独占变量的一个方式是为每个线程关联一个唯一的线程上下文（类似于某些框架里的<code>session</code>）——实际上<code>ThreadLocal</code>的实现方式就是如此，只是稍微麻烦一些。这里先贴出<code>ThreadLocal.get()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前线程</span></span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  <span class="comment">// 拿到该线程对应的ThreadLocalMap</span></span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到对应的entry并返回</span></span><br><span class="line">    ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      T result = (T)e.value;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则设置初始值并返回</span></span><br><span class="line">  <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到线程t关联的ThreadLocalMap</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread类中的ThreadLocalMap成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置初值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T value = initialValue();</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为指定线程创建ThreadLocalMap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">  t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心问题在于<code>getMap(t)</code>、<code>map.getEntry(this)</code>和<code>setInitialValue()</code>的实现。第一个方法很简单，只是拿到<code>Thread</code>的成员而已；<code>setInitialValue()</code>也很简单，在线程没有关联<code>ThreadLocalMap</code>时创建一个。<code>set()</code>方法实现也类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  Thread t = Thread.currentThread();</span><br><span class="line">  ThreadLocalMap map = getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    map.set(<span class="keyword">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是在没有关联<code>ThreadLocalMap</code>的情况下创建一个，如果有关联则设置相应的entry。因此问题转换为<code>ThreadLocalMap</code>类做了哪些工作。</p>
<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p><code>ThreadLocalMap</code>本身是一个哈希表，但并没有采用<code>HashMap</code>，而是重新以开放定址法实现了一遍哈希表，并且它的entry是<code>WeakReference</code>。每个entry的key是<code>ThreadLocal</code>类，value是我们之前设定的value，当有冲突时，就顺序往下找，直到查找完或者找到对应的值，或者查找到null。</p>
<p>由于实现哈希表的流程比较复杂（特别是扩表和缩表），这里就略过了，只看几个基本的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">  <span class="comment">// entry定义，WeakReference类型</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">      <span class="keyword">super</span>(k);</span><br><span class="line">      value = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">  <span class="comment">// 所有的entry</span></span><br><span class="line">  <span class="keyword">private</span> Entry[] table;</span><br><span class="line">  <span class="comment">// entry数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY]; <span class="comment">// 初始化entry表</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>); <span class="comment">// 计算得到初值的位置</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue); <span class="comment">// 并设置这个entry</span></span><br><span class="line">    size = <span class="number">1</span>; <span class="comment">// 设置entry数量</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY); <span class="comment">// 设置扩表阈值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置kv</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>); <span class="comment">// 初始bucket id</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从i开始顺序循环查找entry</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">      <span class="comment">// 拿到这个entry的key</span></span><br><span class="line">      ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      <span class="comment">// 如果相等则设置后返回</span></span><br><span class="line">      <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">        e.value = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果key为null，说明这个弱引用被回收了，那么将这个entry的key和value换成新的就可以了</span></span><br><span class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">        replaceStaleEntry(key, value, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走到这说明找到了一个entry为null的slot，那么设置，并尝试清理出一些空闲的slot</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">      rehash();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据key找到对应的entry</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">      <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 如果没有直接找到，说明有可能是冲突，也可能weak引用被回收，需要考虑两种情况</span></span><br><span class="line">      <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开放定址法总会遇到一些entry为空的情况，这里还要考虑<code>WeakReference</code>随时可能被回收的情况。</p>
<p>另一个问题在于直接hash地址的计算，这里的计算方式为<code>key.threadLocalHashCode &amp; (table.length - 1)</code>，也就是<code>ThreadLocal</code>的某个成员变量对桶大小取摸。<code>threadLocalHashCode</code>在<code>ThreadLocal</code>初始化时设置，并且不会变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>; <span class="comment">// 步长</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger(); <span class="comment">// 全局id生成器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode(); <span class="comment">// 设置唯一id</span></span><br><span class="line">  <span class="comment">// id计算方式</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换言之，正常运行时会为每个<code>ThreadLocal</code>赋予一个不可变的全局唯一id，那么用这个值作为key自然是唯一的。</p>
<p>现在我们可以顺一下每个线程在访问<code>ThreadLocal</code>时的流程。当线程初次<code>set()</code>或<code>get()</code>时，会尝试设置当前线程关联的<code>ThreadLocalMap</code>，并根据<code>ThreadLocal</code>的id设置或获取对应的entry。在不考虑弱引用被回收的情况下，再次访问该<code>ThreadLocal</code>时，就可以拿到先前设置的entry。显然，由于不同的线程拥有不同的<code>ThreadLocalMap</code>，各个线程在调用<code>ThreadLocal.set()</code>和<code>ThreadLocal.get()</code>时就可以拿到本线程独享的entry了。</p>
<p>至于为什么要将entry的key设计为<code>WeakReference</code>，个人理解是一个线程可能会处理多个任务，有些任务设置<code>ThreadLocal</code>后忘了清理或者不方便清理，就会导致这个entry发生内存泄漏。不过即使如此，也只能让<code>ThreadLocalMap.table</code>中的entry的key被置为null，value还是强引用，在这种情况下，如果没有额外操作，即使外界没有任何对该value的强引用，也会造成一段时间内的内存泄漏。因此有可能的话最好在运行完一个任务后调用<code>remove()</code>删掉该entry，以便尽快回收内存，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">      m.remove(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">        e.clear();</span><br><span class="line">        expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>WeakReference</code>的回收发生在没有强引用且触发GC时，因此一般会将<code>ThreadLocal</code>变量设为<code>static final</code>，保证其在类加载后强引用一直存在，那么它对应的entry.key就不会被回收，从而保证线程运行时总是能拿到对应的值。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2020/03/26/java-thread-pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/03/26/java-thread-pool/" class="post-title-link" itemprop="url">Java线程池学习（1）</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-26T00:00:00+08:00">2020-03-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-01 18:54:50" itemprop="dateModified" datetime="2020-04-01T18:54:50+08:00">2020-04-01</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>线程池简单来说就是静态或动态的创建一些线程，需要以线程为单位执行任务时，交给已创建好的线程去执行即可。</p>
<p>吐个槽，不得不说<code>if</code>后面无论是否是单条语句，都加上<code>{}</code>还是很有必要的，标准库相关的代码没花括号看得人头疼。</p>
<h2 id="需要实现的接口"><a href="#需要实现的接口" class="headerlink" title="需要实现的接口"></a>需要实现的接口</h2><p>Java的线程池实例类型一般是<code>ThreadPoolExecutor</code>，继承关系是<code>ThreadPoolExecutor</code>&lt;-<code>AbstractExecutorService</code>&lt;-<code>ExecutorService</code>&lt;-<code>Executor</code>，对外暴露了这些接口：</p>
<p><b>Executor</b>：最上层的线程池接口</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void execute(Runnable)</code></td>
<td>要求线程池执行<code>Runnable</code>指向的任务</td>
</tr>
</tbody></table>
<p><b>ExecutorService</b>：暴露了一些通用的线程池接口</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>shutdown()</code></td>
<td>停止线程池，并拒绝添加新任务，但对已提交的任务（包括正在执行的和在阻塞队列中的）没有影响；可以重复执行</td>
</tr>
<tr>
<td><code>shutdownNow()</code></td>
<td>立即停止线程池，并拒绝添加新任务，包括已提交的任务。会尝试中断所有线程</td>
</tr>
<tr>
<td><code>isTerminated()</code></td>
<td>判断所有线程是否已停止执行。只有在调用<code>shutdown</code>和<code>shutdownNow</code>后才可能返回true</td>
</tr>
<tr>
<td><code>boolean awaitTermination(long, TimeUnit)</code></td>
<td>阻塞并等待所有线程执行完毕，带超时判断。同样的，只有在调用<code>shutdown</code>和<code>shutdownNow</code>后才可能返回true</td>
</tr>
<tr>
<td><code>submit(Callable)</code><br><code>submit(Runnable)</code><br><code>submit(Runnable,T)</code></td>
<td>提交一个带Future的任务。第三个方法由于<code>Runnable</code>没有返回值，但某些时候又需要一个返回值，就可以当参数传进去，该参数可以为<code>null</code></td>
</tr>
<tr>
<td><code>invokeAll(Collection&lt;Callable)</code><br><code>invokeAll(Collection&lt;Callable&gt;,long,TimeUnit)</code></td>
<td>提交一批任务，事实上底层还是依次调用<code>execute</code>，所以这个命名有点让人产生疑惑</td>
</tr>
<tr>
<td><code>invokeAny(Collection&lt;Callable&gt;)</code><br><code>invokeAny(Collection&lt;Callable&gt;, long, TimeUnit)</code></td>
<td>提交一批任务，其中只要一个结束就返回</td>
</tr>
</tbody></table>
<p><b>AbstractExecutorService</b>：对部分接口做了一些简单实现，比如<code>Future&lt;?&gt; submit(Runnable)</code>最终会通过<code>execute(Runnable)</code>实现</p>
<p><b>ThreadPoolExecutor</b>：线程池的最终实现类</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>setThreadFactory(ThreadFactory)</code><br><code>getThreadFactory()</code></td>
<td>设置/获取线程工厂</td>
</tr>
<tr>
<td><code>setRejectedExecutionHandler(RejectedExecutionHandler)</code><br><code>getRejectedExecutionHandler()</code></td>
<td>设置/获取拒绝任务时的回调函数</td>
</tr>
<tr>
<td><code>setCorePoolSize(int)</code><br><code>getCorePoolSize()</code></td>
<td>设置/获取核心线程数，如果比当前的小，则尝试停掉空闲的线程；如果比当前的值大，则尝试添加线程</td>
</tr>
<tr>
<td><code>prestartCoreThread()</code><br><code>prestartAllCoreThreads()</code></td>
<td>预启动一个/所有核心线程</td>
</tr>
<tr>
<td><code>allowCoreThreadTimeOut(boolean)</code><br><code>allowsCoreThreadTimeOut()</code></td>
<td>设置/获取是否允许在一段时间后销毁核心线程</td>
</tr>
<tr>
<td><code>setMaximumPoolSize(int)</code><br><code>getMaximumPoolSize()</code></td>
<td>设置/获取最大线程数</td>
</tr>
<tr>
<td><code>setKeepAliveTime(long,TimeUnit)</code><br><code>getKeepAliveTime(TimeUnit)</code></td>
<td>设置/获取线程在终止前可以保持空闲的时间限制</td>
</tr>
<tr>
<td><code>getQueue()</code></td>
<td>获取等待队列</td>
</tr>
<tr>
<td><code>remove(Runnable)</code><br><code>purge()</code></td>
<td>移除并尝试停止一个/所有任务</td>
</tr>
<tr>
<td><code>getPoolSize()</code></td>
<td>获取当前线程数量</td>
</tr>
<tr>
<td><code>getActiveCount()</code></td>
<td>获取当前正在运行的线程数，但不是准确值</td>
</tr>
<tr>
<td><code>getLargestPoolSize()</code></td>
<td>获取线程池迄今为止同时运行的最大线程数</td>
</tr>
<tr>
<td><code>getTaskCount()</code><br><code>getCompletedTaskCount()</code></td>
<td>获取已提交/完成的所有任务数，但不是准确值</td>
</tr>
</tbody></table>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>可以看出线程池实际上完全由<code>ThreadPoolExecutor</code>实现，其私有变量包括：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctl</code></td>
<td><code>AtomicInteger</code></td>
<td>保存线程池状态和执行线程数</td>
</tr>
<tr>
<td><code>workQueue</code></td>
<td><code>BlockingQueue&lt;Runnable&gt;</code></td>
<td>用来保存已提交待执行的任务</td>
</tr>
<tr>
<td><code>mainLock</code></td>
<td><code>ReentrantLock</code></td>
<td>主锁</td>
</tr>
<tr>
<td><code>termination</code></td>
<td><code>Condition</code></td>
<td>由<code>mainLock</code>生成，用来支持<code>awaitTermination()</code></td>
</tr>
<tr>
<td><code>workers</code></td>
<td><code>HashSet&lt;Worker&gt;</code></td>
<td>保存所有的工作线程</td>
</tr>
<tr>
<td><code>largestPoolSize</code></td>
<td><code>int</code></td>
<td>线程池最大容量</td>
</tr>
<tr>
<td><code>corePoolSize</code></td>
<td><code>int</code></td>
<td>核心线程数限制</td>
</tr>
<tr>
<td><code>maximumPoolSize</code></td>
<td><code>int</code></td>
<td>最大线程数限制</td>
</tr>
<tr>
<td><code>completedTaskCount</code></td>
<td><code>int</code></td>
<td>已完成的任务数</td>
</tr>
<tr>
<td><code>threadFactory</code></td>
<td><code>ThreadFactory</code></td>
<td>用以生成线程</td>
</tr>
<tr>
<td><code>handler</code></td>
<td><code>RejectedExecutionHandler</code></td>
<td>用以任务被拒绝时回调</td>
</tr>
<tr>
<td><code>keepAliveTime</code></td>
<td><code>long</code></td>
<td>线程在终止前可以保持空闲的时间限制</td>
</tr>
<tr>
<td><code>allowCoreThreadTimeOut</code></td>
<td><code>boolean</code></td>
<td>是否允许在一段时间后销毁核心线程</td>
</tr>
<tr>
<td><code>acc</code></td>
<td><code>AccessControlContext</code></td>
<td>访问控制的上下文</td>
</tr>
</tbody></table>
<h2 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h2><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>之前提到，线程池的状态保存在<code>ctl</code>变量中，它保存了两部分信息，其高位3位用来表示线程池状态，后29位表示正在运行中的线程数，放一起可以保证线程池状态和数量一致。线程池支持的状态包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>以<code>int</code>表示状态的一个好处是，在某些情况下这些状态是可以“比较”的，比如<code>runStateLessThan()</code>静态方法可以判断两个状态的顺序，<code>runStateAtLeast()</code>用以判断“至少”处于哪一个状态。事实上线程池的状态迁移规则也是一个偏序图，如下：</p>
<p><img src="/images/thread_pool_state_trans.jpg" alt="线程池状态迁移图"></p>
<p>笼统的说，线程池以<code>RUNNING</code>状态起始，在<code>shutdown()</code>方法执行后进入<code>SHUTDOWN</code>状态，在所有已提交的任务执行结束且所有线程结束后进入<code>TIDYING</code>状态；<code>RUNNING</code>或<code>SHUTDOWN</code>状态的线程池也可以在<code>shutdownNow()</code>方法后进入<code>STOP</code>状态，在所有线程结束后进入<code>TIDYING</code>。<code>TIDYING</code>状态的线程池通过调用<code>terminated()</code>进入<code>TERMINATED</code>状态，至此线程池彻底运行结束。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">      keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">  <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">  <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">  <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">  <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">  <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">  <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上是参数合法性检查和初始化一些稀有变量。不过<code>ctl</code>的<code>mainLock</code>没在这初始化，直接写在定义里了，其中<code>ctl</code>被初始化为<code>RUNNING</code>。</p>
<h3 id="任务执行逻辑"><a href="#任务执行逻辑" class="headerlink" title="任务执行逻辑"></a>任务执行逻辑</h3><p>无论是<code>submit()</code>还是<code>invoke*()</code>，最终都是调用<code>execute()</code>，它是执行任务的的底层接口，先来看一下它的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();  <span class="comment">// 当前线程池运行状态</span></span><br><span class="line">  <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 如果正在运行的线程小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 那么添加一个线程，这里以corePoolSize作为线程池大小限制的判断标准</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get(); <span class="comment">// 由于addWorker()可能失败，执行时间又比较长，所以再拿一次</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 如果当前线程池还在运行，并且添加到任务等待队列里</span></span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 再检查一下运行状态，如果处于非运行状态，则尝试移除该任务，并回调拒绝接口</span></span><br><span class="line">      reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// 否则的话，要么线程池还在运行，要么移除该任务失败，而由于这一时刻worker数量为0，就尝试创建一个空线程，这样就会有新的线程有可能执行该command</span></span><br><span class="line">      addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 走到这里，要么线程池不在运行，要么添加到等待队列失败，那么尝试再调用addWorker()，以maximumPoolSize作为限制标准，如果失败则执行拒绝逻辑</span></span><br><span class="line">    reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以核心还是<code>addWorker()</code>的流程，第二个参数如果为<code>true</code>，则以<code>corePoolSize</code>作为限制添加worker的标准，否则以<code>maximumPoolSize</code>为标准。那么反推回<code>execute()</code>，可以看出线程池在添加一个任务时，如果当前实际运行的线程数小于<code>corePoolSize</code>，那么就尝试创建一个worker；否则会在尝试添加进任务队列后，以<code>maximumPoolSize</code>为标准尝试添加worker</p>
<p><code>corePoolSize</code>可以为0，比如常见的<code>Executors.newCachedThreadPool()</code>就会创建一个<code>corePoolSize</code>为0且<code>maximumPoolSize</code>为<code>Integer.MAX_VALUE</code>的线程池。不过这个线程池的第一个线程不是通过<code>(workerCountOf(recheck) == 0</code>分支创建的，而是通过<code>!addWorker(command, false)</code>创建，这是因为<code>newCachedThreadPool()</code>使用的队列为<code>synchronousQueue</code>，这个queue没有缓存，只在有线程<code>take</code>/<code>poll</code>的时候，<code>offer</code>才能返回<code>true</code>，否则无法将任务入队，意味着只有存在空闲线程的时候第一个分支才能通过。在这种机制下添加任务时，要么立即创建一个新的线程去执行，要么由一个空闲的线程去执行，不会使用等待队列作为任务缓存，所以一般最好别用<code>newCachedThreadPool()</code>创建线程池。</p>
<p><code>addWorker</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">  retry:</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c); <span class="comment">// 当前线程池运行状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">      ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">      firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">      ! workQueue.isEmpty()))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">      <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) <span class="comment">// 这里core判断应该用corePoolSize限制还是用maximumPoolSize限制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">// 尝试对当前线程数自增，如果成功，则跳出最外层循环</span></span><br><span class="line">        <span class="keyword">break</span> retry;</span><br><span class="line">      c = ctl.get(); <span class="comment">// 重新拿到线程池运行状态</span></span><br><span class="line">      <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// 如果发现不一致，则重新执行外层循环</span></span><br><span class="line">        <span class="keyword">continue</span> retry;</span><br><span class="line">      <span class="comment">// 如果一致，说明是CAS操作失败，重试内层循环即可</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">  Worker w = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">// 创建一个Worker实例，firstTask是第一个要运行的命令</span></span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread; <span class="comment">// Worker实例会初始化一个Thread对象</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123; <span class="comment">// t不为空意味着一个线程已经被创建好了</span></span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;  <span class="comment">// 拿到mainLock</span></span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 重新检查线程池状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">        <span class="keyword">if</span> (rs &lt; SHUTDOWN || <span class="comment">// 如果线程池仍处于RUNNING状态</span></span><br><span class="line">            (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123; <span class="comment">// 或者已经是running了，但firstTask为空</span></span><br><span class="line">          <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 如果这个线程已启动且没有结束，这是非法状态</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">          workers.add(w); <span class="comment">// 添加worker</span></span><br><span class="line">          <span class="keyword">int</span> s = workers.size(); <span class="comment">// 可能需要更新最大值</span></span><br><span class="line">          <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = s;</span><br><span class="line">          workerAdded = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (workerAdded) &#123; <span class="comment">// 在这里启动t</span></span><br><span class="line">        t.start();</span><br><span class="line">        workerStarted = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">      addWorkerFailed(w); <span class="comment">// 如果失败了，那么走失败流程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加worker失败的流程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">      workers.remove(w); <span class="comment">// 从列表中移除worker</span></span><br><span class="line">    decrementWorkerCount(); <span class="comment">// 减少worker数</span></span><br><span class="line">    tryTerminate(); <span class="comment">//尝试停止线程，之后解释</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是根据线程池当前状态，尝试添加一个新线程，只是很多地方使用了CAS以提高并发度，导致一些代码阅读起来比较麻烦</p>
<p>线程池会将创建好的Worker添加进<code>workers</code>散列表中，它保存了所有实际运行的线程，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Thread thread; <span class="comment">// 对应的线程实例</span></span><br><span class="line">  Runnable firstTask; <span class="comment">// 第一个要运行的任务，可以为null</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks; <span class="comment">// 已完成的任务数</span></span><br><span class="line"></span><br><span class="line">  Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// 设置锁状态为-1,直到开始运行</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写Runnable.run()接口</span></span><br><span class="line">    runWorker(<span class="keyword">this</span>); <span class="comment">// 实际上调用的是ThreadPoolExecutor.runWorker()</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123; <span class="comment">// 复写排他锁判断逻辑</span></span><br><span class="line">    <span class="keyword">return</span> getState() != <span class="number">0</span>; <span class="comment">// 只要不为0就表示已上锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; <span class="comment">// 复写获取锁的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; <span class="comment">// 尝试将状态CAS为1</span></span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">// 设置排他锁的持有线程为当前线程</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; <span class="comment">// 释放锁</span></span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 复写其他的锁逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面搞那么麻烦，主要是为了这里</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// 只有拿到排他锁后才能对线程发送中断信号</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        t.interrupt();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暂且不论<code>AbstractQueuedSynchronizer</code>的原理，简单来说继承AQS的类可以提供互斥/共享锁的操作。<code>Worker</code>类将实际线程进行了包装，并维持了一个排他锁来保证线程操作的原子性。</p>
<p><code>Worker</code>的构造函数会初始化并运行一个线程，这个线程启动后会执行<code>worker.run()</code>，进而调用<code>runWorker()</code>方法，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">  Thread wt = Thread.currentThread(); <span class="comment">// 当前线程，会不会某些情况下Thread.currentThread() != w.thread ？</span></span><br><span class="line">  Runnable task = w.firstTask;</span><br><span class="line">  w.firstTask = <span class="keyword">null</span>; <span class="comment">// 获取并清空worker的第一个任务</span></span><br><span class="line">  w.unlock(); <span class="comment">// 释放worker的锁</span></span><br><span class="line">  <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>; <span class="comment">// 是否因任务抛出的异常导致该线程异常退出</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有必要，则从任务队列里拿一个task出来</span></span><br><span class="line">      w.lock(); <span class="comment">// 获得worker的锁</span></span><br><span class="line">      <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || <span class="comment">// 如果线程池的状态是非STOP以上的状态（STOP，TIDYING，TERMINATED）</span></span><br><span class="line">        (Thread.interrupted() &amp;&amp; <span class="comment">// 或者本线程已被中断，（再检查一下线程池状态），并且当前线程还没有被中断</span></span><br><span class="line">        runStateAtLeast(ctl.get(), STOP))) &amp;&amp; <span class="comment">// 看文档的意思是，操作系统为每个线程维持了一个flag，来标明线程是否中断</span></span><br><span class="line">        !wt.isInterrupted()) <span class="comment">// Thread.interrupted()方法和wt.isInterrupted()底层调用的都是native方法isInterrupted(boolean)，但参数不一样，入参用以判断是否清空flag</span></span><br><span class="line">        wt.interrupt(); <span class="comment">// 那么尝试中断当前线程</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        beforeExecute(wt, task); <span class="comment">// ThreadPoolExecutor允许子类重写beforeExecute()，可以在一个任务执行前做一些事情</span></span><br><span class="line">        Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          task.run(); <span class="comment">// 执行任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException x) &#123; <span class="comment">// 异常处理</span></span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          afterExecute(task, thrown); <span class="comment">// 与beforeExecute()类似</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task = <span class="keyword">null</span>;</span><br><span class="line">        w.completedTasks++;</span><br><span class="line">        w.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    processWorkerExit(w, completedAbruptly); <span class="comment">// 最后做一些收尾工作，之后解释</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是每个<code>worker</code>的主循环，它不断的从任务队列里拉一个任务出来并执行，并根据线程池状态判断是否应当终止。取任务的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// 超时标志</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前线程池状态为SHUTDOWN以上，并且如果处于STOP以上或者任务队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">      decrementWorkerCount(); <span class="comment">// 减少worker数量？个人感觉这个逻辑应该扔到外层，但可能考虑到返回值只有空和非空两种情况，不好判断，因此放在这里了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(c); <span class="comment">// 当前线程数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; <span class="comment">// 是否允许延迟停止核心线程</span></span><br><span class="line">    <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) <span class="comment">// 如果线程数超过了最大线程数，或者超时</span></span><br><span class="line">        &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123; <span class="comment">// 并且线程数大于1或者任务队列为空</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="comment">// 那么就尝试减少worker数量，并返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// CAS失败了就重试</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Runnable r = timed ? <span class="comment">// 是否带超时的取队列元素</span></span><br><span class="line">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">        workQueue.take();</span><br><span class="line">      <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">      timedOut = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">      timedOut = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池终止逻辑"><a href="#线程池终止逻辑" class="headerlink" title="线程池终止逻辑"></a>线程池终止逻辑</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><p>停止线程池一般通过<code>shutdown()</code>或<code>shutdownNow()</code>。这里先看一下<code>shutdown()</code>及相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkShutdownAccess(); <span class="comment">// 检查是否有权限shutdown每一个worker</span></span><br><span class="line">    advanceRunState(SHUTDOWN);  <span class="comment">// 提升线程池状态至SHUTDOWN</span></span><br><span class="line">    interruptIdleWorkers(); <span class="comment">// 尝试中断所有空闲线程，它最终会调用interruptIdleWorkers(false)</span></span><br><span class="line">    onShutdown(); <span class="comment">// 空方法，允许子类复写</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提升线程池的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateAtLeast(c, targetState) || <span class="comment">// 终止条件</span></span><br><span class="line">        ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))) <span class="comment">// CAS</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断空闲线程，可以选择中断一个或者终止所有空闲线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">      Thread t = w.thread;</span><br><span class="line">      <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; <span class="comment">// 当线程处于非中断状态，并且立即拿到锁后</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          t.interrupt(); <span class="comment">// 尝试中断</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (onlyOne) <span class="comment">// 不管成没成功，只要flag为true就停止循环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试终止线程池</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) || <span class="comment">// 如果当前线程池处于RUNNING</span></span><br><span class="line">        runStateAtLeast(c, TIDYING) || <span class="comment">// 或者在TIDYING或TERMINATED</span></span><br><span class="line">        (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) <span class="comment">// 或者处于SHUTDOWN且任务队列不为空</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// 要求正在运行的worker数量为0</span></span><br><span class="line">      interruptIdleWorkers(ONLY_ONE); <span class="comment">// 否则的话就尝试中断一个空闲的worker</span></span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走到这说明当前线程池状态在SHUTDOWN或STOP，并且worker数量为0</span></span><br><span class="line">    <span class="comment">// 那么就可以进一步将线程池状态迁移至TIDYING，再迁移至TERMINATED</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123; <span class="comment">// CAS，这保证了?-&gt;TIDYING-&gt;TERMINATED的操作只做一次</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          terminated(); <span class="comment">// 一个空方法，允许子类自定义当线程池终止时做一些事情</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ctl.set(ctlOf(TERMINATED, <span class="number">0</span>)); <span class="comment">// 最后将线程池状态转移到TERMINATED</span></span><br><span class="line">          termination.signalAll(); <span class="comment">// 并通知所有等待termination的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>checkShutdownAccess()</code>主要是检查当前线程是否有权限shutdown掉所有运行中的线程。</p>
<p><code>advanceRunState()</code>相对比较简单，就是不停的CAS去改变<code>ctl</code>的值，直到将状态“提升”至指定的状态或以上。</p>
<p><code>interruptIdleWorkers()</code>会尝试中断所有空闲线程。这里“空闲”的判断标准是<code>w.tryLock()</code>是否成功。在<code>runWorker()</code>方法中可以看到，在执行一个任务前会获取该worker的锁，因此可以用<code>tryLock()</code>来判断线程是否空闲。</p>
<p><code>shutdown()</code>是空方法，允许子类在<code>shutdown()</code>后可以做一些额外的事情</p>
<p><code>tryTerminate()</code>尝试将线程池状态从<code>SHUTDOWN</code>或<code>STOP</code>迁移至<code>TERMINATED</code>，并唤醒等待<code>termination</code>的线程。<code>termination</code>只会被<code>awaitTermination()</code>等待，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED)) <span class="comment">// 如果已经处于TERMINATED状态，则可以直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) <span class="comment">// 如果等待时间非法，则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      nanos = termination.awaitNanos(nanos); <span class="comment">// 设置超时并等待</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前看起来如果被<code>termination</code>唤醒，那么其实就说明已经<code>TERMINATED</code>了，不过可能考虑到扩展性，还是用循环包了起来。</p>
<p>接下来我们可以总结当调用<code>shutdown()</code>时发生了什么。假设线程池有若干线程在运行，其中有些线程空闲，并且任务队列不为空。当调用<code>shutdown()</code>和<code>awaitTermination()</code>后，线程池状态提升为<code>SHUTDOWN</code>，然后空闲的线程被中断，但由于任务队列不为空，因此<code>tryTerminate()</code>就直接返回了，主线程由于调用<code>awaitTermination()</code>进入等待状态。之后我们看每个线程的动作，也就是<code>runWorker()</code>方法，由于线程池状态没有到达<code>STOP</code>，因此还可以正常从任务队列里拿任务。在任务队列为空后，会执行<code>processWorkerExit()</code>，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (completedAbruptly) <span class="comment">// 参数为true，说明该worker因为用户抛出的异常而终止</span></span><br><span class="line">    decrementWorkerCount(); <span class="comment">// 那么减少worker数量</span></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    completedTaskCount += w.completedTasks; <span class="comment">// 增加总完成数</span></span><br><span class="line">    workers.remove(w); <span class="comment">// 从workers里移除</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tryTerminate(); <span class="comment">// 调用tryTerminate()，尝试停止线程池，不管结果如何</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123; <span class="comment">// 如果线程池状态为RUNNING或SHUTDOWN</span></span><br><span class="line">    <span class="comment">// 这里逻辑比较麻烦，大致上是判断要不要再创建一个线程</span></span><br><span class="line">    <span class="keyword">if</span> (!completedAbruptly) &#123; <span class="comment">// 如果该线程是正常退出的</span></span><br><span class="line">      <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;  <span class="comment">// 如果允许回收线程，那么判断标准为0，否则为corePoolSize</span></span><br><span class="line">      <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty()) <span class="comment">// 如果判断标准为0，并且任务队列非空，则设为1</span></span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &gt;= min) <span class="comment">// 如果已运行的线程数超过判断标准，则不继续创建worker</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 总的来说，如果线程异常退出，或者正在运行的线程数比需要的少，就再拉起一个线程</span></span><br><span class="line">    addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processWorkerExit()</code>除了更新统计数据外，会尝试调用<code>tryTerminate()</code>。在<code>SHUTDOWN</code>状态下，任务队列为空时能进入下面的处理逻辑，也就意味着该状态下正在运行的线程还会消费任务队列，直至任务队列为空。在任务队列为空后，该线程会更新线程池状态，再唤醒所有等待<code>termination</code>的线程，最后退出。被唤醒的线程就会发现此时线程池已结束，并且所有已提交的任务都被处理完成，因此有些说法将这种停止线程池的方式为“优雅地”。</p>
<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><p>和<code>shutdown()</code>相比，<code>shutdownNow()</code>就比较粗暴了，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  List&lt;Runnable&gt; tasks;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    checkShutdownAccess(); <span class="comment">// 权限检查</span></span><br><span class="line">    advanceRunState(STOP); <span class="comment">// 将线程池状态提升至STOP</span></span><br><span class="line">    interruptWorkers(); <span class="comment">// 中断所有worker</span></span><br><span class="line">    tasks = drainQueue(); <span class="comment">// 获取剩余的任务列表</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  tryTerminate(); <span class="comment">// 尝试终止线程池</span></span><br><span class="line">  <span class="keyword">return</span> tasks; <span class="comment">// 返回未处理完的任务列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">  mainLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">      w.interruptIfStarted(); <span class="comment">// 无论线程池的状态和worker的状态，都尝试发送中断信号</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mainLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将工作队列的任务全部返回回去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">  ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">  q.drainTo(taskList);</span><br><span class="line">  <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">      <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">        taskList.add(r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾<code>runWorker()</code>方法，在线程池状态提升至<code>STOP</code>后，worker最终会因为无法通过<code>getTask()</code>获得任务从而退出执行，而<code>tryTerminate()</code>也会忽略工作队列长度去尝试改变线程池状态至<code>TERMINATED</code>，最后返回未执行的任务队列。</p>
<p>当然，即使执行<code>shutdownNow()</code>，也不能保证所有线程立即结束，只是worker不能取新的任务了；同样的，只有当所有任务都结束后才能唤醒<code>awaitTermination()</code>，这是因为<code>tryTerminate</code>使用<code>ctl.compareAndSet(c, ctlOf(TIDYING, 0))</code>作为CAS标准，显然只有所有线程都结束后才能使得<code>ctlOf(TIDYING, 0)</code>为真，从而执行<code>signalAll()</code>。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2020/03/24/ceph3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/03/24/ceph3/" class="post-title-link" itemprop="url">Ceph学习（3） RGW简介</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-03-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-24T00:00:00+08:00">2020-03-24</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-25 17:59:52" itemprop="dateModified" datetime="2020-03-25T17:59:52+08:00">2020-03-25</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>RGW（RADOS Gateway）是ceph对外提供的对象存储网关服务。RGW对外提供了HTTP Restful API允许用户通过S3或Swift兼容的API访问ceph，并使用rados客户端将数据映射到rados上，如下图所示。</p>
<p><img src="/images/ceph_rgw_arch.jpeg" alt="RGW框架"></p>
<p>RGW利用了ceph object的一些特性。对于一个ceph object，包含以下几个内容：</p>
<ul>
<li>Name：object名</li>
<li>Data content：实际数据</li>
<li>xattrs：object扩展属性，保存在文件系统中的文件扩展属性里，长度也受到文件系统的限制</li>
<li>omap：也是object扩展属性，但保存rocksdb/leveldb中</li>
</ul>
<p>使用omap的主要目的是为了提高性能。同样的，当object发生迁移/复制时，omap的内容也会迁移/复制。</p>
<p>而对于一般的对象存储服务，大概包含三个概念：</p>
<ul>
<li>User（用户）：对象存储服务的使用者，可以拥有一或多个bucket</li>
<li>Bucket（存储桶）：存储对象的容器，便于管理一批具有同一属性的object，如配额、授权管理等</li>
<li>对象（object）：存储的基本单位，允许用户保留一些扩展属性。一般由KV对组成，对象之间没有直接关系，且不支持编辑对象的部分内容</li>
</ul>
<h2 id="User"><a href="#User" class="headerlink" title="User"></a>User</h2><p>RGW保存了用户认证信息、访问控制权限信息和配额信息，以支持S3和Swift认证。RGW将用户数据保存在rados对象的数据部分，一个用户对应一个对象。比如一个对象可以是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rados -p .users.uid get test1 -</span></span><br><span class="line">test1	:PLMP37NFI61I4LA8IFZC(E5WDmoIVQe4NuCyB9SYHbKEx9RnhE4LCHgQ5GOCgtest1test1@google.comtest1PLMP37NFI61I4LA8IFZCHPLMP37NFI61I4LA8IFZC(E5WDmoIVQe4NuCyB9SYHbKEx9RnhE4LCHgQ5GOCg���������������������������������</span><br></pre></td></tr></table></figure>

<h2 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h2><p>同样的，一个bucket也对应了一个rados对象，保存了该bucket的一些必要信息，包括owner、quota、placement_rule、索引等。</p>
<p>在创建bucket时，RGW网关会同步创建一个或多个索引（index）对象，用于保存该bucket下的对象列表，以支持list bucket功能，因此上传/删除object时必须更新索引。比如我们创建了一个bucket <code>mybucket</code>和一个object <code>mybucket/hello.txt</code>，可以在<code>.rgw</code>中查找到该bucket的相关信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rados get mybucket -p .rgw  -</span></span><br><span class="line">�mybucket</span><br><span class="line">         .rgw.bucketsdefault.14100.2default.14100.2.rgw.buckets.index.rgw.buckets.extratest1p�z^</span><br></pre></td></tr></table></figure>

<p>解析出来是：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bucket"</span>: <span class="string">"mybucket"</span>,</span><br><span class="line">    <span class="attr">"pool"</span>: <span class="string">".rgw.buckets"</span>,</span><br><span class="line">    <span class="attr">"index_pool"</span>: <span class="string">".rgw.buckets.index"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"default.14100.2"</span>,</span><br><span class="line">    <span class="attr">"marker"</span>: <span class="string">"default.14100.2"</span>,</span><br><span class="line">    <span class="attr">"owner"</span>: <span class="string">"test1"</span>,</span><br><span class="line">    <span class="attr">"ver"</span>: <span class="string">"0#17"</span>,</span><br><span class="line">    <span class="attr">"master_ver"</span>: <span class="string">"0#0"</span>,</span><br><span class="line">    <span class="attr">"mtime"</span>: <span class="string">"2020-03-25 06:21:36.000000"</span>,</span><br><span class="line">    <span class="attr">"max_marker"</span>: <span class="string">"0#"</span>,</span><br><span class="line">    <span class="attr">"usage"</span>: &#123;</span><br><span class="line">        <span class="attr">"rgw.main"</span>: &#123;</span><br><span class="line">            <span class="attr">"size_kb"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"size_kb_actual"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">"num_objects"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"rgw.multimeta"</span>: &#123;</span><br><span class="line">            <span class="attr">"size_kb"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"size_kb_actual"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"num_objects"</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"bucket_quota"</span>: &#123;</span><br><span class="line">        <span class="attr">"enabled"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"max_size_kb"</span>: <span class="number">-1</span>,</span><br><span class="line">        <span class="attr">"max_objects"</span>: <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即它的索引保存在<code>.rgw.buckets.index</code>中，id为<code>default.14100.2</code>，数据保存在<code>.rgw.buckets</code>中。然后查看<code>.rgw.buckets.index/.dir.default.14100.2</code>（注意要加上<code>.dir.</code>）的omap：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rados listomapkeys -p .rgw.buckets.index .dir.default.14100.2 </span></span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure>

<p>接着就可以在数据池<code>.rgw.buckets</code>中查看对应的object的数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rados get -p .rgw.buckets default.14100.2_hello.txt -</span></span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<p>为了避免索引过大，bucket可能将索引进行分片，<code>object_name</code>到<code>shard</code>的映射关系默认是<code>hash(object_name)%num_shards</code></p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>RGW默认对单个object size最大为5GB（同S3，可以改），如果要上传更大的object可以使用分片上传。</p>
<p>我个人试下来，对于直接上传，无论大小，都会只对应于一个rados object。而通过分片上传的object则会生成为若干分片，并保存在数据池中，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rados ls -p .rgw.buckets | grep large-10</span></span><br><span class="line">default.14100.1_large-10</span><br><span class="line">...</span><br><span class="line">default.14100.1__multipart_large-10.2~JxmG9bBy-5xLiGwjMDjLz9ynnn18JyN.31</span><br><span class="line">default.14100.1__shadow_large-10.2~JxmG9bBy-5xLiGwjMDjLz9ynnn18JyN.40_1</span><br><span class="line">default.14100.1__multipart_large-10.2~JxmG9bBy-5xLiGwjMDjLz9ynnn18JyN.39</span><br><span class="line">default.14100.1__multipart_large-10.2~JxmG9bBy-5xLiGwjMDjLz9ynnn18JyN.36</span><br><span class="line">default.14100.1__shadow_large-10.2~JxmG9bBy-5xLiGwjMDjLz9ynnn18JyN.7_2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>第一个分片为同直接上传的object名。一般来说分片上传时，会要求除最后一个分片外，都应当是某个固定的大小。而对于每个分片，ceph写入时会将其按照<code>rgw_obj_stripe_size</code>（条带大小）拆分成若干小文件，命名形式分别是<code>{bucket_name}__multipart_{object_name}_{randid}.{part_id}</code>和<code>{bucket_name}__shadow_{object_name}_{randid}.{part_id}_{sub_id}</code>。每个分片的xattr属性都会保存如etag等object的附加属性，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rados listxattr -p .rgw.buckets default.14100.1__multipart_large-10.2~JxmG9bBy-5xLiGwjMDjLz9ynnn18JyN.31  </span></span><br><span class="line">user.rgw.acl</span><br><span class="line">user.rgw.etag</span><br><span class="line">user.rgw.x-amz-date</span><br><span class="line"></span><br><span class="line"><span class="comment"># rados getxattr -p .rgw.buckets default.14100.1__multipart_large-10.2~JxmG9bBy-5xLiGwjMDjLz9ynnn18JyN.31 user.rgw.etag</span></span><br><span class="line">bd2e7af438c489561bf7abb2475b6517</span><br></pre></td></tr></table></figure>

<p>而第一个分片会保存该object的所有meta信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rados listxattr -p .rgw.buckets default.14100.1_large-10                                                  </span></span><br><span class="line">user.rgw.acl</span><br><span class="line">user.rgw.content_type</span><br><span class="line">user.rgw.etag</span><br><span class="line">user.rgw.idtag</span><br><span class="line">user.rgw.manifest</span><br><span class="line">user.rgw.x-amz-date</span><br><span class="line">user.rgw.x-amz-meta-s3cmd-attrs</span><br><span class="line">user.rgw.x-amz-storage-class</span><br><span class="line"></span><br><span class="line"><span class="comment"># rados getxattr -p .rgw.buckets default.14100.1_large-10 user.rgw.etag</span></span><br><span class="line">77000380a2a1dbc5694c40f52fe5640f-41</span><br></pre></td></tr></table></figure>

<p>关于RGW如何处理认证就忽略了，不过有一个问题在于RGW如何区分swift请求还是S3请求。源码比较复杂，个人猜测应该还是根据HTTP包来区分，比如一个典型的S3请求可能是：</p>
<p><img src="/images/ceph_rgw_s3_request.jpeg" alt="S3请求"></p>
<p>而一个swift请求可能是</p>
<p><img src="/images/ceph_rgw_swift_request.jpeg" alt="Swift请求"></p>
<p>那么作为网关是可以区分出两种请求的</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2020/03/12/ceph2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/03/12/ceph2/" class="post-title-link" itemprop="url">Ceph学习（2） Object映射关系和BlueStore简介</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-03-12 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-12T00:00:00+08:00">2020-03-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-26 16:57:38" itemprop="dateModified" datetime="2020-03-26T16:57:38+08:00">2020-03-26</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ceph使用Rados存储实际数据。对象存储的一个特点是不支持/不需要很多文件系统的特性，比如目录，因此ceph采用了绕过文件系统、通过直接管理磁盘的方式来提高存读效率。</p>
<h2 id="Object映射关系"><a href="#Object映射关系" class="headerlink" title="Object映射关系"></a>Object映射关系</h2><h3 id="Pools（存储池）"><a href="#Pools（存储池）" class="headerlink" title="Pools（存储池）"></a>Pools（存储池）</h3><p>个人理解很像S3的bucket概念，可以将object进行分组区分，便于管理，比如防止重名、设置quota、设置存储类型（多副本/纠错）、ruleset、副本数等。</p>
<p>相对于S3的bucket，ceph中的pool的主要作用还是可以为不同组的object设置不同ruleset。比如可以创建两个pool，分别用以保存冷、热数据，对于热数据可以设置采用多副本模式、使用SSD osd，而对于冷数据可以使用raid模式、机械硬盘，从而提高效率。又或者对于不太重要的数据，可以将隔离级别降低，提高系统利用率。</p>
<p>每个pool有唯一的id。创建Ceph时有一些默认的pool，比如rbd，其id为0。常见的关于pool的操作包括：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ceph osd lspools <span class="comment"># 列出pools</span></span><br><span class="line">ceph osd pool create &#123;pool-name&#125; &#123;pg-num&#125; [&#123;pgp-num&#125;] [replicated] [crush-ruleset-name] [expected-num-objects] <span class="comment"># 创建pool</span></span><br><span class="line">ceph osd pool <span class="built_in">set</span>-quota &#123;pool-name&#125; [max_objects &#123;obj-count&#125;] [max_bytes &#123;bytes&#125;] <span class="comment"># 设置配额</span></span><br><span class="line">ceph osd pool delete &#123;pool-name&#125; [&#123;pool-name&#125; --yes-i-really-really-mean-it] <span class="comment"># 删除pool</span></span><br><span class="line">ceph osd pool rename &#123;current-pool-name&#125; &#123;new-pool-name&#125; <span class="comment"># 重命名pool</span></span><br><span class="line">rados df <span class="comment"># 查看统计信息</span></span><br><span class="line">ceph osd pool <span class="built_in">set</span> &#123;poolname&#125; size &#123;num-replicas&#125; <span class="comment"># 设置副本数</span></span><br></pre></td></tr></table></figure>

<h3 id="Placement-Groups（归置组）"><a href="#Placement-Groups（归置组）" class="headerlink" title="Placement Groups（归置组）"></a>Placement Groups（归置组）</h3><p>为了实现不同pool之间的隔离，Ceph并没有将object直接映射到osd，而是引入了placement group作为中间层，实现两级映射，如下图所示</p>
<p><img src="/images/ceph_pg_map.jpeg" alt="Ceph组织架构"></p>
<p>大致是通过oid(object id)和一些meta信息（如副本总数）算出一个hash值，得到pgid(placement group id)，再用pgid和crushmap算出映射到哪些osd。由于 Ceph 集群必须能增大或缩小、并动态地重均衡。如果让客户端“知道”哪个 OSD 有哪个对象，就会导致客户端和 OSD 紧耦合；相反， CRUSH 算法把对象映射到归置组、然后再把各归置组映射到一或多个 OSD ，这一间接层可以让 Ceph 在 OSD 守护进程和底层设备上线时动态地重均衡。</p>
<p>注：后来又看了下相关的读写源码分析，发现客户端并没有从MON读PG相关信息，PGID和对应的OSD都是客户端本地计算的。</p>
<p>pgid全局唯一，由monitor统一管理，一般是类似{pid}.1, {pid}.2, {pid}.3, … 这样的形式，即以pool id为前缀。由于pool的id是全局唯一的，因此只要每个pool内的pgid不冲突就可以保证pgid全局唯一。</p>
<p>与CRUSH算法类似，oid到pgid的映射也需要考虑扩展性和负载均衡。这个问题很像redis的hash表的扩展，redis采用的策略是使用2<sup>n</sup>作为掩码，从而导致扩展时每个桶迁移的时候只有一半的数据需要迁移。不过ceph并没有规定pg_num只能取2<sup>n</sup>，因此采用了stable_mod算法，以减少迁移量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint32 <span class="title">stable_mod</span><span class="params">(uint32 hash, uint32 pg_num, uint32 mask)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((hash &amp; mask) &lt; pg_num)&#123;</span><br><span class="line">    <span class="keyword">return</span> hash &amp; mask;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hash &amp; (mask &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路和之前提到的类似，通过将二进制低位相同的object尽量放置在一起。但简单的用掩码做与运算，会导致一部分object落在无效的pg上，因此将这些无效的pg重映射到低位相同的pg，达到类似的效果。</p>
<p>显然这种做法会导致平均意义上部分pg映射到的object数是其他pg的两倍，不过迁移时确实能降低大部分移动工作。比如pg总数从10个提高到13个时，大概有18.75%的数据需要迁移，而如果用直接取摸的做法会有92.307%的数据要迁移。考虑到pgid到OSD的映射也起到一定负载均衡的效果，因此总的来说这个算法还是比较理想的。</p>
<p>pg扩展时一部分数据迁移称为pg分裂。采用stable_mod的另一个好处是，在使用FileStore作为存储引擎时，可以以逆序hash作为目录的方式存储object，这样当pg分裂时可以通过改动一部分子目录就可以获得待迁移的数据，再将其移动到对应的osd即可。</p>
<p>由此可以建立object-PG-OSD的映射关系。对于多副本模式，ceph写的时候会先去请求primary OSD，primary OSD接受到请求后会向所有副本发起写请求并写入本地，在所有副本响应成功后通知客户端写成功。读流程相对而言比较简单，直接读某个副本即可。</p>
<h2 id="BlueStore简介"><a href="#BlueStore简介" class="headerlink" title="BlueStore简介"></a>BlueStore简介</h2><p>为了提高访问磁盘的效率，ceph可以选择使用BlueStore直接管理硬盘，不再进行rados对象和文件之间的转换，从而简化I/O路径。基本架构如下图所示，</p>
<p><img src="/images/ceph_bluestore.jpg" alt="BlueStore基本架构"></p>
<p>简单来说，BlueStore默认采用位图模式管理磁盘，并使用RockDB管理元数据；且BlueStore实现了一个小的文件系统BlueFS，支持BlueRocksEnv接口，从而能够运行RocksDB。BlueStore和BlueFS可以共享设备，也可以指定不同设备。BlueStore中的数据大致分为三类：</p>
<ul>
<li>对象数据，一般保存在慢速设备中</li>
<li>元数据（如onode），由BlueFS直接管理，保存在高速设备中</li>
<li>WAL，由BlueFS直接管理，保存在超高速设备中</li>
</ul>
<p>实际上如果没有足够容量的高速设备，WAL和sst也可以保存在慢速设备中，BlueStore会将这部分硬盘空间标为BlueFS正在使用。</p>
<p>管理磁盘和内存最大的不同点在于磁盘需要以块为单位扇入/扇出，通常会以block为单位（默认4k）读写，不过为了管理方便ceph的最小分配单元min_alloc_size是block大小的整数倍（SSD默认16K，HDD默认64K）。如下图所示，Bluestore中的一个object的元数据对应于一个onode数据结构，被持久化到rocksdb中。每个onode包含若干lextent（逻辑段，可以不连续，即bluestore支持稀疏写，数据校验、压缩、共享也是以lextent为基本单位的），每个lextent会映射到某个blob上的一个区间。一个blob可能包含多个pextent，这些pextent最终对应于磁盘上的某一块数据。</p>
<p><img src="/images/ceph_bluestore_disk_arch.jpg" alt="Object到磁盘的映射"></p>
<p>Bluestore的读流程相对简单，只需要读到相应的block并为空洞补0即可。写流程比较复杂，即使同一个写操作也会按照min_alloc_size进行判断，拆分成若干大写（do_write_big，对齐写）和小写（do_write_small，非对齐写），具体流程可以参考<a href="http://www.sysnote.org/2016/08/19/ceph-bluestore/" target="_blank" rel="noopener">ceph存储引擎bluestore解析</a>和<a href="http://blog.wjin.org/posts/ceph-bluestore.html" target="_blank" rel="noopener">Ceph BlueStore</a>，注意在覆盖写的时候可能会需要将WAL写入rocksdb。按我理解，对于对象存储，用对齐写的概率远高于非对齐写，因此对写效率的提升是很明显的。此外，copy操作会产生带引用计数的共享blob，当发生修改时会采用copy-on-write。</p>
<p>关于缓存，BlueStore中需要缓存两类数据：元数据（如onode）和用户数据。常见的缓存淘汰算法有LRU（Least Recently Used）和LFU（Least Frequently Used），分别优先淘汰最晚访问和最近一段时间访问频率最少的缓存，BlueStore中的元数据使用LRU算法进行管理。用户数据使用2Q算法：它使用了三个队列A1in、A1out和Am，其中A1out不保存实际数据。当有新的缓存被加载进来时，首先进入A1in队列，且被命中时不会提升其热度，直到它淘汰进入A1out。当A1out中某一项被命中时，则将其移入Am，即认为它是真正的热数据；Am中被淘汰的项也会进去A1out。采用这种算法可以识别访问相关性带来的缓存命中提高。</p>
<p>这只是bluestore的基本流程，上层还需要根据不同的PG和object进行判断，非常复杂。感觉对磁盘管理理解的还是很肤浅，以后要补习一下常见的文件系统是如何管理磁盘的。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2020/03/03/ceph1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/03/03/ceph1/" class="post-title-link" itemprop="url">Ceph学习（1） CRUSH简介</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-03T00:00:00+08:00">2020-03-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-12 15:42:52" itemprop="dateModified" datetime="2020-03-12T15:42:52+08:00">2020-03-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学习ceph的起因是听说ceph对小文件的读写支持很好，但也有地方说ceph更适合大文件的存储，所以还是自己确认一下。前端时间一直断断续续的看Ceph相关的书（《Ceph设计原理与实现》），现在也应该做一下笔记了。</p>
<p>Ceph基本架构如下，可以看到用户可以通过四种方式访问ceph（动态库、对象存储API、块存储访问、posix文件系统访问），无论哪种，最终还是落盘到RADOS上，这也是ceph的核心。</p>
<p>本地集群搭建可以参考<a href="https://juejin.im/post/5e17eff0f265da3e1a59a0ab" target="_blank" rel="noopener">Ubuntu通过docker快速搭建Ceph测试集群（单机部署）</a></p>
<p><img src="/images/ceph_arch.png" alt="Ceph基本架构"></p>
<p>Ceph存储的核心是RADOS（Reliable Autonomic Distributed Object Store，可靠自主的分布式对象存储），基本原理是我们通过object key和一些集群信息计算一个hash值，这个hash值会将其唯一的映射到某一台或者几台具体的存储设备上：只要object key和集群信息不变，那么这个映射关系就不会变；只要hash足够优秀，那么最终各个存储设备就会负载均衡。通过这种方式，我们在避免访问一个中心化的节点的同时，将数据分散在多台机器中，从而得到一个分布式的存储系统。</p>
<p><img src="/images/ceph_rados_arch.png" alt="RADOS基本架构"></p>
<p>这里有几个核心概念：</p>
<ul>
<li>OSD（Object Storage Device，对象存储设备）：一个逻辑或物理上的存储单元，可以简单理解为一个主机。有时候也指OSD守护进程。一个object的数据最终会存储在某一个OSD上。</li>
<li>MDS（Metadata server，元数据服务器）：保存ceph元数据的服务</li>
<li>MON（Monitor，监视器）：Ceph监控进程</li>
<li>CRUSH（Controlled Replication Under Scalable Hashing）：ceph用户计算object地址的伪随机算法</li>
<li>PG（Placement Group，归置组）：对象的集合，用以简化object地址计算</li>
<li>Ceph集群运行图（Cluster Map）：Ceph 依赖于 Ceph 客户端和 OSD ，因为它们知道集群的拓扑，这个拓扑由 5 张图共同描述，统称为“集群运行图”：<ul>
<li>Montior Map： 包含集群的 fsid（Ceph作为文件系统时的文件系统标识符） 、位置、名字、地址和端口，也包括当前版本、创建时间、最近修改时间。要查看监视器图，用 ceph mon dump 命令。</li>
<li>OSD Map： 包含集群 fsid 、创建时间、最近修改时间、存储池列表、副本数量、归置组数量、 OSD 列表及其状态（如 up 、 in ）。要查看OSD运行图，用 ceph osd dump 命令。</li>
<li>PG Map：包含归置组版本、其时间戳、最新的 OSD 运行图版本、占满率、以及各归置组详情，像归置组 ID 、 up set 、 acting set 、 PG 状态（如 active+clean ），和各存储池的数据使用情况统计。</li>
<li>CRUSH Map：包含存储设备列表、故障域树状结构（如设备、主机、机架、行、房间、等等）、和存储数据时如何利用此树状结构的规则。</li>
<li>MDS Map： 包含当前 MDS 图的版本、创建时间、最近修改时间，还包含了存储元数据的存储池、元数据服务器列表、还有哪些元数据服务器是 up 且 in 的。要查看 MDS 图，执行 ceph mds dump 。</li>
</ul>
</li>
</ul>
<p>Ceph 存储系统支持“池”概念，它是存储对象的逻辑分区。Ceph 客户端从监视器获取一张集群运行图，并把对象写入存储池。存储池的 size 或副本数、 CRUSH 规则集和归置组数量决定着 Ceph 如何放置数据。</p>
<p>由此可见，RADOS的核心是CRUSH，它直接影响了RADOS的性能。</p>
<p>考虑一个简单的情况：我们有一大堆objects（每个object对应唯一id），和一大堆主机，如何将这些object保存在这些主机上，使得</p>
<ul>
<li>可以通过objectID和少量额外信息（如当前集群拓扑图），唯一计算出其所属主机（可能有多个）</li>
<li>统计意义上object存放应当达到负载均衡，且允许不同主机拥有不同的负载能力，允许多个副本保存在不同主机/机柜等单位上</li>
<li>object或主机的加入/删除尽量少的影响其他object的存放位置</li>
<li>object存放的先后顺序不应当影响计算结果</li>
<li>同一object的不同副本应保存在不同主机上</li>
</ul>
<p>为了达到这些目标，Sage等人提出了CRUSH算法（<a href="https://www.ssrc.ucsc.edu/Papers/weil-sc06.pdf" target="_blank" rel="noopener">CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data</a>）。为了方便描述，CRUSH以树的形式描述集群拓扑图，并引入了两种节点bucket和device，分别表示树的中间节点和叶节点，其中只有device设备是实际的承载数据的最终设备。不同节点有不同的权重，用于描述其负载能力，以便达成负载均衡：显然，上层节点的权重是其所有直接子节点的权重之和。一个典型的集群拓扑结构如下图所示：</p>
<p><img src="/images/ceph_cluster_top.png" alt="典型的集群拓扑结构"></p>
<h2 id="选择算法概述"><a href="#选择算法概述" class="headerlink" title="选择算法概述"></a>选择算法概述</h2><p>在介绍CRUSH算法前，需要简单了解下RUSH算法。RUSH（Replication Under Scalable Hashing）是一个算法族，它的目标是将含有多个副本的object映射到一个可扩展的存储设备集合上。论文详见<a href="https://www.ssrc.ucsc.edu/Papers/honicky-ipdps04.pdf" target="_blank" rel="noopener">Replication Under Scalable Hashing: A Family of Algorithms for Scalable Decentralized Data Distribution</a>。RUSH中的子集群大致对应于CRUSH中的bucket，对于某个bucket，最基本的需求是从bucket中选取符合object key为x、副本号为r的子节点，称该函数为c(r,x)。不同的bucket可以有不同的策略，目前ceph支持四种不同类型的bucket，如下：</p>
<h3 id="Uniform-Buckets"><a href="#Uniform-Buckets" class="headerlink" title="Uniform Buckets"></a>Uniform Buckets</h3><p>适用于子节点权重完全一致且不太可能改变的情况，例如公司采购一批设备后就不动了。</p>
<p>这类bucket的计算方式为c(r,x) = (hash(x) + rp) mod m，其中p是一个预先随机指定的素数，显然这个算法是O(1)的。由于p和m互质，对于不同的r，c(r,x)一定不相同，这保证了不同副本保存在不同节点上。</p>
<p>当然，添加/删除节点后，几乎所有的c(r,x) 都会变化，会引起大量的数据迁移。</p>
<h3 id="List-Buckets"><a href="#List-Buckets" class="headerlink" title="List Buckets"></a>List Buckets</h3><p>这类bucket允许节点权重不同，所使用的算法为RUSH<sub>P</sub>，原始的计算流程大致如下（具体参数的含义可以参考原论文）：</p>
<p><img src="/images/ceph_rushq.jpeg" alt="RUSHQ算法"></p>
<p>个人理解，RUSH<sub>P</sub>按照节点从新到旧的顺序查找，尝试找到一个能够通过检测标准的节点再加入。对于节点j，其权重为m’<sub>j</sub>，0~j-1的总权重为n’<sub>j</sub>，z是一个由x,j确定的介于[0, m’<sub>j</sub>+n’<sub>j</sub>]的随机数，素数p≥m’<sub>j</sub>。令z’=(z+r*p) mod (m’<sub>j</sub>+n’<sub>j</sub>)，如果z’&lt;m’<sub>j</sub>，则认为测试通过。显然查找object的复杂度是O(n)</p>
<p>当n’<sub>j</sub>足够大的时候，我们可以保证在[0,R)之间至多有一个r能够通过测试，这意味着不同副本可以落在不同节点上。如果所有节点都没测试通过，个人猜测可以扔在某个固定节点上，也可以调整r，直到测试通过</p>
<p>由于是按节点添加时间的顺序从新到旧测试的，因此当有新节点加入时，只有应当落在新节点的object会被迁移。不过如果某个中间节点被删除，由于n’<sub>j</sub>发生了变化，所以对各个节点上的object分布都会有影响。</p>
<h3 id="Tree-Buckets"><a href="#Tree-Buckets" class="headerlink" title="Tree Buckets"></a>Tree Buckets</h3><p>与List buckets非常相似，只是将bucket按照二叉树组织，原始的计算流程大致如下：</p>
<p><img src="/images/ceph_rusht.jpeg" alt="RUSHT算法"></p>
<p>简单来说，RUSH<sub>T</sub>算法会尝试将object放置在左/右子树中，测试标准与RUSH<sub>P</sub>很像，只是比较的时候按左/右子树的权重判断。显然查找object的复杂度是O(logn)</p>
<p>图中没有给出<code>hash(x,node.index,r,0)</code>的算法。单从图中给出的算法看，个人理解这种树形结构可能会造成副本放置在同一台主机上。至于如何处理这种冲突，个人猜测可以不断的调整r，直到选到一个可用的节点。</p>
<p>由于选择节点是看左右子树的权重比，因此比如当左子树权重增大时，左子树已测试通过的object不会变化，但需要调整右子树（对于减小的情况也类似）。因此叶节点的加入/删除会影响集群中半数的object的分布。</p>
<p>我看到一种说法是</p>
<h3 id="Straw-Buckets"><a href="#Straw-Buckets" class="headerlink" title="Straw Buckets"></a>Straw Buckets</h3><p>Straw算法的核心是为根据object key、副本号和节点权重，为每个节点计算一个hash值，选hash值最大的那个节点。显然查找object的复杂度是O(logn)。</p>
<p>一个比较奇怪的地方在于原straw算法对权重做了特殊处理。可见，修正后的权重与其他元素有关，因此添加和删除节点时会造成不相关元素的迁移。原论文对hash算法描述的很简略，个人猜测搞这么麻烦是为了让数据分布的更均匀</p>
<p><img src="/images/ceph_straw.jpeg" alt="Straw算法"></p>
<p>所以ceph后来使用了straw2算法，更符合算法描述</p>
<p><img src="/images/ceph_straw2.jpeg" alt="Straw2算法"></p>
<p>可以看出，在添加/删除节点的时候，只对刚好hash值落在这个节点上的object会有影响。因此straw2算法的抵御结构变化的效果最好，故ceph将其作为默认的选择算法。</p>
<h2 id="Cluter-Map"><a href="#Cluter-Map" class="headerlink" title="Cluter Map"></a>Cluter Map</h2><p>Cluter Map是Ceph集群拓扑结构的逻辑描述。Ceph集群通常是“数据中心-机架-主机-磁盘”这样的树形结构，且叶节点的ID为正，内部节点的ID为负。</p>
<p>常见的节点类型包括osd (or device)、host、chassis、rack、row、pdu、pod、room、datacenter、zone、region、root</p>
<p>比如我们刚才启动的集群，默认的crushmap结构如下，可以看到确实是个树形结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># devices</span><br><span class="line">device 0 osd.0</span><br><span class="line">device 1 osd.1</span><br><span class="line">device 2 osd.2</span><br><span class="line"></span><br><span class="line"># buckets</span><br><span class="line">host c05592a743f2 &#123;</span><br><span class="line">        id -2           # do not change unnecessarily</span><br><span class="line">        # weight 1.000</span><br><span class="line">        alg straw</span><br><span class="line">        hash 0  # rjenkins1</span><br><span class="line">        item osd.0 weight 1.000</span><br><span class="line">&#125;</span><br><span class="line">host 4c637dadfc46 &#123;</span><br><span class="line">        id -3           # do not change unnecessarily</span><br><span class="line">        # weight 2.000</span><br><span class="line">        alg straw</span><br><span class="line">        hash 0  # rjenkins1</span><br><span class="line">        item osd.1 weight 2.000</span><br><span class="line">&#125;</span><br><span class="line">host c88b7c736087 &#123;</span><br><span class="line">        id -4           # do not change unnecessarily</span><br><span class="line">        # weight 3.000</span><br><span class="line">        alg straw</span><br><span class="line">        hash 0  # rjenkins1</span><br><span class="line">        item osd.2 weight 3.000</span><br><span class="line">&#125;</span><br><span class="line">root default &#123;</span><br><span class="line">        id -1           # do not change unnecessarily</span><br><span class="line">        # weight 6.000</span><br><span class="line">        alg straw</span><br><span class="line">        hash 0  # rjenkins1</span><br><span class="line">        item c05592a743f2 weight 1.000</span><br><span class="line">        item 4c637dadfc46 weight 2.000</span><br><span class="line">        item c88b7c736087 weight 3.000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Placement-Rule"><a href="#Placement-Rule" class="headerlink" title="Placement Rule"></a>Placement Rule</h2><p>Ceph支持自定义placement rule完成数据映射，每条placement rule可以包含多个操作，包括三类：</p>
<ol>
<li>take: 从cluster map中选择指定编号的bucket，并以此作为后续的输入，如默认的规则是从root开始选择的</li>
<li>select: 从输入的bucket当中选择指定类型和数量的item。目前ceph支持两种select算法，分别是firstn和indep，分别对应多副本策略和纠错码策略</li>
<li>emit: 输出最终选择结果并返回</li>
</ol>
<p>一个典型的rule如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># rules</span><br><span class="line">rule replicated_ruleset &#123;</span><br><span class="line">        ruleset 0</span><br><span class="line">        type replicated</span><br><span class="line">        min_size 1</span><br><span class="line">        max_size 10</span><br><span class="line">        step take default</span><br><span class="line">        step chooseleaf firstn 0 type host</span><br><span class="line">        step emit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心还是在于select算法的选择，典型的firstn算法如下图所示，搜索具体的某个节点大致是个深搜的过程。流程中随机因子r是由当前副本id和重试次数共同决定。</p>
<p><img src="/images/ceph_firstn.jpeg" alt="firstn算法"></p>
<p>选择OSD失败可能包括hash冲突、过载、网络隔离/延迟、宕机。hash冲突无法避免，但后面几种情况可能会恢复，那么读的时候应该如何处理？和写副本流程一致？有一个中心化的组件用以记录特殊情况？</p>
<p>此外，ceph支持对OSD设置reweight，简单来说是个权重掩码，用于人工干预某个OSD的权重，降低其被选中的概率。将reweight设为0可以临时屏蔽某个OSD。</p>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>最后记录一些可能用到的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crushtool -o --build --num_osds ... <span class="comment"># 手动创建crushmap</span></span><br><span class="line">ceph osd getcrushmap -o &#123;compiled-crushmap-filename&#125; <span class="comment"># 导出当前集群的crushmap至指定文件</span></span><br><span class="line">crushtool -d &#123;compiled-crushmap-filename&#125; -o &#123;decompiled-crushmap-filename&#125; <span class="comment"># 将导出的crushmap文件反编译为可编辑版本</span></span><br><span class="line">crushtool -c &#123;decompiled-crushmap-filename&#125; -o &#123;compiled-crushmap-filename&#125; <span class="comment"># 将可编辑版本编译为二进制crushmap文件</span></span><br><span class="line">crushtool -i &#123;compiled-crushmap-filename&#125; --<span class="built_in">test</span> --min-x 0 --max-x 9 --num-rep 3 --rule-set 0 --show_mappings <span class="comment"># 模拟输入一些文件，输出映射结果</span></span><br><span class="line">crushtool -i &#123;compiled-crushmap-filename&#125; --<span class="built_in">test</span> --min-x 0 --max-x 1000000 --num-rep 3 --rule-set 0 --show_utilization <span class="comment"># 仅统计分布概况</span></span><br><span class="line">ceph osd setcrushmap -i &#123;compiled-crushmap-filename&#125; <span class="comment"># 重设crushmap</span></span><br><span class="line">ceph osd df tree <span class="comment"># 查看整个集群的空间利用率</span></span><br><span class="line">ceph osd reweight &#123;osd_numberic_id&#125; &#123;reweight&#125; <span class="comment"># 设置某个osd的reweight值</span></span><br></pre></td></tr></table></figure>

<p>有些地方还不是很明白，之后确定了可能会改。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/30/kmp-find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/30/kmp-find/" class="post-title-link" itemprop="url">用NFA解释KMP算法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-30 00:00:00 / Modified: 20:55:16" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">2019-12-30</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法" target="_blank" rel="noopener">KMP算法</a>是一个比较经典的字串搜索算法，相信学过一点算法的都知道。我一直觉得KMP算法理解起来非常反人类，尤其是我这种脑子比较轴的人，所以这里用NFA来解释KMP算法。leetcode原题在<a href="https://leetcode-cn.com/problems/implement-strstr/submissions/" target="_blank" rel="noopener">实现 strStr()</a>。</p>
<h2 id="NFA模拟字符串匹配"><a href="#NFA模拟字符串匹配" class="headerlink" title="NFA模拟字符串匹配"></a>NFA模拟字符串匹配</h2><p>如何用状态机来模拟字串搜索呢？假设目标串为<code>S=&quot;aabaabbcaabbccc&quot;</code>，模式串为<code>P=&quot;aabbcaab&quot;</code>，那么就可以制造这样一个NFA：</p>
<p>0<ruby>→ <rt>a</rt></ruby>1<ruby>→ <rt>a</rt></ruby>2<ruby>→ <rt>b</rt></ruby>3<ruby>→ <rt>b</rt></ruby>4<ruby>→ <rt>c</rt></ruby>5<ruby>→ <rt>a</rt></ruby>6<ruby>→ <rt>a</rt></ruby>7<ruby>→ <rt>b</rt></ruby>8</p>
<p>这里隐去了不成功的状态转移路径，所有未标注的状态转移路径都指向状态0，比如状态1在遇到非<code>a</code>的情况下应该跳转到0。</p>
<p>然后维持一个不重复的状态集，每解析一个目标串的字符，就尝试将集合中所有状态按照这个字符向前转移一次，初始集合为<code>{0}</code>，且转移后都要重新加入状态0。当状态集合包含最终状态（这里是状态8）时，我们认为匹配成功，否则认为匹配失败。那么针对于这个匹配，我们的状态转移过程是：</p>
<p>{0}<ruby>→ <rt>a</rt></ruby>{0,1}<ruby>→ <rt>a</rt></ruby>{0,1,2}<ruby>→ <rt>b</rt></ruby>{0,3}<ruby>→ <rt>a</rt></ruby>{0,1}<ruby>→ <rt>a</rt></ruby>{0,1,2}<ruby>→ <rt>b</rt></ruby>{0,3}<ruby>→ <rt>b</rt></ruby>{0,4}<ruby>→ <rt>c</rt></ruby>{0,5}<ruby>→ <rt>a</rt></ruby>{0,1,6}<ruby>→ <rt>a</rt></ruby>{0,1,2,7}<ruby>→ <rt>b</rt></ruby>{0,3,8}</p>
<p>可见最终的状态集合包含了目标状态8，因此匹配成功。</p>
<p>为什么可以用这样一个NFA来模拟字符串匹配过程？</p>
<ol>
<li>假设我们从目标串任意位置i开始，从初始集合{0}开始运行NFA，那么如果这个位置i与模式串匹配，那么最终一定会转移到最终状态，反之亦然</li>
<li>因此我们可以从目标串所有位置开始同时运行同一个NFA，只要其中一个转移到了状态8，那么就说明转移成功</li>
<li>由于所有初始集合均为{0}，而{0}是这些过程中任意集合的子集，且之后的状态转移路径完全相同，因此可以进行合并，即可以通过从前向后遍历目标串字符，并根据这些字符进行状态转移，就得到了同样的效果</li>
</ol>
<p>感觉说的不是特别清楚，有兴趣的可以看看编译原理。</p>
<h2 id="NFA到DFA"><a href="#NFA到DFA" class="headerlink" title="NFA到DFA"></a>NFA到DFA</h2><p>带着一个状态集跑NFA也是一个选择，但似乎可以更简化一些，比如我们可以仿照NFA转DFA的原理来重新思考这个问题。NFA转DFA的原理大致是将NFA的状态集合看作DFA的一个状态，然后不停扩展DFA的状态集合，直至不再变化。不过这里有些细小的差别：新增的状态集合需要再加一个状态0。</p>
<p>仍然以上面那个例子为例，</p>
<ul>
<li>{0}可以通过a转移到{0,1}，其他转移到{0}</li>
<li>{0,1}可以通过a转移到{0,1,2}，其他转移到{0}</li>
<li>{0,1,2}可以通过b转移到{0,3}，通过a转移到{0,1,2}，其他转移到{0}</li>
<li>{0,3}可以通过b转移到{0,4}，通过a转移到{0,1}，其他转移到{0}</li>
<li>{0,4}可以通过c转移到{0,5}，通过a转移到{0,1}，其他转移到{0}</li>
<li>…</li>
<li>{0,1,2,7}可以通过b转移到{0,3,8}，通过a转移到{0,1,2}，其他转移到{0}</li>
</ul>
<p>仔细观察这个扩展过程，有以下特点：</p>
<ol>
<li>每次都只会新增一个状态，且只和上一个状态集有关。比如{0,1,2}通过b转移到{0,3}，状态3由状态2而来，状态集{0,3}只和{0,1,2}有关</li>
<li>假设上一个状态集合为[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]，[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>]一定已经处理过，且s<sub>k</sub>一定会通过P[s<sub>k</sub>]转移到新状态s<sub>k</sub>+1</li>
<li>s<sub>k</sub>只能通过P[s<sub>k</sub>]转移到s<sub>k</sub>+1。对于非P[s<sub>k</sub>]的字符，s<sub>k</sub>只能转移到状态0，故状态集[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]遇到非P[s<sub>k</sub>]的字符的字符，转移后的状态集等同于状态集[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>]遇到相同字符转移后的状态集，且这个状态集一定已经处理过（证明起来比较麻烦，可以试试用数学归纳法）</li>
</ol>
<p>因此我们可以用状态s<sub>k</sub>来唯一指代状态集合[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]，且状态子集[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>]由状态s<sub>k-1</sub>唯一指定。换言之，可以记录一个数组prev，顺着这个数组，就能从状态s<sub>k</sub>找到全部的[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]。</p>
<p>那么如何来求prev呢？还是按照NFA转DFA中的扩展思路，假设对于状态s<sub>k</sub>，它所指代的状态集合为{s<sub>k</sub>,s<sub>k-1</sub>,…,s<sub>1</sub>,s<sub>0</sub>}={s<sub>k</sub>, prev[s<sub>k</sub>], prev[prev[s<sub>k</sub>]], …, 0}，其中s<sub>k</sub>可以通过P[s<sub>k</sub>]转移到s<sub>k</sub>+1，那接下来的问题就在于prev[s<sub>k</sub>], prev[prev[s<sub>k</sub>]], …, 0能通过P[s<sub>k</sub>]转移到哪。考虑其中的一个状态s<sub>m</sub>，有</p>
<ul>
<li>如果P[s<sub>m</sub>]==P[s<sub>k</sub>]，则s<sub>m</sub>可以通过P[s<sub>k</sub>]转移到s<sub>m</sub>+1，否则转移到0</li>
<li>假设s<sub>m</sub>可以通过P[s<sub>k</sub>]转移到s<sub>m</sub>+1，而s<sub>m</sub>+1已经被处理过，那么prev[s<sub>m</sub>]也可以通过P[s<sub>k</sub>]转移到prev[s<sub>m</sub>]+1，且prev[s<sub>m</sub>]+1==prev[s<sub>m</sub>+1]。这还是由于新状态只能由特定字符转换而来导致的。</li>
</ul>
<p>还是拿上面那个举例，已知prev[{1,2,3,4,5,6}]={0,1,0,0,0,1}，也就是已经计算得到状态6了，现在要计算状态7。状态6可以通过字符a转换到状态7，而状态prev[6]=1可以通过字符a转换到状态2，故prev[7]=2。也就是说，状态集{6,1,0}通过字符a转移到了状态集{7,2,1,0}。更一般的做法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makePrev</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prev)</span></span>&#123;</span><br><span class="line">  prev.resize(pattern.length()+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  prev[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.size(); ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> pi = prev[i];</span><br><span class="line">    <span class="keyword">while</span> (pi &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[pi])&#123;</span><br><span class="line">      pi = prev[pi];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pi == <span class="number">-1</span> || pattern[i] == pattern[pi])&#123; <span class="comment">// prev[0]设为-1主要是为了方便这里能合并if判断</span></span><br><span class="line">      prev[i+<span class="number">1</span>] = pi+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev[i+<span class="number">1</span>] = pi;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，假设我们已经得到了DFA，那么应该如何运行呢？之前提到，我们可以用最后一个状态s<sub>k</sub>来唯一指代一个状态集合来作为DFA的状态，而DFA中的状态能转移到哪得把状态集里所有状态都扫一遍。因此假设当前字符为c，有</p>
<ul>
<li>如果P[s<sub>k</sub>]==c，则转移到状态s<sub>k</sub>+1，否则得查P[prev[s<sub>k</sub>]]</li>
<li>下一个状态集至少有状态0</li>
</ul>
<p>因此可以这么判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (needle.size() &gt; haystack.size())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (needle.empty())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev;</span><br><span class="line">  makePrev(needle, prev);</span><br><span class="line">  <span class="keyword">int</span> successIndex = needle.size();</span><br><span class="line">  <span class="keyword">int</span> pi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.size(); ++i)&#123;</span><br><span class="line">    <span class="keyword">char</span> c = haystack[i];</span><br><span class="line">    <span class="keyword">while</span> (pi &gt;= <span class="number">0</span> &amp;&amp; c != needle[pi])&#123;</span><br><span class="line">      pi = prev[pi];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (++pi &gt;= successIndex)&#123; <span class="comment">// prev[0]设为-1后这里也能合并判断</span></span><br><span class="line">      <span class="keyword">return</span> i-needle.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实代码写出来就非常像KMP了，只是对于状态转移，KMP的解释是后缀匹配，但我个人很难理解后缀匹配，用笔算着算着就晕了。用状态转移解释的话，虽然说着麻烦，但自己笔算推演一下就很容易理解。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/13/opencv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/13/opencv/" class="post-title-link" itemprop="url">opencv简单使用</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-13 00:00:00 / Modified: 16:16:10" itemprop="dateCreated datePublished" datetime="2019-12-13T00:00:00+08:00">2019-12-13</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前试了一下，将ImageIO换成opencv后，图片转换效率和内存使用率有明显提升，比如同一张大图，ImageIO大概能用十来秒，opencv平均用时1秒左右，果断换了。</p>
<p>我编译出来opencv的动态链接库后，放到线上运行时还会报错<code>libstdc++.so</code>和<code>libjasper.so</code>找不到对应的版本，拷一个过去就可以了。</p>
<p>基本操作还是将原图转换为Mat，再做一大堆操作（旋转、缩放等），最后编码为目标图。</p>
<p>需要注意的有两点：</p>
<ul>
<li>opencv使用了大量堆外内存，所以需要把堆外内存调大点（<code>-XX:MaxDirectMemorySize</code>参数），并且几乎所有使用了堆外内粗的对象都要及时release</li>
<li>直接读文件可以用<code>imread()</code>，读内存用<code>imdecode()</code>，但这种方式会导致exif信息丢失，导致exif中如果有Orientation信息时，会导致转换后相对于原图旋转/翻转，因此要手动旋转/翻转。据说高版本的<code>imread()</code>会自动选择/翻转。</li>
</ul>
<p>但是对于动图，我暂时还没找到opencv的处理方法，所以还是用gifsicle+libwebp。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原图转换为Mat</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Mat <span class="title">bytes2mat</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">  MatOfByte matOfByte = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    matOfByte = <span class="keyword">new</span> MatOfByte(bytes);</span><br><span class="line">    <span class="keyword">return</span> Imgcodecs.imdecode(matOfByte, Imgcodecs.IMREAD_UNCHANGED);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matOfByte != <span class="keyword">null</span>)&#123;</span><br><span class="line">      matOfByte.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转/翻转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Mat <span class="title">doOrientation</span><span class="params">(Mat mat, Orientation orientation)</span></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (orientation)&#123;</span><br><span class="line">    <span class="keyword">case</span> TOP_LEFT:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TOP_RIGHT:</span><br><span class="line">      Core.flip(mat, mat, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BOTTOM_RIGHT:</span><br><span class="line">      Core.flip(mat, mat, -<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BOTTOM_LEFT:</span><br><span class="line">      Core.flip(mat, mat, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LEFT_TOP:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RIGHT_TOP:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      Core.flip(mat, mat, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RIGHT_BOTTOM:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      Core.flip(mat, mat, -<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LEFT_BOTTOM:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      Core.flip(mat, mat, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放+质量，也可以是别的什么操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] convertImage(<span class="keyword">byte</span>[] srcBytes, Orientation orientation, Size sz, String ext, <span class="keyword">int</span> quality)&#123;</span><br><span class="line">  Mat srcMat = <span class="keyword">null</span>;</span><br><span class="line">  Mat dstMat = <span class="keyword">null</span>;</span><br><span class="line">  MatOfByte dstMatByte = <span class="keyword">null</span>;</span><br><span class="line">  MatOfInt thumbParams = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    srcMat = bytes2mat(srcBytes);</span><br><span class="line">    <span class="keyword">if</span> (srcMat == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (orientation != <span class="keyword">null</span>)&#123;</span><br><span class="line">      doOrientation(srcMat, orientation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Size sz = <span class="keyword">new</span> Size(params.getDstWidth(), params.getDstHeight());</span><br><span class="line">    dstMat = <span class="keyword">new</span> Mat(sz, CvType.CV_8U);</span><br><span class="line">    Imgproc.resize(srcMat, dstMat, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ext.equals(<span class="string">".jpeg"</span>))&#123;</span><br><span class="line">        thumbParams = <span class="keyword">new</span> MatOfInt(Imgcodecs.IMWRITE_JPEG_QUALITY, quality);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ext.equals(<span class="string">".webp"</span>))&#123;</span><br><span class="line">        thumbParams = <span class="keyword">new</span> MatOfInt(Imgcodecs.IMWRITE_WEBP_QUALITY, quality);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dstMatByte = <span class="keyword">new</span> MatOfByte();</span><br><span class="line">    <span class="keyword">if</span> (thumbParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Imgcodecs.imencode(ext, dstMat, dstMatByte, thumbParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Imgcodecs.imencode(ext, dstMat, dstMatByte);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dstMatByte.toArray();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (srcMat != <span class="keyword">null</span>)&#123;</span><br><span class="line">      srcMat.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dstMat != <span class="keyword">null</span>)&#123;</span><br><span class="line">      dstMat.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dstMatByte != <span class="keyword">null</span>)&#123;</span><br><span class="line">      dstMatByte.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (thumbParams != <span class="keyword">null</span>)&#123;</span><br><span class="line">      thumbParams.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/11/gcc-upgrade/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/11/gcc-upgrade/" class="post-title-link" itemprop="url">用于编译的docker镜像搭建</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-11 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-11T00:00:00+08:00">2019-12-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-12 14:14:28" itemprop="dateModified" datetime="2019-12-12T14:14:28+08:00">2019-12-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有些库编译的时候，可能本地能过，但线上跑不了，所以需要以类似线上的环境建立一个docker镜像，在里面编译完后使用。我这里是编译opencv的时候有这种需求。线上是centos6，所以我用的基础镜像也是<code>centos:6</code>。</p>
<h3 id="基础编译环境"><a href="#基础编译环境" class="headerlink" title="基础编译环境"></a>基础编译环境</h3><ul>
<li>centos: <code>yum groupinstall &quot;Development Tools&quot;</code></li>
<li>ubuntu: <code>apt-get install -y build-essential</code></li>
</ul>
<h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><p>opencv对cmake版本有要求，所以需要升级一下cmake</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz    </span><br><span class="line">tar xvf cmake-3.6.2.tar.gz &amp;&amp; <span class="built_in">cd</span> cmake-3.6.2/</span><br><span class="line">./bootstrap</span><br><span class="line">gmake</span><br><span class="line">gmake install <span class="comment"># root权限</span></span><br></pre></td></tr></table></figure>

<p>然后执行<code>cmake --version</code>看看有没有生效</p>
<h3 id="高版本的gcc"><a href="#高版本的gcc" class="headerlink" title="高版本的gcc"></a>高版本的gcc</h3><p>按说这个不是必选项，但我用低版本的gcc编译opencv出了各种问题，比如<code>opencv/3rdparty/openexr/IlmThread/IlmThreadPool.cpp:49:19: error: atomic: No such file or directory</code>，所以还是升级一下</p>
<p>可以参考<a href="https://blog.51cto.com/2716255/1965617" target="_blank" rel="noopener">曲折的gcc升级详细步骤</a>，这几个依赖包能装都装一下，最好手动装，yum有点坑。我遇到的一个问题是线上gcc寻找头文件和库的路径有点问题，似乎不会搜索<code>/usr/local</code>，并且<code>--with-isl-lib</code>这样的参数实际上在编译期间是无效的。所以安装的时候可以重新指定路径，或者手动copy到<code>/usr/include</code>和<code>/lib64</code>下。</p>
<p><code>./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib --with-isl-include=/usr/local/isl/include --with-isl-lib=/usr/local/isl/lib/</code></p>
<p>编译出来gcc后，还遇到一个问题是编译opencv时报错<code>Error: no such instruction</code>，这个问题在于升级gcc的时候没有升级<code>assembler(/usr/bin/as)</code>，版本过低，因此需要再升级<code>binutils</code>。</p>
<p>不过我编译<code>binutils</code>的时候会报错<code>as.c:704:44: error: ‘TARGET_CANONICAL’ undeclared (first use in this function)</code>等一大堆错误，参考<a href="https://www.cnblogs.com/shakin/p/4276434.html" target="_blank" rel="noopener">使用zeranoe的自动化脚本mingw-w64-build-3.6.4在ubutun14.04_64bit上交叉编译ffmpeg 2.5</a>，可以把这几个变量取消掉<code>unset LIBRARY_PATH CPATH C_INCLUDE_PATH PKG_CONFIG_PATH CPLUS_INCLUDE_PATH INCLUDE</code></p>
<p>这几个依赖库make完后都可以执行<code>make check</code>来检测下是否正常。</p>
<h3 id="ant"><a href="#ant" class="headerlink" title="ant"></a>ant</h3><p>这个可以用<code>yum</code>或者<code>apt</code>之类的安装，也可以去官网下载，但无论哪种，都需要添加一个环境变量<code>ANT_HOME</code>，并且把<code>$ANT_HOME/bin</code>加到<code>PATH</code>里，<code>$ANT_HOME/lib</code>加到<code>CLASSPATH</code>里</p>
<p>至于jdk怎么安装就不提了</p>
<h3 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h3><p>此外还需要预安装一些编解码库，包括<code>zlib</code>,<code>jpeg</code>,<code>tiff</code>,<code>jasper</code>,<code>png</code>。我编译时报错<code>error: &#39;read&#39; is not a member of &#39;cv::TiffDecoderBufHelper&#39;</code>，需要加一个选项<code>-DBUILD_TIFF=ON</code></p>
<p>还有一个问题是，如果出现<code>Java wrappers: NO</code>，需要再安装python2.7以上，参考<a href="https://segmentfault.com/a/1190000000654227" target="_blank" rel="noopener">CENTOS 6.5 安装 Python 2.7 总结</a></p>
<p>正常的cmake流程即可，注意<code>cmake</code>完后需要看下有没有开启java选项</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=OFF -DBUILD_TESTS=OFF -D CMAKE_INSTALL_PREFIX=/opt/soft ..</span><br><span class="line">make -j16</span><br><span class="line"><span class="comment"># 可以不install，所以前面的prefix也可以不指定</span></span><br></pre></td></tr></table></figure>

<h3 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h3><p>可以找一个和线上环境相似的镜像，我直接用<code>centos:6</code>了，基本上需要运行这几条命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础工具</span></span><br><span class="line">yum -y groupinstall <span class="string">"Development Tools"</span></span><br><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake，从本地copy一个过来</span></span><br><span class="line"><span class="comment"># docker cp cmake-3.6.2 $&#123;docker_pid&#125;:/tmp/</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/cmake-3.6.2 &amp;&amp; ./bootstrap &amp;&amp; gmake &amp;&amp; gmake install</span><br><span class="line"></span><br><span class="line"><span class="comment"># jdk，注意安装完要添加环境变量JAVA_HOME，一般是/usr/lib/jvm/java-1.8.0-openjdk.x86_64</span></span><br><span class="line">yum install -y java-1.8.0-openjdk-devel.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># ant，注意安装完要添加环境变量将ANT_HOME，一般是/usr/share/ant</span></span><br><span class="line">yum install -y ant</span><br><span class="line"></span><br><span class="line"><span class="comment"># gcc依赖</span></span><br><span class="line">wget http://ftp.yz.yamagata-u.ac.jp/pub/GNU/gmp/gmp-6.1.2.tar.xz <span class="comment"># 太慢就挂代理，用法是wget $&#123;url&#125; -e use_proxy=yes -e http_proxy=$&#123;proxy&#125;</span></span><br><span class="line">tar -xvf gmp-6.1.2.tar.xz &amp;&amp; <span class="built_in">cd</span> gmp-6.1.2 &amp;&amp;  ./configure  --prefix=/usr/<span class="built_in">local</span>/gmp &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget http://ftp.gnu.org/gnu/mpfr/mpfr-4.0.2.tar.gz</span><br><span class="line">tar -xvf mpfr-4.0.2.tar.gz &amp;&amp; <span class="built_in">cd</span> mpfr-4.0.2 &amp;&amp; ./configure --with-gmp-include=/usr/<span class="built_in">local</span>/gmp/include  --with-gmp-lib=/usr/<span class="built_in">local</span>/gmp/lib --prefix=/usr/<span class="built_in">local</span>/mpfr &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget https://ftp.gnu.org/gnu/mpc/mpc-1.1.0.tar.gz</span><br><span class="line">tar -xvf mpc-1.1.0.tar.gz &amp;&amp; <span class="built_in">cd</span> mpc-1.1.0 &amp;&amp;  ./configure --with-mpfr-include=/usr/<span class="built_in">local</span>/mpfr/include  --with-mpfr-lib=/usr/<span class="built_in">local</span>/mpfr/lib --with-gmp-include=/usr/<span class="built_in">local</span>/gmp/include --with-gmp-lib=/usr/<span class="built_in">local</span>/gmp/lib --prefix=/usr/<span class="built_in">local</span>/mpc &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=/usr/<span class="built_in">local</span>/gmp/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line">wget http://isl.gforge.inria.fr/isl-0.22.tar.bz2</span><br><span class="line">tar -xvf isl-0.22.tar.bz2 &amp;&amp; <span class="built_in">cd</span> isl-0.22 &amp;&amp;  ./configure   --with-gmp-prefix==/usr/<span class="built_in">local</span>/gmp --prefix=/usr/<span class="built_in">local</span>/isl &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget ftp://gcc.gnu.org/pub/gcc/infrastructure/cloog-0.18.1.tar.gz</span><br><span class="line">tar -xvf  cloog-0.18.1.tar.gz &amp;&amp; <span class="built_in">cd</span> cloog-0.18.1 &amp;&amp;  ./configure   --with-gmp-prefix==/usr/<span class="built_in">local</span>/gmp -with-isl-prefix=/usr/<span class="built_in">local</span>/isl --prefix=/usr/<span class="built_in">local</span>/cloog &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># gcc</span></span><br><span class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-9.2.0/gcc-9.2.0.tar.gz</span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=/usr/<span class="built_in">local</span>/mpfr/include:/usr/<span class="built_in">local</span>/isl/include:/usr/<span class="built_in">local</span>/mpc/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"><span class="comment"># 这里不知道为啥，修改LD_LIBRARY_PATH或者/etc/ld.so.conf都不生效，只能把上面几个编译出来的动态链接库都扔到/usr/lib64/下</span></span><br><span class="line">./configure -<span class="built_in">enable</span>-checking=release -<span class="built_in">enable</span>-languages=c,c++ -<span class="built_in">disable</span>-multilib --with-gmp=/usr/<span class="built_in">local</span>/gmp/  --with-mpfr=/usr/<span class="built_in">local</span>/mpfr --with-mpc=/usr/<span class="built_in">local</span>/mpc</span><br><span class="line"></span><br><span class="line"><span class="comment"># binutils</span></span><br><span class="line">wget https://ftp.gnu.org/gnu/binutils/binutils-2.33.1.tar.gz -e use_proxy=yes -e http_proxy=<span class="variable">$&#123;proxy&#125;</span></span><br><span class="line"><span class="built_in">unset</span> LIBRARY_PATH CPATH C_INCLUDE_PATH PKG_CONFIG_PATH CPLUS_INCLUDE_PATH INCLUDE</span><br><span class="line">tar -xvf binutils-2.33.1.tar.gz</span><br><span class="line"> ./configure --prefix=/usr</span><br><span class="line"> make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一大堆编解码库</span></span><br><span class="line"> yum install -y zlib-devel.x86_64 libjpeg-turbo-devel.x86_64 jasper-devel.x86_64 libtiff-devel.x86_64  libpng-devel.x86_64</span><br><span class="line"></span><br><span class="line"> <span class="comment"># python 2.7</span></span><br><span class="line"> wget https://www.python.org/ftp/python/2.7.8/Python-2.7.8.tgz</span><br><span class="line">tar xf Python-2.7.8.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-2.7.8</span><br><span class="line">./configure --prefix=/usr/ &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># opencv，从本地copy一个过去</span></span><br><span class="line"><span class="comment"># docker cp opencv $&#123;docker_pid&#125;:/tmp/</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/opencv &amp;&amp; mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=OFF -DBUILD_TESTS=OFF -DBUILD_TIFF=ON ..</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<p>可以全部搞完再<code>docker commit</code>，也可以搞完一步就commit一下，看情况了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/05/hbase-bulkload2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/05/hbase-bulkload2/" class="post-title-link" itemprop="url">记录一下HBase BulkLoad使用过程中遇到的坑</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-05T00:00:00+08:00">2019-12-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-27 17:07:10" itemprop="dateModified" datetime="2020-03-27T17:07:10+08:00">2020-03-27</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这段时间被bulkload搞的头大，记录一些问题：</p>
<h2 id="HFile权限问题"><a href="#HFile权限问题" class="headerlink" title="HFile权限问题"></a>HFile权限问题</h2><p>HBase执行bulkload时需要对应HFile目录的读写权限。网上通用做法是递归<code>chmod</code>相关目录，感觉比较麻烦。</p>
<p>最好在临时文件所在的根目录为hbase用户增加default acl，并且要在<code>hdfs-site.xml</code>中增加<code>fs.permissions.umask-mode=000</code>这一项</p>
<p>默认的<code>fs.permissions.umask-mode</code>应该是022，这会导致新创建子目录的mask为’r-x’，hbase用户写操作失败。</p>
<h2 id="HBase的hadoop-client版本需要与hdfs版本相对应"><a href="#HBase的hadoop-client版本需要与hdfs版本相对应" class="headerlink" title="HBase的hadoop-client版本需要与hdfs版本相对应"></a>HBase的hadoop-client版本需要与hdfs版本相对应</h2><p>由于hbase region server需要加载HFile，即会去读写相关HFile文件，因此hadoop-client和hdfs版本不匹配会出现一些奇奇怪怪的问题。</p>
<p>我遇到的情况是2.6版本的<code>hadoop-client</code>访问2.4的hdfs会报权限错。但奇怪的是如果hbase访问hdfs有问题，那么region server根本不应该能跑起来，只能说是玄学。</p>
<h2 id="生成不同table的HFILE"><a href="#生成不同table的HFILE" class="headerlink" title="生成不同table的HFILE"></a>生成不同table的HFILE</h2><p>貌似<code>HFileOutputFormat2</code>只支持对于单表生成数据，那么如果需要通过某一过程同时生成两个以上表的HFILE就不能直接用了。最典型的例子是从表A把数据挪动到表B，再把表A数据删除。个人做法还是把<code>createRecordWriter()</code>方法抽取出来，毕竟自己通过<code>HFileWriter</code>去写，万一出问题了呢。</p>
<p>这里推荐一个博文<a href="http://www.zhangrenhua.com/2016/01/28/hadoop-Hbase%E5%BF%AB%E9%80%9F%E5%86%99%E5%85%A5%E8%A7%A3%E6%83%91%E4%B9%8BHFile/" target="_blank" rel="noopener">Hbase快速写入解惑之HFile</a>，里面有一个简单的本地生成HFile的例子。跑MapReduce的时候也可以参考</p>
<p>但本地生成的HFile，还需要再copy到HBase所在的HDFS集群的某个目录下，再执行<code>doBulkLoad()</code></p>
<p>这里有另一个问题是如果通过mapreduce作业生成HFile时，需不需要通过reduce来生成HFile。个人感觉还是自己控制会方便一点，建议把reduce num置为0，然后在map过程中将数据写入对应目录的不同taskId的子目录下，最后bulkload。</p>
<h2 id="写入HFile的时候需要保证KeyValue按字典序排序"><a href="#写入HFile的时候需要保证KeyValue按字典序排序" class="headerlink" title="写入HFile的时候需要保证KeyValue按字典序排序"></a>写入HFile的时候需要保证KeyValue按字典序排序</h2><p>比如要写1000行数据，每行有50个KeyValue，那么这50000个KeyValue都必须按字典序排序。</p>
<p>只使用<code>HFileOutputFormat2</code>的话不需要注意这一点，它会自动排序。</p>
<h2 id="尽量利用timestamp进行同步"><a href="#尽量利用timestamp进行同步" class="headerlink" title="尽量利用timestamp进行同步"></a>尽量利用timestamp进行同步</h2><p>由于绕开了RS，我们在写数据的时候无法通过CAS判断是否应当写入，那么timestamp就成了数据同步依据的唯一选择，但怎么用timestamp还得看具体情况</p>
<p>设t0&lt;t1&lt;t2，t0时刻我们决定清空比较早期的用户记录，如果扫表和生成HFile的时间很长，而用户t1时刻增加了记录，不指定deleteMarker的timestamp的话，在t2时刻进行bulkload时会删除这条记录，这显然是违背业务逻辑的</p>
<p>说起来为了时间戳同步这事还改动了其他模块的部分处理逻辑，真是肝疼。比如HBase timestamp有一个坑是，你可以在修改时指定一个时间戳去改，假如每次指定的timestamp相同，那么你有可能改成功。但如果某次操作是以相同timestamp写一个deleteMarker进去，那么之后再以相同时间戳写入就会失败（一直是deleteMarker），直到hbase执行compact。这个问题会导致我们不方便把一个timestamp分配给某个具体业务，以此为依据进行数据的增删改查——当然了，如果某个timestamp被置为deleteMarker，那么比这个timestamp更小的数据就有可能被compact掉。</p>
<h2 id="生成大的HFile"><a href="#生成大的HFile" class="headerlink" title="生成大的HFile"></a>生成大的HFile</h2><p>如果直接使用<code>FDSHFileOutputFormat2</code>其实没有这个问题</p>
<p>我之前的做法是缓存一小批数据就写一个HFile，这样会导致HFile数量过大，在load时会急速提升hbase负载，因此需要避免生成过多的HFile</p>
<p>而生成大的HFile的麻烦在于可能源数据不是有序的，那么比较好的做法是map阶段生成类似<code>(key,Put)</code>这样的有序对，然后reduce阶段再将其写入HDFS</p>
<p>当然如果源数据是有序的（比如从hbase某个表里读），那么在map阶段直接写入就可以了</p>
<p>个人遇到的一个问题是本地多线程写HFile时，由于多个线程共用一个缓冲队列，显然即使源数据有序，这个缓冲区也不是有序的。最后的做法是使用<code>ThreadLocal</code>，为每个线程提供一个独立的、线程安全的缓冲队列（相应的，缓冲队列大小会小一些），这样只要各个线程读到的数据是有序的（或者近似有序的），问题就不是很大</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/12/hbase-bulkload/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/12/hbase-bulkload/" class="post-title-link" itemprop="url">HBase BulkLoad简单用法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-12T00:00:00+08:00">2019-11-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-24 20:12:53" itemprop="dateModified" datetime="2019-11-24T20:12:53+08:00">2019-11-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>再更新一下，之前介绍的搞法会需要先通过MR作业生成一些HFile文件，但其实不一定需要用MR完成。这点可以看<code>HFileOutputFormat2.class</code>的源码，其中写HFile的核心是<code>createRecordWriter()</code>，而这个方法其实并没有用到MR作业的任何特性。</p>
<p>那么就可以自己手动把这段代码提取出来，生成一个类似<code>RecordWriter&lt;ImmutableBytesWritable, Cell&gt;</code>的类，这样可以直接在本地（或者别的什么地方）生成HFile。因此流程可以进一步简化为：</p>
<ol>
<li>直接将要写入的数据写入HFile</li>
<li>令hbase加载生成的HFile</li>
</ol>
<p>当然这个类是不是线程安全的我就不太清楚了，建议用之前加个锁，或者再优化一下代码</p>
<hr>
<p>最近发现BulkLoad这个好东西，记录一下</p>
<p>简单来说，正常的HBase写操作需要先经过Region Server，再通过一系列复杂操作后才会生成HFile并落盘（比如写WAL、flush、split等），进而生效。由于hbase的一个具体的region server是单点的，如果某个作业的写入量较大，很可能会把region server打爆。而我们知道，HBase持久化是通过HFile保存的，那么反过来，如果把写操作聚合成为一个HFile，再让hbase去加载这个hfile，那么就完成了写入操作，这样做可以省下大量的region server操作，降低负载，这个操作称为bulkload。</p>
<p>Bulkload大致步骤包括：</p>
<ol>
<li>生成要处理的数据。至于如何生成、生成什么格式得看具体场景，但无论如何，需要能被接下来的mapreduce作业访问到</li>
<li>提交一个mapreduce作业，这个作业需要读取步骤1中生成的数据，并转换为HFile。这个HFile一般可以放在hbase所在hdfs集群上的某个临时目录下面</li>
<li>令hbase加载步骤2生成的HFile</li>
</ol>
<p>网上大多数教程是讲如何导入数据，那么这里就讲讲如何批量删除数据。假设我们要删的数据保存在<code>/tmp/input.txt</code>里，以每行写一个timestamp和一个key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1573542224666,test157354-1958983957411631613/hello-00000</span><br><span class="line">1573542224674,test157354-1958983957411631613/hello-00001</span><br><span class="line">1573542224680,test157354-1958983957411631613/hello-00002</span><br><span class="line">1573542224687,test157354-1958983957411631613/hello-00003</span><br><span class="line">1573542224693,test157354-1958983957411631613/hello-00004</span><br><span class="line">1573542224700,test157354-1958983957411631613/hello-00005</span><br><span class="line">1573542224707,test157354-1958983957411631613/hello-00006</span><br><span class="line">1573542224713,test157354-1958983957411631613/hello-00007</span><br><span class="line">1573542224724,test157354-1958983957411631613/hello-00008</span><br><span class="line">1573542224730,test157354-1958983957411631613/hello-00009</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来要写一个mapper，将一行数据转换为KeyValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">ImmutableBytesWritable</span>, <span class="title">KeyValue</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">      String[] tokens = value.toString().split(<span class="string">","</span>, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">long</span> ts = Long.parseLong(tokens[<span class="number">0</span>]);</span><br><span class="line">      String rowKey = tokens[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      Delete delete = <span class="keyword">new</span> Delete(rowKey.getBytes());</span><br><span class="line">      delete.deleteFamily(FAMILY_TO_BE_DELETE, ts);</span><br><span class="line"></span><br><span class="line">      ImmutableBytesWritable row = <span class="keyword">new</span> ImmutableBytesWritable(rowKey.getBytes());</span><br><span class="line">      <span class="keyword">for</span> (List&lt;Cell&gt; cells : delete.getFamilyCellMap().values())&#123;</span><br><span class="line">        <span class="keyword">for</span> (Cell cell : cells)&#123;</span><br><span class="line">          KeyValue kv = KeyValueUtil.ensureKeyValue(cell);</span><br><span class="line">          context.write(row, kv);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注意这里需要自己将Delete转换为KeyValue。如果是正常写数据，直接将mapper的输出类设为Put就行</p>
<p>然后初始化并启动一个mapreduce job。其核心在于<code>HFileOutputFormat2.configureIncrementalLoad()</code>，这个方法会进一步设置一些job的属性，比如各种输入输出类型。有兴趣的话可以看看源码，如果不满意可以自行修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Path filePath = <span class="keyword">new</span> Path(<span class="string">"file:///tmp/input.txt"</span>);</span><br><span class="line">Path hfilePath = <span class="keyword">new</span> Path(<span class="string">"/tmp/"</span> + tableName + <span class="string">"/"</span> + UUID.randomUUID().toString());</span><br><span class="line">Job job = Job.getInstance(conf, <span class="string">"bulkLoad"</span>);</span><br><span class="line">job.setJarByClass(DeleteMapper.class);</span><br><span class="line">job.setMapperClass(DeleteMapper.class);</span><br><span class="line">HTable table = getHTable(tableName);</span><br><span class="line">HFileOutputFormat2.configureIncrementalLoad(job, table);</span><br><span class="line">FileInputFormat.addInputPath(job, filePath);</span><br><span class="line">FileOutputFormat.setOutputPath(job, hfilePath);</span><br><span class="line">job.waitForCompletion(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>如果job能正常运行，那么会在<code>&quot;/tmp/&quot; + tableName + &quot;/&quot; + UUID.randomUUID().toString()</code>下生成一些HFile。最后加载这些HFile，最好在加载完后把HFile删掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadIncrementalHFiles loadFiles = <span class="keyword">new</span> LoadIncrementalHFiles(conf);</span><br><span class="line">HTable table = getHTable(tableName);</span><br><span class="line">loadFiles.doBulkLoad(hfilePath, table);</span><br></pre></td></tr></table></figure>

<p>实际上现在很多hbase的操作都是想办法直接操作HFile而非直接访问region server，从而降低对线上服务的影响。目前没有在启用hbase加密的集群上试过，据说因为加解密是在region server上完成的，那么估计就不能用这种方式了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
