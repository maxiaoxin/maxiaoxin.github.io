<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="读书笔记">
<meta property="og:url" content="https://maxiaoxin.github.io/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记">
  <link rel="canonical" href="https://maxiaoxin.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/30/kmp-find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/30/kmp-find/" class="post-title-link" itemprop="url">用NFA解释KMP算法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-30 00:00:00 / Modified: 20:55:16" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">2019-12-30</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法" target="_blank" rel="noopener">KMP算法</a>是一个比较经典的字串搜索算法，相信学过一点算法的都知道。我一直觉得KMP算法理解起来非常反人类，尤其是我这种脑子比较轴的人，所以这里用NFA来解释KMP算法。leetcode原题在<a href="https://leetcode-cn.com/problems/implement-strstr/submissions/" target="_blank" rel="noopener">实现 strStr()</a>。</p>
<h2 id="NFA模拟字符串匹配"><a href="#NFA模拟字符串匹配" class="headerlink" title="NFA模拟字符串匹配"></a>NFA模拟字符串匹配</h2><p>如何用状态机来模拟字串搜索呢？假设目标串为<code>S=&quot;aabaabbcaabbccc&quot;</code>，模式串为<code>P=&quot;aabbcaab&quot;</code>，那么就可以制造这样一个NFA：</p>
<p>0<ruby>→ <rt>a</rt></ruby>1<ruby>→ <rt>a</rt></ruby>2<ruby>→ <rt>b</rt></ruby>3<ruby>→ <rt>b</rt></ruby>4<ruby>→ <rt>c</rt></ruby>5<ruby>→ <rt>a</rt></ruby>6<ruby>→ <rt>a</rt></ruby>7<ruby>→ <rt>b</rt></ruby>8</p>
<p>这里隐去了不成功的状态转移路径，所有未标注的状态转移路径都指向状态0，比如状态1在遇到非<code>a</code>的情况下应该跳转到0。</p>
<p>然后维持一个不重复的状态集，每解析一个目标串的字符，就尝试将集合中所有状态按照这个字符向前转移一次，初始集合为<code>{0}</code>，且转移后都要重新加入状态0。当状态集合包含最终状态（这里是状态8）时，我们认为匹配成功，否则认为匹配失败。那么针对于这个匹配，我们的状态转移过程是：</p>
<p>{0}<ruby>→ <rt>a</rt></ruby>{0,1}<ruby>→ <rt>a</rt></ruby>{0,1,2}<ruby>→ <rt>b</rt></ruby>{0,3}<ruby>→ <rt>a</rt></ruby>{0,1}<ruby>→ <rt>a</rt></ruby>{0,1,2}<ruby>→ <rt>b</rt></ruby>{0,3}<ruby>→ <rt>b</rt></ruby>{0,4}<ruby>→ <rt>c</rt></ruby>{0,5}<ruby>→ <rt>a</rt></ruby>{0,1,6}<ruby>→ <rt>a</rt></ruby>{0,1,2,7}<ruby>→ <rt>b</rt></ruby>{0,3,8}</p>
<p>可见最终的状态集合包含了目标状态8，因此匹配成功。</p>
<p>为什么可以用这样一个NFA来模拟字符串匹配过程？</p>
<ol>
<li>假设我们从目标串任意位置i开始，从初始集合{0}开始运行NFA，那么如果这个位置i与模式串匹配，那么最终一定会转移到最终状态，反之亦然</li>
<li>因此我们可以从目标串所有位置开始同时运行同一个NFA，只要其中一个转移到了状态8，那么就说明转移成功</li>
<li>由于所有初始集合均为{0}，而{0}是这些过程中任意集合的子集，且之后的状态转移路径完全相同，因此可以进行合并，即可以通过从前向后遍历目标串字符，并根据这些字符进行状态转移，就得到了同样的效果</li>
</ol>
<p>感觉说的不是特别清楚，有兴趣的可以看看编译原理。</p>
<h2 id="NFA到DFA"><a href="#NFA到DFA" class="headerlink" title="NFA到DFA"></a>NFA到DFA</h2><p>带着一个状态集跑NFA也是一个选择，但似乎可以更简化一些，比如我们可以仿照NFA转DFA的原理来重新思考这个问题。NFA转DFA的原理大致是将NFA的状态集合看作DFA的一个状态，然后不停扩展DFA的状态集合，直至不再变化。不过这里有些细小的差别：新增的状态集合需要再加一个状态0。</p>
<p>仍然以上面那个例子为例，</p>
<ul>
<li>{0}可以通过a转移到{0,1}，其他转移到{0}</li>
<li>{0,1}可以通过a转移到{0,1,2}，其他转移到{0}</li>
<li>{0,1,2}可以通过b转移到{0,3}，通过a转移到{0,1,2}，其他转移到{0}</li>
<li>{0,3}可以通过b转移到{0,4}，通过a转移到{0,1}，其他转移到{0}</li>
<li>{0,4}可以通过c转移到{0,5}，通过a转移到{0,1}，其他转移到{0}</li>
<li>…</li>
<li>{0,1,2,7}可以通过b转移到{0,3,8}，通过a转移到{0,1,2}，其他转移到{0}</li>
</ul>
<p>仔细观察这个扩展过程，有以下特点：</p>
<ol>
<li>每次都只会新增一个状态，且只和上一个状态集有关。比如{0,1,2}通过b转移到{0,3}，状态3由状态2而来，状态集{0,3}只和{0,1,2}有关</li>
<li>假设上一个状态集合为[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]，[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>]一定已经处理过，且s<sub>k</sub>一定会通过P[s<sub>k</sub>]转移到新状态s<sub>k</sub>+1</li>
<li>s<sub>k</sub>只能通过P[s<sub>k</sub>]转移到s<sub>k</sub>+1。对于非P[s<sub>k</sub>]的字符，s<sub>k</sub>只能转移到状态0，故状态集[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]遇到非P[s<sub>k</sub>]的字符的字符，转移后的状态集等同于状态集[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>]遇到相同字符转移后的状态集，且这个状态集一定已经处理过（证明起来比较麻烦，可以试试用数学归纳法）</li>
</ol>
<p>因此我们可以用状态s<sub>k</sub>来唯一指代状态集合[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]，且状态子集[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>]由状态s<sub>k-1</sub>唯一指定。换言之，可以记录一个数组prev，顺着这个数组，就能从状态s<sub>k</sub>找到全部的[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]。</p>
<p>那么如何来求prev呢？还是按照NFA转DFA中的扩展思路，假设对于状态s<sub>k</sub>，它所指代的状态集合为{s<sub>k</sub>,s<sub>k-1</sub>,…,s<sub>1</sub>,s<sub>0</sub>}={s<sub>k</sub>, prev[s<sub>k</sub>], prev[prev[s<sub>k</sub>]], …, 0}，其中s<sub>k</sub>可以通过P[s<sub>k</sub>]转移到s<sub>k</sub>+1，那接下来的问题就在于prev[s<sub>k</sub>], prev[prev[s<sub>k</sub>]], …, 0能通过P[s<sub>k</sub>]转移到哪。考虑其中的一个状态s<sub>m</sub>，有</p>
<ul>
<li>如果P[s<sub>m</sub>]==P[s<sub>k</sub>]，则s<sub>m</sub>可以通过P[s<sub>k</sub>]转移到s<sub>m</sub>+1，否则转移到0</li>
<li>假设s<sub>m</sub>可以通过P[s<sub>k</sub>]转移到s<sub>m</sub>+1，而s<sub>m</sub>+1已经被处理过，那么prev[s<sub>m</sub>]也可以通过P[s<sub>k</sub>]转移到prev[s<sub>m</sub>]+1，且prev[s<sub>m</sub>]+1==prev[s<sub>m</sub>+1]。这还是由于新状态只能由特定字符转换而来导致的。</li>
</ul>
<p>还是拿上面那个举例，已知prev[{1,2,3,4,5,6}]={0,1,0,0,0,1}，也就是已经计算得到状态6了，现在要计算状态7。状态6可以通过字符a转换到状态7，而状态prev[6]=1可以通过字符a转换到状态2，故prev[7]=2。也就是说，状态集{6,1,0}通过字符a转移到了状态集{7,2,1,0}。更一般的做法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makePrev</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prev)</span></span>&#123;</span><br><span class="line">  prev.resize(pattern.length()+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  prev[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.size(); ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> pi = prev[i];</span><br><span class="line">    <span class="keyword">while</span> (pi &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[pi])&#123;</span><br><span class="line">      pi = prev[pi];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pi == <span class="number">-1</span> || pattern[i] == pattern[pi])&#123; <span class="comment">// prev[0]设为-1主要是为了方便这里能合并if判断</span></span><br><span class="line">      prev[i+<span class="number">1</span>] = pi+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev[i+<span class="number">1</span>] = pi;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，假设我们已经得到了DFA，那么应该如何运行呢？之前提到，我们可以用最后一个状态s<sub>k</sub>来唯一指代一个状态集合来作为DFA的状态，而DFA中的状态能转移到哪得把状态集里所有状态都扫一遍。因此假设当前字符为c，有</p>
<ul>
<li>如果P[s<sub>k</sub>]==c，则转移到状态s<sub>k</sub>+1，否则得查P[prev[s<sub>k</sub>]]</li>
<li>下一个状态集至少有状态0</li>
</ul>
<p>因此可以这么判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (needle.size() &gt; haystack.size())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (needle.empty())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev;</span><br><span class="line">  makePrev(needle, prev);</span><br><span class="line">  <span class="keyword">int</span> successIndex = needle.size();</span><br><span class="line">  <span class="keyword">int</span> pi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.size(); ++i)&#123;</span><br><span class="line">    <span class="keyword">char</span> c = haystack[i];</span><br><span class="line">    <span class="keyword">while</span> (pi &gt;= <span class="number">0</span> &amp;&amp; c != needle[pi])&#123;</span><br><span class="line">      pi = prev[pi];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (++pi &gt;= successIndex)&#123; <span class="comment">// prev[0]设为-1后这里也能合并判断</span></span><br><span class="line">      <span class="keyword">return</span> i-needle.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实代码写出来就非常像KMP了，只是对于状态转移，KMP的解释是后缀匹配，但我个人很难理解后缀匹配，用笔算着算着就晕了。用状态转移解释的话，虽然说着麻烦，但自己笔算推演一下就很容易理解。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/13/opencv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/13/opencv/" class="post-title-link" itemprop="url">opencv简单使用</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-13 00:00:00 / Modified: 16:16:10" itemprop="dateCreated datePublished" datetime="2019-12-13T00:00:00+08:00">2019-12-13</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前试了一下，将ImageIO换成opencv后，图片转换效率和内存使用率有明显提升，比如同一张大图，ImageIO大概能用十来秒，opencv平均用时1秒左右，果断换了。</p>
<p>我编译出来opencv的动态链接库后，放到线上运行时还会报错<code>libstdc++.so</code>和<code>libjasper.so</code>找不到对应的版本，拷一个过去就可以了。</p>
<p>基本操作还是将原图转换为Mat，再做一大堆操作（旋转、缩放等），最后编码为目标图。</p>
<p>需要注意的有两点：</p>
<ul>
<li>opencv使用了大量堆外内存，所以需要把堆外内存调大点（<code>-XX:MaxDirectMemorySize</code>参数），并且几乎所有使用了堆外内粗的对象都要及时release</li>
<li>直接读文件可以用<code>imread()</code>，读内存用<code>imdecode()</code>，但这种方式会导致exif信息丢失，导致exif中如果有Orientation信息时，会导致转换后相对于原图旋转/翻转，因此要手动旋转/翻转。据说高版本的<code>imread()</code>会自动选择/翻转。</li>
</ul>
<p>但是对于动图，我暂时还没找到opencv的处理方法，所以还是用gifsicle+libwebp。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原图转换为Mat</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Mat <span class="title">bytes2mat</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">  MatOfByte matOfByte = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    matOfByte = <span class="keyword">new</span> MatOfByte(bytes);</span><br><span class="line">    <span class="keyword">return</span> Imgcodecs.imdecode(matOfByte, Imgcodecs.IMREAD_UNCHANGED);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matOfByte != <span class="keyword">null</span>)&#123;</span><br><span class="line">      matOfByte.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转/翻转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Mat <span class="title">doOrientation</span><span class="params">(Mat mat, Orientation orientation)</span></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (orientation)&#123;</span><br><span class="line">    <span class="keyword">case</span> TOP_LEFT:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TOP_RIGHT:</span><br><span class="line">      Core.flip(mat, mat, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BOTTOM_RIGHT:</span><br><span class="line">      Core.flip(mat, mat, -<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BOTTOM_LEFT:</span><br><span class="line">      Core.flip(mat, mat, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LEFT_TOP:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RIGHT_TOP:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      Core.flip(mat, mat, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RIGHT_BOTTOM:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      Core.flip(mat, mat, -<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LEFT_BOTTOM:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      Core.flip(mat, mat, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放+质量，也可以是别的什么操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] convertImage(<span class="keyword">byte</span>[] srcBytes, Orientation orientation, Size sz, String ext, <span class="keyword">int</span> quality)&#123;</span><br><span class="line">  Mat srcMat = <span class="keyword">null</span>;</span><br><span class="line">  Mat dstMat = <span class="keyword">null</span>;</span><br><span class="line">  MatOfByte dstMatByte = <span class="keyword">null</span>;</span><br><span class="line">  MatOfInt thumbParams = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    srcMat = bytes2mat(srcBytes);</span><br><span class="line">    <span class="keyword">if</span> (srcMat == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (orientation != <span class="keyword">null</span>)&#123;</span><br><span class="line">      doOrientation(srcMat, orientation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Size sz = <span class="keyword">new</span> Size(params.getDstWidth(), params.getDstHeight());</span><br><span class="line">    dstMat = <span class="keyword">new</span> Mat(sz, CvType.CV_8U);</span><br><span class="line">    Imgproc.resize(srcMat, dstMat, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ext.equals(<span class="string">".jpeg"</span>))&#123;</span><br><span class="line">        thumbParams = <span class="keyword">new</span> MatOfInt(Imgcodecs.IMWRITE_JPEG_QUALITY, quality);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ext.equals(<span class="string">".webp"</span>))&#123;</span><br><span class="line">        thumbParams = <span class="keyword">new</span> MatOfInt(Imgcodecs.IMWRITE_WEBP_QUALITY, quality);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dstMatByte = <span class="keyword">new</span> MatOfByte();</span><br><span class="line">    <span class="keyword">if</span> (thumbParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Imgcodecs.imencode(ext, dstMat, dstMatByte, thumbParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Imgcodecs.imencode(ext, dstMat, dstMatByte);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dstMatByte.toArray();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (srcMat != <span class="keyword">null</span>)&#123;</span><br><span class="line">      srcMat.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dstMat != <span class="keyword">null</span>)&#123;</span><br><span class="line">      dstMat.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dstMatByte != <span class="keyword">null</span>)&#123;</span><br><span class="line">      dstMatByte.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (thumbParams != <span class="keyword">null</span>)&#123;</span><br><span class="line">      thumbParams.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/11/gcc-upgrade/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/11/gcc-upgrade/" class="post-title-link" itemprop="url">用于编译的docker镜像搭建</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-11 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-11T00:00:00+08:00">2019-12-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-12 14:14:28" itemprop="dateModified" datetime="2019-12-12T14:14:28+08:00">2019-12-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有些库编译的时候，可能本地能过，但线上跑不了，所以需要以类似线上的环境建立一个docker镜像，在里面编译完后使用。我这里是编译opencv的时候有这种需求。线上是centos6，所以我用的基础镜像也是<code>centos:6</code>。</p>
<h3 id="基础编译环境"><a href="#基础编译环境" class="headerlink" title="基础编译环境"></a>基础编译环境</h3><ul>
<li>centos: <code>yum groupinstall &quot;Development Tools&quot;</code></li>
<li>ubuntu: <code>apt-get install -y build-essential</code></li>
</ul>
<h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><p>opencv对cmake版本有要求，所以需要升级一下cmake</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz    </span><br><span class="line">tar xvf cmake-3.6.2.tar.gz &amp;&amp; <span class="built_in">cd</span> cmake-3.6.2/</span><br><span class="line">./bootstrap</span><br><span class="line">gmake</span><br><span class="line">gmake install <span class="comment"># root权限</span></span><br></pre></td></tr></table></figure>

<p>然后执行<code>cmake --version</code>看看有没有生效</p>
<h3 id="高版本的gcc"><a href="#高版本的gcc" class="headerlink" title="高版本的gcc"></a>高版本的gcc</h3><p>按说这个不是必选项，但我用低版本的gcc编译opencv出了各种问题，比如<code>opencv/3rdparty/openexr/IlmThread/IlmThreadPool.cpp:49:19: error: atomic: No such file or directory</code>，所以还是升级一下</p>
<p>可以参考<a href="https://blog.51cto.com/2716255/1965617" target="_blank" rel="noopener">曲折的gcc升级详细步骤</a>，这几个依赖包能装都装一下，最好手动装，yum有点坑。我遇到的一个问题是线上gcc寻找头文件和库的路径有点问题，似乎不会搜索<code>/usr/local</code>，并且<code>--with-isl-lib</code>这样的参数实际上在编译期间是无效的。所以安装的时候可以重新指定路径，或者手动copy到<code>/usr/include</code>和<code>/lib64</code>下。</p>
<p><code>./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib --with-isl-include=/usr/local/isl/include --with-isl-lib=/usr/local/isl/lib/</code></p>
<p>编译出来gcc后，还遇到一个问题是编译opencv时报错<code>Error: no such instruction</code>，这个问题在于升级gcc的时候没有升级<code>assembler(/usr/bin/as)</code>，版本过低，因此需要再升级<code>binutils</code>。</p>
<p>不过我编译<code>binutils</code>的时候会报错<code>as.c:704:44: error: ‘TARGET_CANONICAL’ undeclared (first use in this function)</code>等一大堆错误，参考<a href="https://www.cnblogs.com/shakin/p/4276434.html" target="_blank" rel="noopener">使用zeranoe的自动化脚本mingw-w64-build-3.6.4在ubutun14.04_64bit上交叉编译ffmpeg 2.5</a>，可以把这几个变量取消掉<code>unset LIBRARY_PATH CPATH C_INCLUDE_PATH PKG_CONFIG_PATH CPLUS_INCLUDE_PATH INCLUDE</code></p>
<p>这几个依赖库make完后都可以执行<code>make check</code>来检测下是否正常。</p>
<h3 id="ant"><a href="#ant" class="headerlink" title="ant"></a>ant</h3><p>这个可以用<code>yum</code>或者<code>apt</code>之类的安装，也可以去官网下载，但无论哪种，都需要添加一个环境变量<code>ANT_HOME</code>，并且把<code>$ANT_HOME/bin</code>加到<code>PATH</code>里，<code>$ANT_HOME/lib</code>加到<code>CLASSPATH</code>里</p>
<p>至于jdk怎么安装就不提了</p>
<h3 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h3><p>此外还需要预安装一些编解码库，包括<code>zlib</code>,<code>jpeg</code>,<code>tiff</code>,<code>jasper</code>,<code>png</code>。我编译时报错<code>error: &#39;read&#39; is not a member of &#39;cv::TiffDecoderBufHelper&#39;</code>，需要加一个选项<code>-DBUILD_TIFF=ON</code></p>
<p>还有一个问题是，如果出现<code>Java wrappers: NO</code>，需要再安装python2.7以上，参考<a href="https://segmentfault.com/a/1190000000654227" target="_blank" rel="noopener">CENTOS 6.5 安装 Python 2.7 总结</a></p>
<p>正常的cmake流程即可，注意<code>cmake</code>完后需要看下有没有开启java选项</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=OFF -DBUILD_TESTS=OFF -D CMAKE_INSTALL_PREFIX=/opt/soft ..</span><br><span class="line">make -j16</span><br><span class="line"><span class="comment"># 可以不install，所以前面的prefix也可以不指定</span></span><br></pre></td></tr></table></figure>

<h3 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h3><p>可以找一个和线上环境相似的镜像，我直接用<code>centos:6</code>了，基本上需要运行这几条命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础工具</span></span><br><span class="line">yum -y groupinstall <span class="string">"Development Tools"</span></span><br><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake，从本地copy一个过来</span></span><br><span class="line"><span class="comment"># docker cp cmake-3.6.2 $&#123;docker_pid&#125;:/tmp/</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/cmake-3.6.2 &amp;&amp; ./bootstrap &amp;&amp; gmake &amp;&amp; gmake install</span><br><span class="line"></span><br><span class="line"><span class="comment"># jdk，注意安装完要添加环境变量JAVA_HOME，一般是/usr/lib/jvm/java-1.8.0-openjdk.x86_64</span></span><br><span class="line">yum install -y java-1.8.0-openjdk-devel.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># ant，注意安装完要添加环境变量将ANT_HOME，一般是/usr/share/ant</span></span><br><span class="line">yum install -y ant</span><br><span class="line"></span><br><span class="line"><span class="comment"># gcc依赖</span></span><br><span class="line">wget http://ftp.yz.yamagata-u.ac.jp/pub/GNU/gmp/gmp-6.1.2.tar.xz <span class="comment"># 太慢就挂代理，用法是wget $&#123;url&#125; -e use_proxy=yes -e http_proxy=$&#123;proxy&#125;</span></span><br><span class="line">tar -xvf gmp-6.1.2.tar.xz &amp;&amp; <span class="built_in">cd</span> gmp-6.1.2 &amp;&amp;  ./configure  --prefix=/usr/<span class="built_in">local</span>/gmp &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget http://ftp.gnu.org/gnu/mpfr/mpfr-4.0.2.tar.gz</span><br><span class="line">tar -xvf mpfr-4.0.2.tar.gz &amp;&amp; <span class="built_in">cd</span> mpfr-4.0.2 &amp;&amp; ./configure --with-gmp-include=/usr/<span class="built_in">local</span>/gmp/include  --with-gmp-lib=/usr/<span class="built_in">local</span>/gmp/lib --prefix=/usr/<span class="built_in">local</span>/mpfr &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget https://ftp.gnu.org/gnu/mpc/mpc-1.1.0.tar.gz</span><br><span class="line">tar -xvf mpc-1.1.0.tar.gz &amp;&amp; <span class="built_in">cd</span> mpc-1.1.0 &amp;&amp;  ./configure --with-mpfr-include=/usr/<span class="built_in">local</span>/mpfr/include  --with-mpfr-lib=/usr/<span class="built_in">local</span>/mpfr/lib --with-gmp-include=/usr/<span class="built_in">local</span>/gmp/include --with-gmp-lib=/usr/<span class="built_in">local</span>/gmp/lib --prefix=/usr/<span class="built_in">local</span>/mpc &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=/usr/<span class="built_in">local</span>/gmp/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line">wget http://isl.gforge.inria.fr/isl-0.22.tar.bz2</span><br><span class="line">tar -xvf isl-0.22.tar.bz2 &amp;&amp; <span class="built_in">cd</span> isl-0.22 &amp;&amp;  ./configure   --with-gmp-prefix==/usr/<span class="built_in">local</span>/gmp --prefix=/usr/<span class="built_in">local</span>/isl &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget ftp://gcc.gnu.org/pub/gcc/infrastructure/cloog-0.18.1.tar.gz</span><br><span class="line">tar -xvf  cloog-0.18.1.tar.gz &amp;&amp; <span class="built_in">cd</span> cloog-0.18.1 &amp;&amp;  ./configure   --with-gmp-prefix==/usr/<span class="built_in">local</span>/gmp -with-isl-prefix=/usr/<span class="built_in">local</span>/isl --prefix=/usr/<span class="built_in">local</span>/cloog &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># gcc</span></span><br><span class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-9.2.0/gcc-9.2.0.tar.gz</span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=/usr/<span class="built_in">local</span>/mpfr/include:/usr/<span class="built_in">local</span>/isl/include:/usr/<span class="built_in">local</span>/mpc/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"><span class="comment"># 这里不知道为啥，修改LD_LIBRARY_PATH或者/etc/ld.so.conf都不生效，只能把上面几个编译出来的动态链接库都扔到/usr/lib64/下</span></span><br><span class="line">./configure -<span class="built_in">enable</span>-checking=release -<span class="built_in">enable</span>-languages=c,c++ -<span class="built_in">disable</span>-multilib --with-gmp=/usr/<span class="built_in">local</span>/gmp/  --with-mpfr=/usr/<span class="built_in">local</span>/mpfr --with-mpc=/usr/<span class="built_in">local</span>/mpc</span><br><span class="line"></span><br><span class="line"><span class="comment"># binutils</span></span><br><span class="line">wget https://ftp.gnu.org/gnu/binutils/binutils-2.33.1.tar.gz -e use_proxy=yes -e http_proxy=<span class="variable">$&#123;proxy&#125;</span></span><br><span class="line"><span class="built_in">unset</span> LIBRARY_PATH CPATH C_INCLUDE_PATH PKG_CONFIG_PATH CPLUS_INCLUDE_PATH INCLUDE</span><br><span class="line">tar -xvf binutils-2.33.1.tar.gz</span><br><span class="line"> ./configure --prefix=/usr</span><br><span class="line"> make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一大堆编解码库</span></span><br><span class="line"> yum install -y zlib-devel.x86_64 libjpeg-turbo-devel.x86_64 jasper-devel.x86_64 libtiff-devel.x86_64  libpng-devel.x86_64</span><br><span class="line"></span><br><span class="line"> <span class="comment"># python 2.7</span></span><br><span class="line"> wget https://www.python.org/ftp/python/2.7.8/Python-2.7.8.tgz</span><br><span class="line">tar xf Python-2.7.8.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-2.7.8</span><br><span class="line">./configure --prefix=/usr/ &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># opencv，从本地copy一个过去</span></span><br><span class="line"><span class="comment"># docker cp opencv $&#123;docker_pid&#125;:/tmp/</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/opencv &amp;&amp; mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=OFF -DBUILD_TESTS=OFF -DBUILD_TIFF=ON ..</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<p>可以全部搞完再<code>docker commit</code>，也可以搞完一步就commit一下，看情况了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/05/hbase-buckload2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/05/hbase-buckload2/" class="post-title-link" itemprop="url">记录一下HBase BulkLoad使用过程中遇到的坑</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-05T00:00:00+08:00">2019-12-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-06 10:49:08" itemprop="dateModified" datetime="2019-12-06T10:49:08+08:00">2019-12-06</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这段时间被bulkload搞的头大，记录一些问题：</p>
<h2 id="HFile权限问题"><a href="#HFile权限问题" class="headerlink" title="HFile权限问题"></a>HFile权限问题</h2><p>HBase执行bulkload时需要对应HFile目录的读写权限。网上通用做法是递归<code>chmod</code>相关目录，感觉比较麻烦。</p>
<p>最好在临时文件所在的根目录为hbase用户增加default acl，并且要在<code>hdfs-site.xml</code>中增加<code>fs.permissions.umask-mode=000</code>这一项</p>
<p>默认的<code>fs.permissions.umask-mode</code>应该是022，这会导致新创建子目录的mask为’r-x’，hbase用户写操作失败。</p>
<h2 id="HBase的hadoop-client版本需要与hdfs版本相对应"><a href="#HBase的hadoop-client版本需要与hdfs版本相对应" class="headerlink" title="HBase的hadoop-client版本需要与hdfs版本相对应"></a>HBase的hadoop-client版本需要与hdfs版本相对应</h2><p>由于hbase region server需要加载HFile，即会去读写相关HFile文件，因此hadoop-client和hdfs版本不匹配会出现一些奇奇怪怪的问题。</p>
<p>我遇到的情况是2.6版本的<code>hadoop-client</code>访问2.4的hdfs会报权限错。但奇怪的是如果hbase访问hdfs有问题，那么region server根本不应该能跑起来，只能说是玄学。</p>
<h2 id="生成不同table的HFILE"><a href="#生成不同table的HFILE" class="headerlink" title="生成不同table的HFILE"></a>生成不同table的HFILE</h2><p>貌似<code>HFileOutputFormat2</code>只支持对于单表生成数据，那么如果需要通过某一过程同时生成两个以上表的HFILE就不能直接用了。最典型的例子是从表A把数据挪动到表B，再把表A数据删除。个人做法还是把<code>createRecordWriter()</code>方法抽取出来，毕竟自己通过<code>HFileWriter</code>去写，万一出问题了呢。</p>
<p>这里推荐一个博文<a href="http://www.zhangrenhua.com/2016/01/28/hadoop-Hbase%E5%BF%AB%E9%80%9F%E5%86%99%E5%85%A5%E8%A7%A3%E6%83%91%E4%B9%8BHFile/" target="_blank" rel="noopener">Hbase快速写入解惑之HFile</a>，里面有一个简单的本地生成HFile的例子。跑MapReduce的时候也可以参考</p>
<p>但本地生成的HFile，还需要再copy到HBase所在的HDFS集群的某个目录下，再执行<code>doBulkLoad()</code></p>
<p>这里有另一个问题是如果通过mapreduce作业生成HFile时，需不需要通过reduce来生成HFile。个人感觉还是自己控制会方便一点，建议把reduce num置为0，然后在map过程中将数据写入对应目录的不同taskId的子目录下，最后bulkload。</p>
<h2 id="写入HFile的时候需要保证KeyValue按字典序排序"><a href="#写入HFile的时候需要保证KeyValue按字典序排序" class="headerlink" title="写入HFile的时候需要保证KeyValue按字典序排序"></a>写入HFile的时候需要保证KeyValue按字典序排序</h2><p>比如要写1000行数据，每行有50个KeyValue，那么这50000个KeyValue都必须按字典序排序。</p>
<p>只使用<code>HFileOutputFormat2</code>的话不需要注意这一点，它会自动排序。</p>
<h2 id="尽量利用timestamp进行同步"><a href="#尽量利用timestamp进行同步" class="headerlink" title="尽量利用timestamp进行同步"></a>尽量利用timestamp进行同步</h2><p>由于绕开了RS，我们在写数据的时候无法通过CAS判断是否应当写入，那么timestamp就成了数据同步依据的唯一选择，但怎么用timestamp还得看具体情况</p>
<p>设t0&lt;t1&lt;t2，t0时刻我们决定清空比较早期的用户记录，如果扫表和生成HFile的时间很长，而用户t1时刻增加了记录，不指定deleteMarker的timestamp的话，在t2时刻进行bulkload时会删除这条记录，这显然是违背业务逻辑的</p>
<p>说起来为了时间戳同步这事还改动了其他模块的部分处理逻辑，真是肝疼。比如HBase timestamp有一个坑是，你可以在修改时指定一个时间戳去改，假如每次指定的timestamp相同，那么你有可能改成功。但如果某次操作是以相同timestamp写一个deleteMarker进去，那么之后再以相同时间戳写入就会失败（一直是deleteMarker），直到hbase执行compact。这个问题会导致我们不方便把一个timestamp分配给某个具体业务，以此为依据进行数据的增删改查——当然了，如果某个timestamp被置为deleteMarker，那么比这个timestamp更小的数据就有可能被compact掉。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/12/hbase-buckload/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/12/hbase-buckload/" class="post-title-link" itemprop="url">HBase BulkLoad简单用法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-12T00:00:00+08:00">2019-11-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-24 20:12:53" itemprop="dateModified" datetime="2019-11-24T20:12:53+08:00">2019-11-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>再更新一下，之前介绍的搞法会需要先通过MR作业生成一些HFile文件，但其实不一定需要用MR完成。这点可以看<code>HFileOutputFormat2.class</code>的源码，其中写HFile的核心是<code>createRecordWriter()</code>，而这个方法其实并没有用到MR作业的任何特性。</p>
<p>那么就可以自己手动把这段代码提取出来，生成一个类似<code>RecordWriter&lt;ImmutableBytesWritable, Cell&gt;</code>的类，这样可以直接在本地（或者别的什么地方）生成HFile。因此流程可以进一步简化为：</p>
<ol>
<li>直接将要写入的数据写入HFile</li>
<li>令hbase加载生成的HFile</li>
</ol>
<p>当然这个类是不是线程安全的我就不太清楚了，建议用之前加个锁，或者再优化一下代码</p>
<hr>
<p>最近发现BulkLoad这个好东西，记录一下</p>
<p>简单来说，正常的HBase写操作需要先经过Region Server，再通过一系列复杂操作后才会生成HFile并落盘（比如写WAL、flush、split等），进而生效。由于hbase的一个具体的region server是单点的，如果某个作业的写入量较大，很可能会把region server打爆。而我们知道，HBase持久化是通过HFile保存的，那么反过来，如果把写操作聚合成为一个HFile，再让hbase去加载这个hfile，那么就完成了写入操作，这样做可以省下大量的region server操作，降低负载，这个操作称为bulkload。</p>
<p>Bulkload大致步骤包括：</p>
<ol>
<li>生成要处理的数据。至于如何生成、生成什么格式得看具体场景，但无论如何，需要能被接下来的mapreduce作业访问到</li>
<li>提交一个mapreduce作业，这个作业需要读取步骤1中生成的数据，并转换为HFile。这个HFile一般可以放在hbase所在hdfs集群上的某个临时目录下面</li>
<li>令hbase加载步骤2生成的HFile</li>
</ol>
<p>网上大多数教程是讲如何导入数据，那么这里就讲讲如何批量删除数据。假设我们要删的数据保存在<code>/tmp/input.txt</code>里，以每行写一个timestamp和一个key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1573542224666,test157354-1958983957411631613/hello-00000</span><br><span class="line">1573542224674,test157354-1958983957411631613/hello-00001</span><br><span class="line">1573542224680,test157354-1958983957411631613/hello-00002</span><br><span class="line">1573542224687,test157354-1958983957411631613/hello-00003</span><br><span class="line">1573542224693,test157354-1958983957411631613/hello-00004</span><br><span class="line">1573542224700,test157354-1958983957411631613/hello-00005</span><br><span class="line">1573542224707,test157354-1958983957411631613/hello-00006</span><br><span class="line">1573542224713,test157354-1958983957411631613/hello-00007</span><br><span class="line">1573542224724,test157354-1958983957411631613/hello-00008</span><br><span class="line">1573542224730,test157354-1958983957411631613/hello-00009</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来要写一个mapper，将一行数据转换为KeyValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">ImmutableBytesWritable</span>, <span class="title">KeyValue</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">      String[] tokens = value.toString().split(<span class="string">","</span>, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">long</span> ts = Long.parseLong(tokens[<span class="number">0</span>]);</span><br><span class="line">      String rowKey = tokens[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      Delete delete = <span class="keyword">new</span> Delete(rowKey.getBytes());</span><br><span class="line">      delete.deleteFamily(FAMILY_TO_BE_DELETE, ts);</span><br><span class="line"></span><br><span class="line">      ImmutableBytesWritable row = <span class="keyword">new</span> ImmutableBytesWritable(rowKey.getBytes());</span><br><span class="line">      <span class="keyword">for</span> (List&lt;Cell&gt; cells : delete.getFamilyCellMap().values())&#123;</span><br><span class="line">        <span class="keyword">for</span> (Cell cell : cells)&#123;</span><br><span class="line">          KeyValue kv = KeyValueUtil.ensureKeyValue(cell);</span><br><span class="line">          context.write(row, kv);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注意这里需要自己将Delete转换为KeyValue。如果是正常写数据，直接将mapper的输出类设为Put就行</p>
<p>然后初始化并启动一个mapreduce job。其核心在于<code>HFileOutputFormat2.configureIncrementalLoad()</code>，这个方法会进一步设置一些job的属性，比如各种输入输出类型。有兴趣的话可以看看源码，如果不满意可以自行修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Path filePath = <span class="keyword">new</span> Path(<span class="string">"file:///tmp/input.txt"</span>);</span><br><span class="line">Path hfilePath = <span class="keyword">new</span> Path(<span class="string">"/tmp/"</span> + tableName + <span class="string">"/"</span> + UUID.randomUUID().toString());</span><br><span class="line">Job job = Job.getInstance(conf, <span class="string">"bulkLoad"</span>);</span><br><span class="line">job.setJarByClass(DeleteMapper.class);</span><br><span class="line">job.setMapperClass(DeleteMapper.class);</span><br><span class="line">HTable table = getHTable(tableName);</span><br><span class="line">HFileOutputFormat2.configureIncrementalLoad(job, table);</span><br><span class="line">FileInputFormat.addInputPath(job, filePath);</span><br><span class="line">FileOutputFormat.setOutputPath(job, hfilePath);</span><br><span class="line">job.waitForCompletion(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>如果job能正常运行，那么会在<code>&quot;/tmp/&quot; + tableName + &quot;/&quot; + UUID.randomUUID().toString()</code>下生成一些HFile。最后加载这些HFile，最好在加载完后把HFile删掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadIncrementalHFiles loadFiles = <span class="keyword">new</span> LoadIncrementalHFiles(conf);</span><br><span class="line">HTable table = getHTable(tableName);</span><br><span class="line">loadFiles.doBulkLoad(hfilePath, table);</span><br></pre></td></tr></table></figure>

<p>实际上现在很多hbase的操作都是想办法直接操作HFile而非直接访问region server，从而降低对线上服务的影响。目前没有在启用hbase加密的集群上试过，据说因为加解密是在region server上完成的，那么估计就不能用这种方式了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/09/redis-read6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/09/redis-read6/" class="post-title-link" itemprop="url">redis学习（6）事件</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-09T00:00:00+08:00">2019-11-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-12 21:32:05" itemprop="dateModified" datetime="2019-11-12T21:32:05+08:00">2019-11-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>redis总体架构是reactor模型，即通过不断等待并处理一个个事件来完成任务，其支持的事件类型可以分为文件事件和时间事件。redis的主进程实际上就是这样的一个过程，从源码可以看到，<code>main()</code>函数最后会调一个<code>aeMain()</code>的函数，它的内部是一个事件循环，处理事件的过程在<code>aeProcessEvents()</code>里完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不要求处理时间事件和文件事件则立刻返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// AE_DONT_WAIT标志表示是否需要尽快返回</span></span><br><span class="line">     <span class="comment">// 如果是的话，则将等待时间设的尽可能短</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要尽快处理一个时间事件，就找一个最近的</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123; <span class="comment">// 如果找到了</span></span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms = <span class="comment">// 就计算还要多久开始</span></span><br><span class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">                shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123; <span class="comment">// 并将其设为最长等待时间</span></span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123; <span class="comment">// 否则检查一下是否需要立即返回</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不需要的话就可以block任意久</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll一下有多少个文件事件就绪</span></span><br><span class="line">        <span class="comment">// 这个地方可能会sleep</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历文件事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">// 需要记录一下是否已经执行该事件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个地方有个特殊的标志是AE_BARRIER</span></span><br><span class="line">            <span class="comment">// 每个FileEvent有两个回调函数，分别是读操作和写操作</span></span><br><span class="line">            <span class="comment">// 一般会先读后写，比如先读完用户请求、处理完后再写回去</span></span><br><span class="line">            <span class="comment">// 但有时候需要先写后读，比如应当先落盘再通知用户已成功处理</span></span><br><span class="line">            <span class="comment">// 如果设置了AE_BARRIER，则表示先写后读</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行读操作</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行写操作</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果要求先写后读，那么这里还要执行一下读操作</span></span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是先检查有没有文件事件就绪，如果有就处理，没有的话依次处理已就绪的时间事件</p>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>基本上所有网络请求都是文件事件，比如先初始化并监听一个socket，直到数据过来。监听socket可以是evport、epoll、kqueue、select，这几个函数的使用优先级依次降低，具体用哪个和当前操作系统有关，linux上一般是epoll。redis将这些I/O复用函数统一整合包装成诸如<code>aeApiCreate()</code>、<code>aeApiAddEvent()</code>、<code>aeApiPoll()</code>之类的函数。其中最主要的还是<code>aeApiPoll()</code>，这个函数会阻塞当前线程，直到有事件就绪或超时，然后返回已就绪的句柄。一般认为<code>evport</code>、<code>kqueue</code>、<code>epoll</code>都是O(1)的时间复杂度，而<code>select</code>是O(n)。</p>
<p>一个完整的用户请求可能包含多个文件事件。以TCP请求为例，在服务器初始化时，会加入一系列以<code>acceptTcpHandler()</code>为回调函数的读事件，事件触发后会<code>accept()</code>用户请求，创建一个<code>client</code>和一个以<code>readQueryFromClient()</code>为回调函数的读事件。等这个事件再触发后，会去读用户传过来的数据，解析命令并处理请求，最后返回客户端。</p>
<p>值得一提的是，这里<code>poll</code>完了以后只是说句柄可以读/写了，而不是数据已经读完了，因此poll完后还需要自己调<code>read()</code>，这一步还是阻塞读。当然如果CPU处理不过来也会阻塞。</p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>时间事件的处理逻辑在<code>processTimeEvents()</code>里。相对来说时间事件没那么复杂，时间到了就执行。server维护了一个时间事件链表，每个时间事件结构体里维护了执行时间点、回调函数和一些别的数据。在加入一个时间事件时会将其插入表头，每次处理时间事件时会扫这个链表，如果一个事件的时间到了就执行。执行完后判断是不是重复事件，如果是（标志为<code>AE_NOMORE</code>）则调整其待执行时间，否则将其ID置为<code>AE_DELETED_EVENT_ID</code>，下次处理时间事件时执行它的<code>finalizerProc()</code>回调函数，并从链表中移除。</p>
<p>理论上扫整个链表确实耗时，不过redis内置的时间事件很少，一般也只有<code>serverCron()</code>。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/05/redis-read5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/05/redis-read5/" class="post-title-link" itemprop="url">redis学习（5）持久化</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-05T00:00:00+08:00">2019-11-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-06 21:11:51" itemprop="dateModified" datetime="2019-11-06T21:11:51+08:00">2019-11-06</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于单机数据库而言，持久化的思路大致分两种，一种是把当前状态（主要是数据，更具体的说是KV对）全部打包保存起来，恢复的时候直接装填；另一种是把所有写操作记录下来，恢复的时候回放这些操作。这两种思路分别对应于redis的RDB文件和AOF文件。</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>可以认为RDB是一种全量备份，其中RDB持久化的方式大致有两种，一种是服务器阻塞并备份，直至结束后再继续服务（<code>SAVE</code>、<code>FLUSHALL</code>命令）；另一种是fork一个子进程，由子进程去进行备份，子进程备份期间禁止再次启动子备份进程（<code>BGSAVE</code>或定时事件）。fork的一个好处是相当于对内存空间进行了快照操作，子线程访问到的数据都是某一时刻“正确的”数据，也就是这一时刻redis数据库的快照。无论哪种，最终调用的都是<code>rdbSave()</code>函数。</p>
<p>可以在redis服务器设置自动备份条件，保存在<code>redisServer-&gt;saveparams</code>里，主要条件有两个：时间间隔和操作次数。时间间隔很容易理解，操作次数则保存在<code>redisServer-&gt;dirty</code>，所有写操作都会增加<code>dirty</code>次数。因此在定时任务<code>serverCron()</code>里会检查各个条件是否已满足，满足则执行<code>rdbSaveBackground()</code></p>
<p><code>rdbSave()</code>是先创建一个临时文件，成功写入后再重命名为指定filename，核心的写操作是由<code>rdbSaveRio()</code>完成的，大致包括以下步骤：</p>
<ol>
<li>写入REDIS魔数和版本号</li>
<li>调用<code>rdbSaveInfoAuxFields()</code>保存redis辅助信息（AUX）</li>
<li>调用<code>rdbSaveModulesAux()</code>保存各个模块的AUX</li>
<li>遍历各个database，保存其id、object数、失效object数等，并遍历其键空间，获得每个object信息并保存</li>
<li>保存object时，如果开启RDB-AOF混合开关会从父进程读增量数据，这个地方没看懂</li>
<li>遍历并保存lua脚本</li>
<li>写入结束时的一些AUX和校验和</li>
</ol>
<p>在保存每个object时，还需要写入这个object的过期信息、LRU（如果开启相应开关）、LFU（如果开启相应开关）、type和具体数据。这部分代码比较复杂，总的来说大致流程是先按某种规则转换为数字/字符串，如果开启压缩则对字符串进行压缩，再写入文件。比如有序集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123; <span class="comment">// 如果有序集合采用ziplist实现</span></span><br><span class="line">    <span class="keyword">size_t</span> l = ziplistBlobLen((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)o-&gt;ptr);  <span class="comment">// 拿到ziplist长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,o-&gt;ptr,l)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 以裸字符串信息写入文件</span></span><br><span class="line">        nwritten += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123; <span class="comment">// 如果以skiplist实现</span></span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = rdbSaveLen(rdb,zsl-&gt;length)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 那么先保存总长度</span></span><br><span class="line">        nwritten += n;</span><br><span class="line"></span><br><span class="line">        zskiplistNode *zn = zsl-&gt;tail; <span class="comment">// 从尾节点开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (zn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = rdbSaveRawString(rdb, <span class="comment">// 以裸字符串形式保存这个节点的值</span></span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)zn-&gt;ele,sdslen(zn-&gt;ele))) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nwritten += n;</span><br><span class="line">        <span class="keyword">if</span> ((n = rdbSaveBinaryDoubleValue(rdb,zn-&gt;score)) == <span class="number">-1</span>) <span class="comment">// 以double形式保存这个节点的score</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten += n;</span><br><span class="line">        zn = zn-&gt;backward; <span class="comment">// 向前走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管可以fork一个子进程来备份，但载入RDB文件还是必须得阻塞执行。无论是RDB还是AOF，文件写完后都会调用<code>_exit()</code>，这个函数会给它的父进程发一个<code>SIGCHLD</code>信号，父进程接受到这个信号会做一些扫尾操作，比如<code>dirty、lastsave、lastbgsave_status</code>之类的，定义在<code>backgroundSaveDoneHandler()</code>里</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF的思路和HBase的WAL类似，都是通过记录写操作来持久化的。假如一开始数据为空，那么记录所有写操作当然可以重放出当前状态。但如果写AOF时数据不为空，且丢失了之前的写操作记录，那么就需要把存量数据先转换为写操作再记录下来。</p>
<p>在打开AOF持久化功能时，客户端每发送一条命令，如果造成数据变动（<code>server-&gt;dirty</code>发生变化），那么就会调用<code>propagate()</code>函数来把写操作写入AOF并传播到从节点。写入AOF调用的是<code>feedAppendOnlyFile()</code>函数，基本上是将命令还原为等价的redis命令字符串再写入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123; <span class="comment">// 将命令写入AOF文件</span></span><br><span class="line">    sds buf = sdsempty();</span><br><span class="line">    robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123; <span class="comment">// 需要额外加一条select命令</span></span><br><span class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid); <span class="comment">// snprintf是一个相对安全的格式化输出函数，第二个参数表示缓冲区最大长度</span></span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>, <span class="comment">// 将select命令写入buf</span></span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        server.aof_selected_db = dictid; <span class="comment">// 重置AOF正在使用的database id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand || <span class="comment">// 过期命令</span></span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]); <span class="comment">// 这个函数会将过期命令统一转换为PEXPIREAT</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123; <span class="comment">// 对于setex和setexp命令</span></span><br><span class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">"SET"</span>,<span class="number">3</span>);</span><br><span class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv); <span class="comment">// 会转换为一个写入命令</span></span><br><span class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]); <span class="comment">// 和一个过期命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123; <span class="comment">// 类似的，set命令也可能包含过期信息</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        robj *exarg = <span class="literal">NULL</span>, *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,argv); <span class="comment">// 先添加一个写命令</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; i ++) &#123; <span class="comment">// 因此需要取出过期参数</span></span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"ex"</span>)) exarg = argv[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"px"</span>)) pxarg = argv[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        serverAssert(!(exarg &amp;&amp; pxarg));</span><br><span class="line">        <span class="keyword">if</span> (exarg) <span class="comment">// 然后写入过期命令</span></span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               exarg);</span><br><span class="line">        <span class="keyword">if</span> (pxarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               pxarg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他命令直接写入即可</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON) <span class="comment">// 如果开启AOF，则将buf写入server.aof_buf</span></span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) <span class="comment">// 如果有后台子进程在运行，那么需要把这些新增的信息加进去</span></span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到实际上这个写操作只是将数据写入<code>server.aof_buf</code>，最后会统一通过<code>flushAppendOnlyFile()</code>落盘，其频率可以是<code>always</code>、<code>everysec</code>、或<code>no</code>。</p>
<p>当然这种记录写操作的一个缺点是日志可能越来越大，回放也会越来越慢，因此需要AOF重写，即丢弃之前的记录，从当前状态开始，将数据转换为等价的写操作并保存，对应的命令就是<code>BGREWRITEAOF</code>。同样的，重写结束后主进程会调用<code>backgroundRewriteDoneHandler()</code>做一些扫尾工作，比如把重写期间新产生的写操作添加进AOF文件里。另外解析出来的命令如果操作数太多，会将其分成多个命令，避免客户端缓冲区溢出。</p>
<p>一个自然而然的想法是，存量数据用RDB存，增量数据用AOF存。事实上redis4.0后增加了RDB-AOF混合持久化，持久化的文件前半段是RDB格式，后半段是AOF格式。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/02/redis-read4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/02/redis-read4/" class="post-title-link" itemprop="url">redis学习（4）数据库</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-02 00:00:00 / Modified: 20:16:42" itemprop="dateCreated datePublished" datetime="2019-11-02T00:00:00+08:00">2019-11-02</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>redis将数据按数据库（database）进行区分，有点像namespace。<code>redisServer</code>结构体维护了一个指向<code>redisDb</code>数组的指针，第i号database所使用的就是<code>redisDb[i]</code>，其定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;  <span class="comment">// 存放具体数据的字典，也称键空间（keyspace）</span></span><br><span class="line">    dict *expires; <span class="comment">// 存放设有超时时间的key的字典</span></span><br><span class="line">    dict *blocking_keys; <span class="comment">// 用以实现阻塞操作</span></span><br><span class="line">    dict *ready_keys; <span class="comment">// 用以实现阻塞操作</span></span><br><span class="line">    dict *watched_keys; <span class="comment">// 用以实现监控key</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">// 数据库id</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl; <span class="comment">// 平均TTL，只用来统计数据</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;  <span class="comment">// 需要整理碎片的key</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h2 id="键空间"><a href="#键空间" class="headerlink" title="键空间"></a>键空间</h2><p>dict存放了这个database的所有键和值，键都是<code>string</code>类型的<code>robj</code>，值可以是之前提到的5种<code>robj</code>。基本上常见的KV数据库的CRUD流程大概就和操作一个dict差不多，当然也有一些额外的操作：</p>
<ul>
<li>几乎所有操作前都要检查这个key有没有过期（过期信息在<code>redisDb-&gt;expires</code>字典里），如果过期则认为这个键不存在，且如果发现过期的键，则<ul>
<li>如果是master节点，需要将过期操作推送到slave节点和AOF文件</li>
<li>发送一个<code>NOTIFY_EXPIRED</code>事件</li>
<li>根据<code>lazyfree-lazy-expire</code>判断是否立即删除这个key，和删除操作类似类似</li>
</ul>
</li>
<li>同样的，几乎所有操作都会修改对应object的<code>lru</code>（最近访问时间/访问频次）</li>
<li>判断操作类型是否正确，比如<code>sadd</code>命令只能操作<code>set</code>对象</li>
<li>如果对现有的对象进行了修改，则需要根据<code>redisDb-&gt;watched_keys</code>判断这个key是否有监控，如果有的话需要将相关的<code>client</code>的flag添加<code>CLIENT_DIRTY_CAS</code>标记，并发送修改事件</li>
<li>对于删除操作，需要根据<code>lazyfree-lazy-expire</code>配置判断是否立即删除这个key<ul>
<li>同步删就是个dict删除操作，且如果是集群模式还要修改对应的slot</li>
<li>异步删的话需要从keyspace里去掉这个entry，然后判断对应的类型是否“容易”删除（目前是根据<code>quicklist</code>、<code>skiplist</code>、<code>hashtable</code>所含元素的多少来判断），如果容易删除就和同步删的操作类似，否则增加一个<code>bio_job</code>让后台线程删（这里终于用到同步了）</li>
</ul>
</li>
<li>读数据的时候还需要统计缓存命中次数</li>
</ul>
<p>这里代码分布在不同函数里，就只贴删除相关的代码了。顺便感慨一下单线程的好处，单线程意味着几乎所有操作都具有原子性（如果不是刻意打断的，比如rehash），如果是多线程的话需要加非常多的判断和锁，想想就很麻烦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> lazy)</span> </span>&#123; <span class="comment">// 删除接口</span></span><br><span class="line">    <span class="keyword">int</span> numdel = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123; <span class="comment">// 依次删除要删除的键</span></span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]); <span class="comment">// 判断是否已过期</span></span><br><span class="line">        <span class="keyword">int</span> deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) : <span class="comment">// 同步或异步删除</span></span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123; <span class="comment">// 如果删除成功</span></span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[j]); <span class="comment">// 则需要通知所有watch这个键的client</span></span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC, <span class="comment">// 然后发送一个删除事件</span></span><br><span class="line">                <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++; <span class="comment">// 并增加一个dirty计数</span></span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; 同步删除</span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr); <span class="comment">// 在expires里删除这条记录</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123; <span class="comment">// 然后从键空间里删除这条记录</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key); <span class="comment">// 如果是集群模式还要修改slot</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; <span class="comment">// 异步删除</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr); <span class="comment">// 先从expires里删除这条记录</span></span><br><span class="line"></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr); <span class="comment">// 然后从db-&gt;dict里删掉这个entry，但还没删具体数据</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123; <span class="comment">// 如果这个entry存在</span></span><br><span class="line">        robj *val = dictGetVal(de); <span class="comment">// 那么先拿到这个值</span></span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val); <span class="comment">// 再计算要删这个值的难度，大致就是根据hashtable、skiplist、quicklist的长度来判断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == <span class="number">1</span>) &#123; <span class="comment">// 如果难度超过阈值，且引用计数为1，说明应当释放内存</span></span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>); <span class="comment">// 那么增加要惰性删除的object数</span></span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="comment">// 把这个值扔到待删除队列里</span></span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>); <span class="comment">// 并把这个entry的value置空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (de) &#123; <span class="comment">// 这样一通操作下来，就可以立即删除entry里的key和value</span></span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de); <span class="comment">// 删除这个entry的key和value（其实是引用计数-1）</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key); <span class="comment">// 如果是集群模式还要修改slot</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>每个object都可以设置过期时间，可以指定过多长时间后失效（<code>EXPIRE</code>和<code>PEXPIRE</code>），或者在某一时刻后失效（<code>EXPIREAT</code>和<code>PEXPIREAT</code>）。不过这几个命令最后都转换为在某个时刻过期来实现，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(client *c, redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span> </span>&#123; <span class="comment">// 设置过期时间</span></span><br><span class="line">    dictEntry *kde, *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单来说就是保存到db-&gt;expires里，键和db-&gt;dict的键共享，值则作为一个long保存到entry-&gt;val里</span></span><br><span class="line">    kde = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,kde != <span class="literal">NULL</span>);</span><br><span class="line">    de = dictAddOrFind(db-&gt;expires,dictGetKey(kde));</span><br><span class="line">    dictSetSignedIntegerVal(de,when);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slave节点需要记录这个过期时间</span></span><br><span class="line">    <span class="keyword">int</span> writable_slave = server.masterhost &amp;&amp; server.repl_slave_ro == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &amp;&amp; writable_slave &amp;&amp; !(c-&gt;flags &amp; CLIENT_MASTER))</span><br><span class="line">        rememberSlaveKeyWithExpire(db,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireGenericCommand</span><span class="params">(client *c, <span class="keyword">long</span> <span class="keyword">long</span> basetime, <span class="keyword">int</span> unit)</span> </span>&#123; <span class="comment">// 处理过期命令</span></span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>], *param = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> when; <span class="comment">// 过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, param, &amp;when, <span class="literal">NULL</span>) != C_OK) <span class="comment">// 过期时间存放在client-&gt;argv[2]里，是一个long型对象</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unit == UNIT_SECONDS) when *= <span class="number">1000</span>;</span><br><span class="line">    when += basetime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果不存在这个键，则不进行任何处理</span></span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经过期了，且不是master节点或者loading状态</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt;= mstime() &amp;&amp; !server.loading &amp;&amp; !server.masterhost) &#123;</span><br><span class="line">        robj *aux;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c-&gt;db,key) : <span class="comment">// 那么需要先进行删除操作</span></span><br><span class="line">                                                    dbSyncDelete(c-&gt;db,key);</span><br><span class="line">        serverAssertWithInfo(c,key,deleted);</span><br><span class="line">        server.dirty++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要将用户命令修改为DEL或UNLINK，发送一个删除事件，并返回</span></span><br><span class="line">        aux = server.lazyfree_lazy_expire ? shared.unlink : shared.del;</span><br><span class="line">        rewriteClientCommandVector(c,<span class="number">2</span>,aux,key);</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        addReply(c, shared.cone);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则就设置一下过期时间，发送expire事件并返回</span></span><br><span class="line">        setExpire(c,c-&gt;db,key,when);</span><br><span class="line">        addReply(c,shared.cone);</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"expire"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否过期也很简单，因为expires里保存了具体的过期时间，那么对比一下就行了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; <span class="comment">//取出过期时间</span></span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> || <span class="comment">// 没找到就返回-1</span></span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然能在expires里找到这个key，那么理论上键空间里也应该有这个key</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de); <span class="comment">// 以有符号整数的形式取出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; <span class="comment">// 判断这个key是否过期</span></span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key); <span class="comment">// 具体过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 小于0表示永不过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// loading状态不做过期检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时间，具体为啥做判断我也不清楚</span></span><br><span class="line">    <span class="keyword">mstime_t</span> now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 键如果没过期就返回没过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 只有master节点能够认为过期的键已失效</span></span><br><span class="line"></span><br><span class="line">    server.stat_expiredkeys++; <span class="comment">// 统计过期键</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire); <span class="comment">// 向slave节点和AOF文件发送过期操作</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED, <span class="comment">// 发送一个事件</span></span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : <span class="comment">// 然后同步或异步的删除</span></span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过期数据删除策略"><a href="#过期数据删除策略" class="headerlink" title="过期数据删除策略"></a>过期数据删除策略</h2><p>《Redis设计与实现》里提到了三种删除策略：</p>
<ul>
<li>定时删除：由于我们知道什么时候过期，那么可以开启一个定时器，在对应时间唤醒一个删除操作</li>
<li>惰性删除：读到过期数据的时候再将其删除</li>
<li>定期删除：隔一段时间清理过期的数据</li>
</ul>
<p>显然第一种做法最精确，且能保证内存消耗最小，前提是需要创建和删除timer，这个timer的代价一般不会太小。第二种做法一方面会造成内存泄漏（过期数据不访问就不会被删除），另一方面会提高读写延时，因为删除一个复杂的对象还是很花时间的。</p>
<p>Redis做法是第三种，且理论上这个线程是可以侦测当前CPU是否空闲，从而决定删除频率。具体做法和redis的事件机制有关，之后再看看。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/10/28/redis-read3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/28/redis-read3/" class="post-title-link" itemprop="url">redis学习（3）对象</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-28 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-28T00:00:00+08:00">2019-10-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 14:31:14" itemprop="dateModified" datetime="2019-11-02T14:31:14+08:00">2019-11-02</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前提到，redis并没有把底层的数据结构暴露给用户，而是对用户提供string、list、set、zset、hash五种类型的object，底层采用之前提到的数据结构，它对用户理论上是透明的。这种分离机制的一个好处是可以根据具体场景进行优化，比如如果hash表非常小的时候，直接用ziplist保存键值对可能会比hashtable计算并查存会更高效，所用空间也更小。</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>redis使用对象来表示数据库中的键和值，每创建一个键值对时，redis会至少创建一个键对象和值对象，对象的基本定义如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 对外暴露的类型，包括string、list、set、zset、hash</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 具体编码，目前有11种</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">// LRU时间</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 具体数据</span></span><br><span class="line">&#125; robj; <span class="comment">// 总长度为16字节</span></span><br></pre></td></tr></table></figure>

<h3 id="string类型的编码转换"><a href="#string类型的编码转换" class="headerlink" title="string类型的编码转换"></a>string类型的编码转换</h3><p>redis用<code>int</code>、<code>embstr</code>或<code>raw</code>来实现string类型，<code>int</code>用来保存整数，且直接保存在<code>ptr</code>字段。<code>raw</code>即<code>sds</code>，而<code>embstr</code>稍微有点特殊。它主要用来存放短字符串，确切的说是字节数小于等于44的字符串（原来是39）。这是因为redis采用jemalloc内存分配器，这个分配器会分配8，16，32，64等字节的内存，因此一次申请64字节依次存放robj和sds，而由于robj占16字节，sdshdr8占3字节，<code>&#39;\0&#39;</code>占1字节，所以能最多能保存64-16-3-1=44字节（旧版的sds头占的空间更大一点，只留了39字节给实际数据）。以下是</p>
<p>redis保存浮点数时会先将其保存为字符串而非float/double，估计是因为精度；对浮点数的操作（比如<code>INCRBYFLOAT</code>）也是先转换为浮点数再保存为字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试编码一个string类型的object以节约空间</span></span><br><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要object的类型为string</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,o,o-&gt;type == OBJ_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是OBJ_ENCODING_EMBSTR类型或OBJ_ENCODING_RAW</span></span><br><span class="line">    <span class="keyword">if</span> (!sdsEncodedObject(o)) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数不能大于1，避免共享对象被修改</span></span><br><span class="line">     <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 尝试将string编码为long</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">         <span class="comment">// 如果能够编码为long，那么尝试用一个共享对象</span></span><br><span class="line">         <span class="comment">// redis提前预置了[0, 9999]之间的整数object作为共享对象</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">            !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">            value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">        &#123;</span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            incrRefCount(shared.integers[value]);</span><br><span class="line">            <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) &#123; <span class="comment">// 如果是raw类型，那么可以释放ptr指向的对象，直接修改指针的值即可</span></span><br><span class="line">                sdsfree(o-&gt;ptr);</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">                o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) &#123; <span class="comment">// 对于embstr，则需要减少原对象的引用次数，再创建一个新的</span></span><br><span class="line">                decrRefCount(o);</span><br><span class="line">                <span class="keyword">return</span> createStringObjectFromLongLongForValue(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123; <span class="comment">// 如果这个字符串比较小</span></span><br><span class="line">        robj *emb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) <span class="keyword">return</span> o; <span class="comment">// 并且不是embstr</span></span><br><span class="line">        emb = createEmbeddedStringObject(s,sdslen(s)); <span class="comment">// 那么就创建一个新的，并释放原来的</span></span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> emb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimStringObjectIfNeeded(o); <span class="comment">// 如果实在不能压缩，那么尝试把这个字符串前后的空格回车之类的字符删掉</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list对象的编码转换"><a href="#list对象的编码转换" class="headerlink" title="list对象的编码转换"></a>list对象的编码转换</h3><p>较早版本的list会用<code>ziplist</code>或<code>linkedlist</code>来实现，但目前统一用<code>quicklist</code>，如何节省内存完全交给<code>quicklist</code>解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypePush</span><span class="params">(robj *subject, robj *value, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;</span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line">        <span class="keyword">size_t</span> len = sdslen(value-&gt;ptr);</span><br><span class="line">        quicklistPush(subject-&gt;ptr, value-&gt;ptr, len, pos);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash对象的编码转换"><a href="#hash对象的编码转换" class="headerlink" title="hash对象的编码转换"></a>hash对象的编码转换</h3><p>hash可以用<code>ziplist</code>或<code>hashtable</code>实现，使用<code>ziplist</code>实现时，只是将键值对顺次插入，然后所有对hash表的操作都可以转换为对列表的操作。</p>
<p>对于大于<code>hash-max-ziplist-entries</code>的<code>ziplist</code>，redis会尝试将其转换为<code>hashtable</code>，默认值是512；同样的，如果任意一个键或者值的长度大于<code>hash-max-ziplist-value</code>的<code>ziplist</code>也会自动转换，默认阈值是64。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeSet</span><span class="params">(robj *o, sds field, sds value, <span class="keyword">int</span> flags)</span> </span>&#123; <span class="comment">// 更新一个KV，flags是个操作标志，可以设置是否允许hash表使用传进来的key/value，或者复制一个新的</span></span><br><span class="line">    <span class="keyword">int</span> update = <span class="number">0</span>; <span class="comment">// 如果是新增一项则为0，更新为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123; <span class="comment">// 如果是ziplist</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD); <span class="comment">// 从头节点开始</span></span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fptr = ziplistFind(fptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field), <span class="number">1</span>); <span class="comment">// 顺序查找key</span></span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果找到了key</span></span><br><span class="line">                vptr = ziplistNext(zl, fptr); <span class="comment">// 找到值，也就是ziplist的下一项</span></span><br><span class="line">                serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">                update = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                zl = ziplistDelete(zl, &amp;vptr); <span class="comment">// 从ziplist里删掉这个值</span></span><br><span class="line"></span><br><span class="line">                zl = ziplistInsert(zl, vptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value, <span class="comment">// 然后把新值写进去</span></span><br><span class="line">                        sdslen(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">            <span class="comment">// 如果没找到，那么就把新的KV写到最后</span></span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value, sdslen(value),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;ptr = zl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果大于阈值，就进行类型转换</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 如果</span></span><br><span class="line">        dictEntry *de = dictFind(o-&gt;ptr,field); <span class="comment">// 查找对应entry</span></span><br><span class="line">        <span class="keyword">if</span> (de) &#123; <span class="comment">// 如果找到了</span></span><br><span class="line">            sdsfree(dictGetVal(de)); <span class="comment">// 就释放原来的值</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123; <span class="comment">// 如果允许直接用传进来的值</span></span><br><span class="line">                dictGetVal(de) = value; <span class="comment">// 就写进去</span></span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dictGetVal(de) = sdsdup(value); <span class="comment">// 否则复制一个新的</span></span><br><span class="line">            &#125;</span><br><span class="line">            update = <span class="number">1</span>; <span class="comment">// 表示是更新操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sds f,v;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD) &#123; <span class="comment">// 如果允许直接用传进来的值，就写进去</span></span><br><span class="line">                f = field;</span><br><span class="line">                field = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = sdsdup(field);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123; <span class="comment">// 同上</span></span><br><span class="line">                v = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            dictAdd(o-&gt;ptr,f,v); <span class="comment">// 把这个新的entry写进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free SDS strings we did not referenced elsewhere if the flags</span></span><br><span class="line"><span class="comment">     * want this function to be responsible. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD &amp;&amp; field) sdsfree(field); <span class="comment">// 如果是传进来用的key，并且没有用到，那么释放</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE &amp;&amp; value) sdsfree(value); <span class="comment">// 类似</span></span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set对象的编码转换"><a href="#set对象的编码转换" class="headerlink" title="set对象的编码转换"></a>set对象的编码转换</h3><p>set可以用<code>intset</code>或<code>hashtable</code>实现，如果是<code>hashtable</code>编码，则只是单纯的将值置为<code>NULL</code>；对于<code>intset</code>，则在非int对象被添加时，或者具体总数大于<code>set-max-intset-entries</code>的时候转换为<code>hashtable</code>，默认值是512。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 如果是hashtable</span></span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>); <span class="comment">// 这个函数只是在key不存在的时候新建一个entry</span></span><br><span class="line">        <span class="keyword">if</span> (de) &#123; <span class="comment">// 如果新建了一个entry，需要写到hashtable里</span></span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123; <span class="comment">// 如果是intset</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123; <span class="comment">// 尝试将value编码为int</span></span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success); <span class="comment">// 尝试写入intset</span></span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries) <span class="comment">// 如果添加成功，但intset里包含的数量超过阈值</span></span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT); <span class="comment">// 那么尝试转换为hashtable</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT); <span class="comment">// 否则需要先转换为hashtable</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 再尝试把这个值写进去</span></span><br><span class="line">             <span class="comment">// 由于这个hashtable之前是个intset，而我们要插入的值一定不是个合法的int值，说明它一定不在原hashtable里</span></span><br><span class="line">             <span class="comment">// 所以可以直接调用dictAdd</span></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zset对象的编码转换"><a href="#zset对象的编码转换" class="headerlink" title="zset对象的编码转换"></a>zset对象的编码转换</h3><p>zset对象的底层可以是<code>ziplist</code>或<code>zset</code>。当创建有序集合时，总是先创建<code>zset</code>并添加进去，当entry总数不大于<code>zset-max-ziplist-entries</code>且总字节数不大于<code>zset-max-ziplist-value</code>时再转换为<code>ziplist</code>。类似的，如果元素太多，也会将<code>ziplist</code>扩展为<code>zset</code>，默认的<code>zset-max-ziplist-entries</code>为128，<code>zset-max-ziplist-value</code>为64。一个典型的插入流程如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetAdd</span><span class="params">(robj *zobj, <span class="keyword">double</span> score, sds ele, <span class="keyword">int</span> *flags, <span class="keyword">double</span> *newscore)</span> </span>&#123; <span class="comment">// 在有序集合里添加一项</span></span><br><span class="line">    <span class="keyword">int</span> incr = (*flags &amp; ZADD_INCR) != <span class="number">0</span>; <span class="comment">// 增加这一项的score</span></span><br><span class="line">    <span class="keyword">int</span> nx = (*flags &amp; ZADD_NX) != <span class="number">0</span>; <span class="comment">// 只有当对应元素不存在时才进行操作</span></span><br><span class="line">    <span class="keyword">int</span> xx = (*flags &amp; ZADD_XX) != <span class="number">0</span>; <span class="comment">// 只有当对应元素存在时进行操作</span></span><br><span class="line">    *flags = <span class="number">0</span>;<span class="comment">// 置为0</span></span><br><span class="line">    <span class="keyword">double</span> curscore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isnan(score)) &#123; <span class="comment">// 不允许假如值为NAN的元素</span></span><br><span class="line">        *flags = ZADD_NAN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123; <span class="comment">// 如果底层是ziplist</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123; <span class="comment">// 尝试找到这一项，由于ziplist非定长且只能从其中一个项跳到下一项，故采取顺序查找</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123; <span class="comment">// 找到了，但不允许修改，则返回</span></span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123; <span class="comment">// 如果要求增加score</span></span><br><span class="line">                score += curscore; <span class="comment">// 那么尝试增加</span></span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123; <span class="comment">// 确保新的score合法</span></span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score; <span class="comment">// 新的score写到返回值里</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123; <span class="comment">// 如果值发生了变化，那么需要把原来的项删了，再新加一项</span></span><br><span class="line">                zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score); <span class="comment">// 这个插入操作本质上是顺序查找，然后在指定位置先插入值，再插入score，且score需要编码为字符串</span></span><br><span class="line">                *flags |= ZADD_UPDATED; <span class="comment">// 标记为update</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123; <span class="comment">// 如果没找到，且允许在元素不存在时进行操作</span></span><br><span class="line">            zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score); <span class="comment">// 那么先插入</span></span><br><span class="line">            <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries || <span class="comment">// 然后判断entry是否过多</span></span><br><span class="line">                sdslen(ele) &gt; server.zset_max_ziplist_value) <span class="comment">// 或者这个元素太大</span></span><br><span class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST); <span class="comment">// 如果是的话就转换成跳表</span></span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score; <span class="comment">// 新的score写到返回值里</span></span><br><span class="line">            *flags |= ZADD_ADDED; <span class="comment">// 设置为add操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123; <span class="comment">// 如果底层是跳表</span></span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplistNode *znode;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = dictFind(zs-&gt;dict,ele); <span class="comment">// 那么先尝试在hash表里查有没有这一项</span></span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果有</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123; <span class="comment">// 且不允许操作</span></span><br><span class="line">                *flags |= ZADD_NOP; <span class="comment">// 就返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curscore = *(<span class="keyword">double</span>*)dictGetVal(de); <span class="comment">// 否则先查到score</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123; <span class="comment">// 增加score</span></span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123; <span class="comment">// 如果score发生了变化，需要修改跳表</span></span><br><span class="line">                znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score); <span class="comment">// 修改score，简单来说就是把原来的连接关系删了，重新调整一下</span></span><br><span class="line">                dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">// 再修改hashtable里的引用</span></span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123; <span class="comment">// 如果没找到，且允许增加</span></span><br><span class="line">            ele = sdsdup(ele); <span class="comment">// 复制一份</span></span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,ele); <span class="comment">// 插入到skiplist</span></span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK); <span class="comment">// 插入到hashtable</span></span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存回收和对象共享"><a href="#内存回收和对象共享" class="headerlink" title="内存回收和对象共享"></a>内存回收和对象共享</h2><p>由于redis的对象之间没有引用关系，因此简单的引用计数就可以判断一个object是否仍然被引用。这个东西比较像C++里的智能指针，且在引用计数被减为0的时候立刻释放内存。</p>
<p>引用计数可以很方便的实现共享对象。不过这个东西有点歧义，有时候共享对象也指redis启动时创建的一系列对象。如下所示，这些对象在创建的时候会把引用计数计为<code>OBJ_SHARED_REFCOUNT</code>，且在操作引用计数的时候会判断引用计数是否为这个特殊值，如果是的话则不进行任何操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sharedObjectsStruct</span> &#123;</span></span><br><span class="line">    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,</span><br><span class="line">    *colon, *nullbulk, *nullmultibulk, *queued,</span><br><span class="line">    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,</span><br><span class="line">    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,</span><br><span class="line">    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,</span><br><span class="line">    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,</span><br><span class="line">    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,</span><br><span class="line">    *rpop, *lpop, *lpush, *rpoplpush, *zpopmin, *zpopmax, *emptyscan,</span><br><span class="line">    *select[PROTO_SHARED_SELECT_CMDS],</span><br><span class="line">    *integers[OBJ_SHARED_INTEGERS],</span><br><span class="line">    *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], <span class="comment">/* "*&lt;value&gt;\r\n" */</span></span><br><span class="line">    *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  <span class="comment">/* "$&lt;value&gt;\r\n" */</span></span><br><span class="line">    sds minstring, maxstring;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a>数据淘汰机制</h2><p>作为缓存组件，redis不保证已保存的数据会一直保存下去，持久性应当由数据库来完成。这也意味着理论上redis可以在任意时刻废弃任意对象。当然一般来说还是在内存比较紧张的时候废弃对象，目前redis大致支持LRU、LFU、TTL算法，每个object的相关信息记录在<code>robj-&gt;lru</code>里。</p>
<h3 id="LRU（Least-Recently-Used）"><a href="#LRU（Least-Recently-Used）" class="headerlink" title="LRU（Least Recently Used）"></a>LRU（Least Recently Used）</h3><p>最近最旧未使用算法，即从当前时刻开始，优先淘汰最旧未使用的对象。</p>
<p>比较精准的LRU的做法是用hash表和双向链表来实现，使用的时候如果hash表里没有就在hash表里加一项，再把链表里的指针移动到队尾；废弃的时候从队首拿出来，并从hash表里删除。当然这么搞的话每次使用时都要更新两个数据结构，相对比较麻烦。</p>
<p>redis的做法就比较简单了：从目标集合里（可以是已过期数据集合，也可以是所有数据集合）随机找几个对象，按LRU算法删掉。无论使用哪种算法，redis都是先从一个object集合里随机挑几个对象，应用相应算法进行淘汰。随机算法也比较简单，就是随机选一些桶，把桶里的元素全返回，如果不够则继续。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123; <span class="comment">// 随机取一些数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tables; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stored = <span class="number">0</span>, maxsizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> maxsteps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) &lt; count) count = dictSize(d);</span><br><span class="line">    maxsteps = count*<span class="number">10</span>; <span class="comment">// 最多尝试count*10次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于redis是渐进式hash，需要考虑这方面问题</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">            _dictRehashStep(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tables = dictIsRehashing(d) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    maxsizemask = d-&gt;ht[<span class="number">0</span>].sizemask; <span class="comment">// 两个table中比较大的那个</span></span><br><span class="line">    <span class="keyword">if</span> (tables &gt; <span class="number">1</span> &amp;&amp; maxsizemask &lt; d-&gt;ht[<span class="number">1</span>].sizemask)</span><br><span class="line">        maxsizemask = d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = random() &amp; maxsizemask; <span class="comment">// 随机取一个值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> emptylen = <span class="number">0</span>; <span class="comment">// 当前一共遇到多少个空桶</span></span><br><span class="line">    <span class="keyword">while</span>(stored &lt; count &amp;&amp; maxsteps--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tables; j++) &#123;</span><br><span class="line">            <span class="comment">// rehash不变性使我们可以忽略一些桶</span></span><br><span class="line">            <span class="keyword">if</span> (tables == <span class="number">2</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; i &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= d-&gt;ht[<span class="number">1</span>].size)</span><br><span class="line">                    i = d-&gt;rehashidx;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= d-&gt;ht[j].size) <span class="keyword">continue</span>; <span class="comment">// 越界</span></span><br><span class="line">            dictEntry *he = d-&gt;ht[j].table[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Count contiguous empty buckets, and jump to other</span></span><br><span class="line"><span class="comment">             * locations if they reach 'count' (with a minimum of 5). */</span></span><br><span class="line">             <span class="comment">// 遇到一个空桶</span></span><br><span class="line">            <span class="keyword">if</span> (he == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                emptylen++;</span><br><span class="line">                <span class="keyword">if</span> (emptylen &gt;= <span class="number">5</span> &amp;&amp; emptylen &gt; count) &#123; <span class="comment">// 如果连续遇到5个以上空桶，且总数超过目标数</span></span><br><span class="line">                    i = random() &amp; maxsizemask; <span class="comment">// 那么重新选一个位置开始</span></span><br><span class="line">                    emptylen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                emptylen = <span class="number">0</span>; <span class="comment">// 否则清空</span></span><br><span class="line">                <span class="keyword">while</span> (he) &#123; <span class="comment">// 把这个桶里的object全返回出去</span></span><br><span class="line">                    *des = he;</span><br><span class="line">                    des++;</span><br><span class="line">                    he = he-&gt;next;</span><br><span class="line">                    stored++;</span><br><span class="line">                    <span class="keyword">if</span> (stored == count) <span class="keyword">return</span> stored;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>) &amp; maxsizemask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// LRU时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123; <span class="comment">// 时钟分辨率，要求服务器的频率高于10000，可以设置</span></span><br><span class="line">        atomicGet(server.lruclock,lruclock); <span class="comment">// redis自己维护的一个始终</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock(); <span class="comment">// 系统调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lruclock = LRU_CLOCK(); <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">if</span> (lruclock &gt;= o-&gt;lru) &#123; <span class="comment">// 如果当前事件比该对象的lru时间大</span></span><br><span class="line">        <span class="keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION; <span class="comment">// 那么相减就好</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) * <span class="comment">// 否则说明过了一轮，需要再加上LRU_CLOCK_MAX</span></span><br><span class="line">                    LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LFU（Least-Frequently-Used）"><a href="#LFU（Least-Frequently-Used）" class="headerlink" title="LFU（Least Frequently Used）"></a>LFU（Least Frequently Used）</h3><p>最近最少使用算法，即在最近一段时间内，优先淘汰使用频率最低的对象。计算频次的做法也比较好理解：每过一定时间减少固定次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUGetTimeInMinutes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// LRU算法下的当前时间</span></span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123; <span class="comment">// 根据object高16位计算已经过了多久</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt; <span class="comment">// 和上面那个类似，计算的时候需要取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123; <span class="comment">// 降低访问频次并返回频次</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">// 高16位用来表示最近降低时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">// 低8位来表示访问次数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : <span class="number">0</span>; <span class="comment">// 衰减，假设距离上次更新过了N个周期，那么就减去N*m个统计次数</span></span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter; <span class="comment">// 注意，最后用的时候使用255-counter作为idle（空闲）值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123; <span class="comment">// 增加计数器函数，估计是考虑到counter取值范围很小，所以增加计数难度</span></span><br><span class="line">      <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">      <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">      <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL; <span class="comment">// 注意初始会给一个object设置访问频次为5，避免一个object被创建后立刻删除</span></span><br><span class="line">      <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>); </span><br><span class="line">      <span class="keyword">if</span> (r &lt; p) counter++; <span class="comment">// 看看有没有通过测试</span></span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="TTL（Time-to-Live）"><a href="#TTL（Time-to-Live）" class="headerlink" title="TTL（Time to Live）"></a>TTL（Time to Live）</h3><p>剩余生存时间，即淘汰超过存活时间的对象。这个算法就比较简单了：<code>idle = ULLONG_MAX - (long)dictGetVal(de);</code>，其中de指向expire字典里的entry，其value是以long形式存的过期时间限制。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/10/08/docker-learn1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/08/docker-learn1/" class="post-title-link" itemprop="url">docker学习（1）</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-08T00:00:00+08:00">2019-10-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-25 16:01:36" itemprop="dateModified" datetime="2019-10-25T16:01:36+08:00">2019-10-25</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近需要把某个服务容器化后搞到K8S上，提高集群利用率，因此学习一下docker和K8S</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>执行<code>wget -qO- https://get.docker.com/ | sh</code>，输入密码即可。之后可能会报个权限错<code>Got permission denied while trying to connect to the Docker daemon socket at</code>，执行<code>sudo usermod -aG docker maxiaoxin &amp;&amp; newgrp - docker</code>即可。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>docker的基本架构如下图所示，从这个意义上讲，docker更像个隔离机制而非虚拟机，毕竟虚拟机是可以允许比如在linux上跑一个windows虚拟机的，而docker不能直接做到这一点。</p>
<p>而且和虚拟机不同的是，严格来说虚拟机是模拟了一个完整的主机，至少是一个完整的操作系统，并且理论上应该可以打一个包含所有运行状态的snapshot（至少包括CPU状态、内存状态和文件状态）。而docker的镜像只包含文件状态，并且非常不建议一个container起多个进程。</p>
<p><img src="/images/container-what-is-container.png" alt="docker基本架构"></p>
<ul>
<li>容器（container）：独立运行的一个或一组应用，以及它们的运行态环境。</li>
<li>镜像（image）：运行容器的所有基础设施，包括代码、运行库、依赖和其他文件系统的对象（类似snapshot）</li>
<li>仓库（repository）：类似git或maven中的仓库，支持版本控制</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>登录：<code>docker login ${uri}</code></li>
<li>从仓库pull一个镜像：<code>docker pull ${host}/${image_name}:${version}</code></li>
<li>上传镜像：<code>docker push ${user_name}/${image_name}</code></li>
<li>列出本地镜像：<code>docker images</code></li>
<li>删除镜像：<code>docker rmi ${image_id}</code></li>
<li>导出镜像文件到本地：<code>docker save -o ${file_name} ${image_name}:${tag}</code></li>
<li>导入镜像文件：<code>docker load --input ${file_name}</code></li>
<li>对容器进行快照，生成image：<code>docker commit ${options} ${container_ID} ${image_name}:${tag}</code>，很像git的commit</li>
<li>使用镜像创建一个容器：<code>docker create ${image_name}:${version}</code></li>
<li>创建并运行一个容器：<code>docker run ${options} ${image_name}:${version} ${args}</code>，其中<code>-i</code>表示打开容器的标准输入，<code>-t</code>告诉docker为容器建立一个命令行终端，<code>-d</code>表示使容器在后台运行，<code>-c</code>可以调整容器的CPU优先级，<code>--restart=always</code>表示无论容器返回码是什么都立刻重启，<code>--restart=on-failure:5</code>表示当返回码非0时重启，且可选择重启次数</li>
<li>启动已停止的容器：<code>docker start ${container_ID}</code></li>
<li>终止/强制停止容器：<code>docker stop ${container_ID}</code>，<code>docker kill ${container_ID}</code></li>
<li>删除一个已停止的容器：<code>docker rm ${container_ID}</code></li>
<li>搜索镜像：<code>docker search ${key_word}</code></li>
<li>查看容器：<code>docker ps ${options}</code>，其中不加任何参数的话是查看运行中的容器，<code>-a</code>查看所有容器（包括已停止的），<code>-l</code>查看最新创建的容器，<code>-n</code>是个数，<code>-q</code>是只列出容器ID</li>
</ul>
<p>当然不是所有情况都适合用commit命令，也可以用<code>docker build</code>来创建一个新的镜像，需要先创建一个Dockerfile，比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line">FROM centos:6.8</span><br><span class="line">MAINTAINER MXX</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure>

<p>其中<code>FROM</code>一定要写，表示继承自哪个image。如果是空的话可以写为<code>FROM scratch</code>，但一般不太会这么写；<code>MAINTAINER</code>是作者名；<code>RUN</code>代表要执行的命令。</p>
<p>另外还有些比较常见的命令，比如</p>
<ul>
<li><code>ADD/COPY</code>用来复制本地文件到镜像</li>
<li><code>EXPOSE</code>命令向外部开放端口，但只是个声明</li>
<li><code>CMD/ENTRYPOINT</code>命令用来描述容器启动后运行的程序等</li>
<li><code>WORKDIR</code>工作目录，如果没有会创建</li>
<li><code>USER</code>当前用户，值得一提的是我在用centos的时候，如果不加上<code>USER root</code>的话，某些情况会报权限错</li>
</ul>
<p>然后执行<code>docker build . -t ${image_name}:${tag}</code>就可以生成了。</p>
<p>值得一提的是docker有个概念layer，意指dockerfile的每条指令，或者每个commit都会产生一个“层”（类似git里一个分支上有多个commit）。之所以有这个概念，是因为docker的文件系统采用了UnionFS，以减少修改文件带来的额外存储开销，也就是只存储差分信息。假如差分存储的代价比较大（比如差分的单位是文件，假如某个1GB的文件只修改了1个byte，那么也会额外产生1GB的信息），那么层越多，镜像越大——当然层越多，不同镜像能共享的文件也就越多，这个也需要取舍。</p>
<p>一般来说启动的还是一个一直运行的服务，而如果依赖比较小的话，可以不用<code>centos</code>这样“重”的基础镜像，参考<a href="https://zhuanlan.zhihu.com/p/54640767" target="_blank" rel="noopener">最小化 Java 镜像的常用技巧</a>。不过比较坑的一点是<code>alpine</code>用的是<code>musl</code>而不是<code>glibc</code>，这将导致某些系统调用不兼容，比如<code>qsort_r</code>。当时我差点改<code>musl</code>源代码了，后来上网找了一个手写的块排加强版代码直接用。</p>
<h2 id="kubernetes相关"><a href="#kubernetes相关" class="headerlink" title="kubernetes相关"></a>kubernetes相关</h2><p>docker的任务是创建镜像，而如果调度计算资源来运行镜像需要靠kubernetes（k8s）。客户端怎么下载和配置就忽略过了，假设我们已经搞了一个镜像<code>hello/world</code>，公司的registry是<code>foo.bar.net</code>，那么常见的命令包括：</p>
<ul>
<li>创建镜像：<code>docker build . -t foo.bar.net/hello/world</code>，注意这里要写全，最好把<code>tag</code>也写上</li>
<li>登录：<code>docker login foo.bar.net</code></li>
<li>上传：<code>docker push foo.bar.net/hello/world</code></li>
<li>创建pod：<code>kubectl create -f helloworld-deployment.yaml</code></li>
<li>创建service：<code>kubectl create -f helloworld_service.yaml</code></li>
<li>创建ingress：<code>kubectl create -f helloworld-ingress.yaml</code></li>
<li>查看状态：<code>kubectl get pod -o wide|grep hello-world</code></li>
</ul>
<p>核心在于pod、service、ingress这三个概念，对应的三个配置文件分别是<code>helloworld-deployment.yaml</code>、<code>helloworld_service.yaml</code>、<code>helloworld-ingress.yaml</code>。其中Pod 是一组紧密关联的容器集合，Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现，而Ingress可以简单的理解成k8s内部的nginx, 和service配合，用作负载均衡器。具体示例可以参考<a href="https://www.mirantis.com/blog/introduction-to-yaml-creating-a-kubernetes-deployment/" target="_blank" rel="noopener">Introduction to YAML: Creating a Kubernetes deployment</a>，总之是一大堆和资源调度相关的配置。</p>
<p>刚才碰到的一个问题是，上传的文件大于1MB会报错413，那么需要在ingress的配置里加入<code>metadata:annotations:nginx.ingress.kubernetes.io/proxy-body-size: &quot;25m&quot;</code></p>
<p>有时候也需要rewrite url，需要加上<code>nginx.ingress.kubernetes.io/rewrite-target</code>，具体怎么用参考<a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/" target="_blank" rel="noopener">Rewrite</a></p>
<h3 id="配置和挂载"><a href="#配置和挂载" class="headerlink" title="配置和挂载"></a>配置和挂载</h3><p>一般来说还是应该将配置文件和docker镜像分开，在运行的时候从某个地方读，这里我常用的有三种：configMap, secrets和emptyDir。</p>
<ul>
<li>emptyDir主要用来在pod重启时不丢失这个路径下的信息，比如某个服务可能挂了，被K8S重新拉起，假如没有一个地方存储日志，就不能确定挂掉的原因了。但如果pod被删掉了，那么emptyDir也会自动删掉。</li>
<li>configMap主要存放配置信息，一种用法是把所有配置信息的键值对直接写进这个文件，然后通过环境变量传进容器。另一种是通过类似<code>kubectl create configmap ${config_name} --from-file=${dir_path}</code>创建，然后通过volumes的方式挂载到某个路径下，到时候去这里读取。但如果用yaml的方式创建/更新的话，无法引用外部文件，必须写在一个yaml配置文件里。如果是挂载目录的方式的话，至少默认这个目录是只读的。</li>
<li>secrets和configMap很像，不过主要用来存储敏感信息，比如用户名密码之类的。但一般不会在配置文件里写明文，而是写base64编码后的信息。比如要把一个keytab写进去，那么就可以用<code>cat ${file_name} | base64</code>得到其编码，再写到yaml配置文件里。至于secrets的安全性就不清楚了。类似的，默认挂载后的目录是只读的。</li>
</ul>
<p>我试了一下，采用挂载的方式，如果更新configMap和secrets后，pod上对应目录下的文件也会更新。至于环境变量是容器运行的时候写的，当然不能更新了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
