<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="读书笔记">
<meta property="og:url" content="https://maxiaoxin.github.io/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记">
  <link rel="canonical" href="https://maxiaoxin.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/05/hbase-buckload2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/05/hbase-buckload2/" class="post-title-link" itemprop="url">记录一下HBase BulkLoad使用过程中遇到的坑</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-05 00:00:00 / Modified: 22:42:58" itemprop="dateCreated datePublished" datetime="2019-12-05T00:00:00+08:00">2019-12-05</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这段时间被bulkload搞的头大，记录一些问题：</p>
<h2 id="HFile权限问题"><a href="#HFile权限问题" class="headerlink" title="HFile权限问题"></a>HFile权限问题</h2><p>HBase执行bulkload时需要对应HFile目录的读写权限。网上通用做法是递归<code>chmod</code>相关目录，感觉比较麻烦。</p>
<p>最好在临时文件所在的根目录为hbase用户增加default acl，并且要在<code>hdfs-site.xml</code>中增加<code>fs.permissions.umask-mode=000</code>这一项</p>
<p>默认的<code>fs.permissions.umask-mode</code>应该是022，这会导致新创建子目录的mask为’r-x’，hbase用户写操作失败。</p>
<h2 id="HBase的hadoop-client版本需要与hdfs版本相对应"><a href="#HBase的hadoop-client版本需要与hdfs版本相对应" class="headerlink" title="HBase的hadoop-client版本需要与hdfs版本相对应"></a>HBase的hadoop-client版本需要与hdfs版本相对应</h2><p>由于hbase region server需要加载HFile，即会去读写相关HFile文件，因此hadoop-client和hdfs版本不匹配会出现一些奇奇怪怪的问题。</p>
<p>我遇到的情况是2.6版本的<code>hadoop-client</code>访问2.4的hdfs会报权限错。但奇怪的是如果hbase访问hdfs有问题，那么region server根本不应该能跑起来，只能说是玄学。</p>
<h2 id="生成不同table的HFILE"><a href="#生成不同table的HFILE" class="headerlink" title="生成不同table的HFILE"></a>生成不同table的HFILE</h2><p>貌似<code>HFileOutputFormat2</code>只支持对于单表生成数据，那么如果需要通过某一过程同时生成两个以上表的HFILE就不能直接用了。最典型的例子是从表A把数据挪动到表B，再把表A数据删除。个人做法还是把<code>createRecordWriter()</code>方法抽取出来，毕竟自己通过<code>HFileWriter</code>去写，万一出问题了呢。</p>
<p>这里推荐一个博文<a href="http://www.zhangrenhua.com/2016/01/28/hadoop-Hbase%E5%BF%AB%E9%80%9F%E5%86%99%E5%85%A5%E8%A7%A3%E6%83%91%E4%B9%8BHFile/" target="_blank" rel="noopener">Hbase快速写入解惑之HFile</a>，里面有一个简单的本地生成HFile的例子。跑MapReduce的时候也可以参考</p>
<p>但本地生成的HFile，还需要再copy到HBase所在的HDFS集群的某个目录下，再执行<code>doBulkLoad()</code></p>
<p>这里有另一个问题是如果通过mapreduce作业生成HFile时，需不需要通过reduce来生成HFile。个人感觉还是自己控制会方便一点，建议把reduce num置为0，然后在map过程中将数据写入对应目录的不同taskId的子目录下，最后bulkload。</p>
<h2 id="写入HFile的时候需要保证KeyValue按字典序排序"><a href="#写入HFile的时候需要保证KeyValue按字典序排序" class="headerlink" title="写入HFile的时候需要保证KeyValue按字典序排序"></a>写入HFile的时候需要保证KeyValue按字典序排序</h2><p>比如要写1000行数据，每行有50个KeyValue，那么这50000个KeyValue都必须按字典序排序。</p>
<p>只使用<code>HFileOutputFormat2</code>的话不需要注意这一点，它会自动排序。</p>
<h2 id="尽量利用timestamp进行同步"><a href="#尽量利用timestamp进行同步" class="headerlink" title="尽量利用timestamp进行同步"></a>尽量利用timestamp进行同步</h2><p>由于绕开了RS，我们在写数据的时候无法通过CAS判断是否应当写入，那么timestamp就成了数据同步依据的唯一选择，但怎么用timestamp还得看具体情况</p>
<p>设t0&lt;t1&lt;t2，t0时刻我们决定清空比较早期的用户记录，如果扫表和生成HFile的时间很长，而用户t1时刻增加了记录，不指定deleteMarker的timestamp的话，在t2时刻进行bulkload时会删除这条记录，这显然是违背业务逻辑的</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/12/hbase-buckload/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/12/hbase-buckload/" class="post-title-link" itemprop="url">HBase BulkLoad简单用法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-12T00:00:00+08:00">2019-11-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-24 20:12:53" itemprop="dateModified" datetime="2019-11-24T20:12:53+08:00">2019-11-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>再更新一下，之前介绍的搞法会需要先通过MR作业生成一些HFile文件，但其实不一定需要用MR完成。这点可以看<code>HFileOutputFormat2.class</code>的源码，其中写HFile的核心是<code>createRecordWriter()</code>，而这个方法其实并没有用到MR作业的任何特性。</p>
<p>那么就可以自己手动把这段代码提取出来，生成一个类似<code>RecordWriter&lt;ImmutableBytesWritable, Cell&gt;</code>的类，这样可以直接在本地（或者别的什么地方）生成HFile。因此流程可以进一步简化为：</p>
<ol>
<li>直接将要写入的数据写入HFile</li>
<li>令hbase加载生成的HFile</li>
</ol>
<p>当然这个类是不是线程安全的我就不太清楚了，建议用之前加个锁，或者再优化一下代码</p>
<hr>
<p>最近发现BulkLoad这个好东西，记录一下</p>
<p>简单来说，正常的HBase写操作需要先经过Region Server，再通过一系列复杂操作后才会生成HFile并落盘（比如写WAL、flush、split等），进而生效。由于hbase的一个具体的region server是单点的，如果某个作业的写入量较大，很可能会把region server打爆。而我们知道，HBase持久化是通过HFile保存的，那么反过来，如果把写操作聚合成为一个HFile，再让hbase去加载这个hfile，那么就完成了写入操作，这样做可以省下大量的region server操作，降低负载，这个操作称为bulkload。</p>
<p>Bulkload大致步骤包括：</p>
<ol>
<li>生成要处理的数据。至于如何生成、生成什么格式得看具体场景，但无论如何，需要能被接下来的mapreduce作业访问到</li>
<li>提交一个mapreduce作业，这个作业需要读取步骤1中生成的数据，并转换为HFile。这个HFile一般可以放在hbase所在hdfs集群上的某个临时目录下面</li>
<li>令hbase加载步骤2生成的HFile</li>
</ol>
<p>网上大多数教程是讲如何导入数据，那么这里就讲讲如何批量删除数据。假设我们要删的数据保存在<code>/tmp/input.txt</code>里，以每行写一个timestamp和一个key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1573542224666,test157354-1958983957411631613/hello-00000</span><br><span class="line">1573542224674,test157354-1958983957411631613/hello-00001</span><br><span class="line">1573542224680,test157354-1958983957411631613/hello-00002</span><br><span class="line">1573542224687,test157354-1958983957411631613/hello-00003</span><br><span class="line">1573542224693,test157354-1958983957411631613/hello-00004</span><br><span class="line">1573542224700,test157354-1958983957411631613/hello-00005</span><br><span class="line">1573542224707,test157354-1958983957411631613/hello-00006</span><br><span class="line">1573542224713,test157354-1958983957411631613/hello-00007</span><br><span class="line">1573542224724,test157354-1958983957411631613/hello-00008</span><br><span class="line">1573542224730,test157354-1958983957411631613/hello-00009</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来要写一个mapper，将一行数据转换为KeyValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">ImmutableBytesWritable</span>, <span class="title">KeyValue</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">      String[] tokens = value.toString().split(<span class="string">","</span>, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">long</span> ts = Long.parseLong(tokens[<span class="number">0</span>]);</span><br><span class="line">      String rowKey = tokens[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      Delete delete = <span class="keyword">new</span> Delete(rowKey.getBytes());</span><br><span class="line">      delete.deleteFamily(FAMILY_TO_BE_DELETE, ts);</span><br><span class="line"></span><br><span class="line">      ImmutableBytesWritable row = <span class="keyword">new</span> ImmutableBytesWritable(rowKey.getBytes());</span><br><span class="line">      <span class="keyword">for</span> (List&lt;Cell&gt; cells : delete.getFamilyCellMap().values())&#123;</span><br><span class="line">        <span class="keyword">for</span> (Cell cell : cells)&#123;</span><br><span class="line">          KeyValue kv = KeyValueUtil.ensureKeyValue(cell);</span><br><span class="line">          context.write(row, kv);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注意这里需要自己将Delete转换为KeyValue。如果是正常写数据，直接将mapper的输出类设为Put就行</p>
<p>然后初始化并启动一个mapreduce job。其核心在于<code>HFileOutputFormat2.configureIncrementalLoad()</code>，这个方法会进一步设置一些job的属性，比如各种输入输出类型。有兴趣的话可以看看源码，如果不满意可以自行修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Path filePath = <span class="keyword">new</span> Path(<span class="string">"file:///tmp/input.txt"</span>);</span><br><span class="line">Path hfilePath = <span class="keyword">new</span> Path(<span class="string">"/tmp/"</span> + tableName + <span class="string">"/"</span> + UUID.randomUUID().toString());</span><br><span class="line">Job job = Job.getInstance(conf, <span class="string">"bulkLoad"</span>);</span><br><span class="line">job.setJarByClass(DeleteMapper.class);</span><br><span class="line">job.setMapperClass(DeleteMapper.class);</span><br><span class="line">HTable table = getHTable(tableName);</span><br><span class="line">HFileOutputFormat2.configureIncrementalLoad(job, table);</span><br><span class="line">FileInputFormat.addInputPath(job, filePath);</span><br><span class="line">FileOutputFormat.setOutputPath(job, hfilePath);</span><br><span class="line">job.waitForCompletion(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>如果job能正常运行，那么会在<code>&quot;/tmp/&quot; + tableName + &quot;/&quot; + UUID.randomUUID().toString()</code>下生成一些HFile。最后加载这些HFile，最好在加载完后把HFile删掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadIncrementalHFiles loadFiles = <span class="keyword">new</span> LoadIncrementalHFiles(conf);</span><br><span class="line">HTable table = getHTable(tableName);</span><br><span class="line">loadFiles.doBulkLoad(hfilePath, table);</span><br></pre></td></tr></table></figure>

<p>实际上现在很多hbase的操作都是想办法直接操作HFile而非直接访问region server，从而降低对线上服务的影响。目前没有在启用hbase加密的集群上试过，据说因为加解密是在region server上完成的，那么估计就不能用这种方式了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/09/redis-read6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/09/redis-read6/" class="post-title-link" itemprop="url">redis学习（6）事件</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-09T00:00:00+08:00">2019-11-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-12 21:32:05" itemprop="dateModified" datetime="2019-11-12T21:32:05+08:00">2019-11-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>redis总体架构是reactor模型，即通过不断等待并处理一个个事件来完成任务，其支持的事件类型可以分为文件事件和时间事件。redis的主进程实际上就是这样的一个过程，从源码可以看到，<code>main()</code>函数最后会调一个<code>aeMain()</code>的函数，它的内部是一个事件循环，处理事件的过程在<code>aeProcessEvents()</code>里完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不要求处理时间事件和文件事件则立刻返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// AE_DONT_WAIT标志表示是否需要尽快返回</span></span><br><span class="line">     <span class="comment">// 如果是的话，则将等待时间设的尽可能短</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要尽快处理一个时间事件，就找一个最近的</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123; <span class="comment">// 如果找到了</span></span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms = <span class="comment">// 就计算还要多久开始</span></span><br><span class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">                shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123; <span class="comment">// 并将其设为最长等待时间</span></span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123; <span class="comment">// 否则检查一下是否需要立即返回</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不需要的话就可以block任意久</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll一下有多少个文件事件就绪</span></span><br><span class="line">        <span class="comment">// 这个地方可能会sleep</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历文件事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">// 需要记录一下是否已经执行该事件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个地方有个特殊的标志是AE_BARRIER</span></span><br><span class="line">            <span class="comment">// 每个FileEvent有两个回调函数，分别是读操作和写操作</span></span><br><span class="line">            <span class="comment">// 一般会先读后写，比如先读完用户请求、处理完后再写回去</span></span><br><span class="line">            <span class="comment">// 但有时候需要先写后读，比如应当先落盘再通知用户已成功处理</span></span><br><span class="line">            <span class="comment">// 如果设置了AE_BARRIER，则表示先写后读</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行读操作</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行写操作</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果要求先写后读，那么这里还要执行一下读操作</span></span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是先检查有没有文件事件就绪，如果有就处理，没有的话依次处理已就绪的时间事件</p>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>基本上所有网络请求都是文件事件，比如先初始化并监听一个socket，直到数据过来。监听socket可以是evport、epoll、kqueue、select，这几个函数的使用优先级依次降低，具体用哪个和当前操作系统有关，linux上一般是epoll。redis将这些I/O复用函数统一整合包装成诸如<code>aeApiCreate()</code>、<code>aeApiAddEvent()</code>、<code>aeApiPoll()</code>之类的函数。其中最主要的还是<code>aeApiPoll()</code>，这个函数会阻塞当前线程，直到有事件就绪或超时，然后返回已就绪的句柄。一般认为<code>evport</code>、<code>kqueue</code>、<code>epoll</code>都是O(1)的时间复杂度，而<code>select</code>是O(n)。</p>
<p>一个完整的用户请求可能包含多个文件事件。以TCP请求为例，在服务器初始化时，会加入一系列以<code>acceptTcpHandler()</code>为回调函数的读事件，事件触发后会<code>accept()</code>用户请求，创建一个<code>client</code>和一个以<code>readQueryFromClient()</code>为回调函数的读事件。等这个事件再触发后，会去读用户传过来的数据，解析命令并处理请求，最后返回客户端。</p>
<p>值得一提的是，这里<code>poll</code>完了以后只是说句柄可以读/写了，而不是数据已经读完了，因此poll完后还需要自己调<code>read()</code>，这一步还是阻塞读。当然如果CPU处理不过来也会阻塞。</p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>时间事件的处理逻辑在<code>processTimeEvents()</code>里。相对来说时间事件没那么复杂，时间到了就执行。server维护了一个时间事件链表，每个时间事件结构体里维护了执行时间点、回调函数和一些别的数据。在加入一个时间事件时会将其插入表头，每次处理时间事件时会扫这个链表，如果一个事件的时间到了就执行。执行完后判断是不是重复事件，如果是（标志为<code>AE_NOMORE</code>）则调整其待执行时间，否则将其ID置为<code>AE_DELETED_EVENT_ID</code>，下次处理时间事件时执行它的<code>finalizerProc()</code>回调函数，并从链表中移除。</p>
<p>理论上扫整个链表确实耗时，不过redis内置的时间事件很少，一般也只有<code>serverCron()</code>。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/05/redis-read5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/05/redis-read5/" class="post-title-link" itemprop="url">redis学习（5）持久化</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-05T00:00:00+08:00">2019-11-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-06 21:11:51" itemprop="dateModified" datetime="2019-11-06T21:11:51+08:00">2019-11-06</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于单机数据库而言，持久化的思路大致分两种，一种是把当前状态（主要是数据，更具体的说是KV对）全部打包保存起来，恢复的时候直接装填；另一种是把所有写操作记录下来，恢复的时候回放这些操作。这两种思路分别对应于redis的RDB文件和AOF文件。</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>可以认为RDB是一种全量备份，其中RDB持久化的方式大致有两种，一种是服务器阻塞并备份，直至结束后再继续服务（<code>SAVE</code>、<code>FLUSHALL</code>命令）；另一种是fork一个子进程，由子进程去进行备份，子进程备份期间禁止再次启动子备份进程（<code>BGSAVE</code>或定时事件）。fork的一个好处是相当于对内存空间进行了快照操作，子线程访问到的数据都是某一时刻“正确的”数据，也就是这一时刻redis数据库的快照。无论哪种，最终调用的都是<code>rdbSave()</code>函数。</p>
<p>可以在redis服务器设置自动备份条件，保存在<code>redisServer-&gt;saveparams</code>里，主要条件有两个：时间间隔和操作次数。时间间隔很容易理解，操作次数则保存在<code>redisServer-&gt;dirty</code>，所有写操作都会增加<code>dirty</code>次数。因此在定时任务<code>serverCron()</code>里会检查各个条件是否已满足，满足则执行<code>rdbSaveBackground()</code></p>
<p><code>rdbSave()</code>是先创建一个临时文件，成功写入后再重命名为指定filename，核心的写操作是由<code>rdbSaveRio()</code>完成的，大致包括以下步骤：</p>
<ol>
<li>写入REDIS魔数和版本号</li>
<li>调用<code>rdbSaveInfoAuxFields()</code>保存redis辅助信息（AUX）</li>
<li>调用<code>rdbSaveModulesAux()</code>保存各个模块的AUX</li>
<li>遍历各个database，保存其id、object数、失效object数等，并遍历其键空间，获得每个object信息并保存</li>
<li>保存object时，如果开启RDB-AOF混合开关会从父进程读增量数据，这个地方没看懂</li>
<li>遍历并保存lua脚本</li>
<li>写入结束时的一些AUX和校验和</li>
</ol>
<p>在保存每个object时，还需要写入这个object的过期信息、LRU（如果开启相应开关）、LFU（如果开启相应开关）、type和具体数据。这部分代码比较复杂，总的来说大致流程是先按某种规则转换为数字/字符串，如果开启压缩则对字符串进行压缩，再写入文件。比如有序集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123; <span class="comment">// 如果有序集合采用ziplist实现</span></span><br><span class="line">    <span class="keyword">size_t</span> l = ziplistBlobLen((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)o-&gt;ptr);  <span class="comment">// 拿到ziplist长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,o-&gt;ptr,l)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 以裸字符串信息写入文件</span></span><br><span class="line">        nwritten += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123; <span class="comment">// 如果以skiplist实现</span></span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = rdbSaveLen(rdb,zsl-&gt;length)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 那么先保存总长度</span></span><br><span class="line">        nwritten += n;</span><br><span class="line"></span><br><span class="line">        zskiplistNode *zn = zsl-&gt;tail; <span class="comment">// 从尾节点开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (zn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = rdbSaveRawString(rdb, <span class="comment">// 以裸字符串形式保存这个节点的值</span></span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)zn-&gt;ele,sdslen(zn-&gt;ele))) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nwritten += n;</span><br><span class="line">        <span class="keyword">if</span> ((n = rdbSaveBinaryDoubleValue(rdb,zn-&gt;score)) == <span class="number">-1</span>) <span class="comment">// 以double形式保存这个节点的score</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten += n;</span><br><span class="line">        zn = zn-&gt;backward; <span class="comment">// 向前走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管可以fork一个子进程来备份，但载入RDB文件还是必须得阻塞执行。无论是RDB还是AOF，文件写完后都会调用<code>_exit()</code>，这个函数会给它的父进程发一个<code>SIGCHLD</code>信号，父进程接受到这个信号会做一些扫尾操作，比如<code>dirty、lastsave、lastbgsave_status</code>之类的，定义在<code>backgroundSaveDoneHandler()</code>里</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF的思路和HBase的WAL类似，都是通过记录写操作来持久化的。假如一开始数据为空，那么记录所有写操作当然可以重放出当前状态。但如果写AOF时数据不为空，且丢失了之前的写操作记录，那么就需要把存量数据先转换为写操作再记录下来。</p>
<p>在打开AOF持久化功能时，客户端每发送一条命令，如果造成数据变动（<code>server-&gt;dirty</code>发生变化），那么就会调用<code>propagate()</code>函数来把写操作写入AOF并传播到从节点。写入AOF调用的是<code>feedAppendOnlyFile()</code>函数，基本上是将命令还原为等价的redis命令字符串再写入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123; <span class="comment">// 将命令写入AOF文件</span></span><br><span class="line">    sds buf = sdsempty();</span><br><span class="line">    robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123; <span class="comment">// 需要额外加一条select命令</span></span><br><span class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid); <span class="comment">// snprintf是一个相对安全的格式化输出函数，第二个参数表示缓冲区最大长度</span></span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>, <span class="comment">// 将select命令写入buf</span></span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        server.aof_selected_db = dictid; <span class="comment">// 重置AOF正在使用的database id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand || <span class="comment">// 过期命令</span></span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]); <span class="comment">// 这个函数会将过期命令统一转换为PEXPIREAT</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123; <span class="comment">// 对于setex和setexp命令</span></span><br><span class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">"SET"</span>,<span class="number">3</span>);</span><br><span class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv); <span class="comment">// 会转换为一个写入命令</span></span><br><span class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]); <span class="comment">// 和一个过期命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123; <span class="comment">// 类似的，set命令也可能包含过期信息</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        robj *exarg = <span class="literal">NULL</span>, *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,argv); <span class="comment">// 先添加一个写命令</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; i ++) &#123; <span class="comment">// 因此需要取出过期参数</span></span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"ex"</span>)) exarg = argv[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"px"</span>)) pxarg = argv[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        serverAssert(!(exarg &amp;&amp; pxarg));</span><br><span class="line">        <span class="keyword">if</span> (exarg) <span class="comment">// 然后写入过期命令</span></span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               exarg);</span><br><span class="line">        <span class="keyword">if</span> (pxarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               pxarg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他命令直接写入即可</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON) <span class="comment">// 如果开启AOF，则将buf写入server.aof_buf</span></span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) <span class="comment">// 如果有后台子进程在运行，那么需要把这些新增的信息加进去</span></span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到实际上这个写操作只是将数据写入<code>server.aof_buf</code>，最后会统一通过<code>flushAppendOnlyFile()</code>落盘，其频率可以是<code>always</code>、<code>everysec</code>、或<code>no</code>。</p>
<p>当然这种记录写操作的一个缺点是日志可能越来越大，回放也会越来越慢，因此需要AOF重写，即丢弃之前的记录，从当前状态开始，将数据转换为等价的写操作并保存，对应的命令就是<code>BGREWRITEAOF</code>。同样的，重写结束后主进程会调用<code>backgroundRewriteDoneHandler()</code>做一些扫尾工作，比如把重写期间新产生的写操作添加进AOF文件里。另外解析出来的命令如果操作数太多，会将其分成多个命令，避免客户端缓冲区溢出。</p>
<p>一个自然而然的想法是，存量数据用RDB存，增量数据用AOF存。事实上redis4.0后增加了RDB-AOF混合持久化，持久化的文件前半段是RDB格式，后半段是AOF格式。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/02/redis-read4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/02/redis-read4/" class="post-title-link" itemprop="url">redis学习（4）数据库</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-02 00:00:00 / Modified: 20:16:42" itemprop="dateCreated datePublished" datetime="2019-11-02T00:00:00+08:00">2019-11-02</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>redis将数据按数据库（database）进行区分，有点像namespace。<code>redisServer</code>结构体维护了一个指向<code>redisDb</code>数组的指针，第i号database所使用的就是<code>redisDb[i]</code>，其定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;  <span class="comment">// 存放具体数据的字典，也称键空间（keyspace）</span></span><br><span class="line">    dict *expires; <span class="comment">// 存放设有超时时间的key的字典</span></span><br><span class="line">    dict *blocking_keys; <span class="comment">// 用以实现阻塞操作</span></span><br><span class="line">    dict *ready_keys; <span class="comment">// 用以实现阻塞操作</span></span><br><span class="line">    dict *watched_keys; <span class="comment">// 用以实现监控key</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">// 数据库id</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl; <span class="comment">// 平均TTL，只用来统计数据</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;  <span class="comment">// 需要整理碎片的key</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h2 id="键空间"><a href="#键空间" class="headerlink" title="键空间"></a>键空间</h2><p>dict存放了这个database的所有键和值，键都是<code>string</code>类型的<code>robj</code>，值可以是之前提到的5种<code>robj</code>。基本上常见的KV数据库的CRUD流程大概就和操作一个dict差不多，当然也有一些额外的操作：</p>
<ul>
<li>几乎所有操作前都要检查这个key有没有过期（过期信息在<code>redisDb-&gt;expires</code>字典里），如果过期则认为这个键不存在，且如果发现过期的键，则<ul>
<li>如果是master节点，需要将过期操作推送到slave节点和AOF文件</li>
<li>发送一个<code>NOTIFY_EXPIRED</code>事件</li>
<li>根据<code>lazyfree-lazy-expire</code>判断是否立即删除这个key，和删除操作类似类似</li>
</ul>
</li>
<li>同样的，几乎所有操作都会修改对应object的<code>lru</code>（最近访问时间/访问频次）</li>
<li>判断操作类型是否正确，比如<code>sadd</code>命令只能操作<code>set</code>对象</li>
<li>如果对现有的对象进行了修改，则需要根据<code>redisDb-&gt;watched_keys</code>判断这个key是否有监控，如果有的话需要将相关的<code>client</code>的flag添加<code>CLIENT_DIRTY_CAS</code>标记，并发送修改事件</li>
<li>对于删除操作，需要根据<code>lazyfree-lazy-expire</code>配置判断是否立即删除这个key<ul>
<li>同步删就是个dict删除操作，且如果是集群模式还要修改对应的slot</li>
<li>异步删的话需要从keyspace里去掉这个entry，然后判断对应的类型是否“容易”删除（目前是根据<code>quicklist</code>、<code>skiplist</code>、<code>hashtable</code>所含元素的多少来判断），如果容易删除就和同步删的操作类似，否则增加一个<code>bio_job</code>让后台线程删（这里终于用到同步了）</li>
</ul>
</li>
<li>读数据的时候还需要统计缓存命中次数</li>
</ul>
<p>这里代码分布在不同函数里，就只贴删除相关的代码了。顺便感慨一下单线程的好处，单线程意味着几乎所有操作都具有原子性（如果不是刻意打断的，比如rehash），如果是多线程的话需要加非常多的判断和锁，想想就很麻烦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> lazy)</span> </span>&#123; <span class="comment">// 删除接口</span></span><br><span class="line">    <span class="keyword">int</span> numdel = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123; <span class="comment">// 依次删除要删除的键</span></span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]); <span class="comment">// 判断是否已过期</span></span><br><span class="line">        <span class="keyword">int</span> deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) : <span class="comment">// 同步或异步删除</span></span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123; <span class="comment">// 如果删除成功</span></span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[j]); <span class="comment">// 则需要通知所有watch这个键的client</span></span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC, <span class="comment">// 然后发送一个删除事件</span></span><br><span class="line">                <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++; <span class="comment">// 并增加一个dirty计数</span></span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; 同步删除</span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr); <span class="comment">// 在expires里删除这条记录</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123; <span class="comment">// 然后从键空间里删除这条记录</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key); <span class="comment">// 如果是集群模式还要修改slot</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; <span class="comment">// 异步删除</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr); <span class="comment">// 先从expires里删除这条记录</span></span><br><span class="line"></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr); <span class="comment">// 然后从db-&gt;dict里删掉这个entry，但还没删具体数据</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123; <span class="comment">// 如果这个entry存在</span></span><br><span class="line">        robj *val = dictGetVal(de); <span class="comment">// 那么先拿到这个值</span></span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val); <span class="comment">// 再计算要删这个值的难度，大致就是根据hashtable、skiplist、quicklist的长度来判断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == <span class="number">1</span>) &#123; <span class="comment">// 如果难度超过阈值，且引用计数为1，说明应当释放内存</span></span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>); <span class="comment">// 那么增加要惰性删除的object数</span></span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="comment">// 把这个值扔到待删除队列里</span></span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>); <span class="comment">// 并把这个entry的value置空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (de) &#123; <span class="comment">// 这样一通操作下来，就可以立即删除entry里的key和value</span></span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de); <span class="comment">// 删除这个entry的key和value（其实是引用计数-1）</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key); <span class="comment">// 如果是集群模式还要修改slot</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>每个object都可以设置过期时间，可以指定过多长时间后失效（<code>EXPIRE</code>和<code>PEXPIRE</code>），或者在某一时刻后失效（<code>EXPIREAT</code>和<code>PEXPIREAT</code>）。不过这几个命令最后都转换为在某个时刻过期来实现，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(client *c, redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span> </span>&#123; <span class="comment">// 设置过期时间</span></span><br><span class="line">    dictEntry *kde, *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单来说就是保存到db-&gt;expires里，键和db-&gt;dict的键共享，值则作为一个long保存到entry-&gt;val里</span></span><br><span class="line">    kde = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,kde != <span class="literal">NULL</span>);</span><br><span class="line">    de = dictAddOrFind(db-&gt;expires,dictGetKey(kde));</span><br><span class="line">    dictSetSignedIntegerVal(de,when);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slave节点需要记录这个过期时间</span></span><br><span class="line">    <span class="keyword">int</span> writable_slave = server.masterhost &amp;&amp; server.repl_slave_ro == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &amp;&amp; writable_slave &amp;&amp; !(c-&gt;flags &amp; CLIENT_MASTER))</span><br><span class="line">        rememberSlaveKeyWithExpire(db,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireGenericCommand</span><span class="params">(client *c, <span class="keyword">long</span> <span class="keyword">long</span> basetime, <span class="keyword">int</span> unit)</span> </span>&#123; <span class="comment">// 处理过期命令</span></span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>], *param = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> when; <span class="comment">// 过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, param, &amp;when, <span class="literal">NULL</span>) != C_OK) <span class="comment">// 过期时间存放在client-&gt;argv[2]里，是一个long型对象</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unit == UNIT_SECONDS) when *= <span class="number">1000</span>;</span><br><span class="line">    when += basetime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果不存在这个键，则不进行任何处理</span></span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经过期了，且不是master节点或者loading状态</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt;= mstime() &amp;&amp; !server.loading &amp;&amp; !server.masterhost) &#123;</span><br><span class="line">        robj *aux;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c-&gt;db,key) : <span class="comment">// 那么需要先进行删除操作</span></span><br><span class="line">                                                    dbSyncDelete(c-&gt;db,key);</span><br><span class="line">        serverAssertWithInfo(c,key,deleted);</span><br><span class="line">        server.dirty++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要将用户命令修改为DEL或UNLINK，发送一个删除事件，并返回</span></span><br><span class="line">        aux = server.lazyfree_lazy_expire ? shared.unlink : shared.del;</span><br><span class="line">        rewriteClientCommandVector(c,<span class="number">2</span>,aux,key);</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        addReply(c, shared.cone);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则就设置一下过期时间，发送expire事件并返回</span></span><br><span class="line">        setExpire(c,c-&gt;db,key,when);</span><br><span class="line">        addReply(c,shared.cone);</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"expire"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否过期也很简单，因为expires里保存了具体的过期时间，那么对比一下就行了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; <span class="comment">//取出过期时间</span></span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> || <span class="comment">// 没找到就返回-1</span></span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然能在expires里找到这个key，那么理论上键空间里也应该有这个key</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de); <span class="comment">// 以有符号整数的形式取出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; <span class="comment">// 判断这个key是否过期</span></span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key); <span class="comment">// 具体过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 小于0表示永不过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// loading状态不做过期检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时间，具体为啥做判断我也不清楚</span></span><br><span class="line">    <span class="keyword">mstime_t</span> now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 键如果没过期就返回没过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 只有master节点能够认为过期的键已失效</span></span><br><span class="line"></span><br><span class="line">    server.stat_expiredkeys++; <span class="comment">// 统计过期键</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire); <span class="comment">// 向slave节点和AOF文件发送过期操作</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED, <span class="comment">// 发送一个事件</span></span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : <span class="comment">// 然后同步或异步的删除</span></span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过期数据删除策略"><a href="#过期数据删除策略" class="headerlink" title="过期数据删除策略"></a>过期数据删除策略</h2><p>《Redis设计与实现》里提到了三种删除策略：</p>
<ul>
<li>定时删除：由于我们知道什么时候过期，那么可以开启一个定时器，在对应时间唤醒一个删除操作</li>
<li>惰性删除：读到过期数据的时候再将其删除</li>
<li>定期删除：隔一段时间清理过期的数据</li>
</ul>
<p>显然第一种做法最精确，且能保证内存消耗最小，前提是需要创建和删除timer，这个timer的代价一般不会太小。第二种做法一方面会造成内存泄漏（过期数据不访问就不会被删除），另一方面会提高读写延时，因为删除一个复杂的对象还是很花时间的。</p>
<p>Redis做法是第三种，且理论上这个线程是可以侦测当前CPU是否空闲，从而决定删除频率。具体做法和redis的事件机制有关，之后再看看。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/10/28/redis-read3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/28/redis-read3/" class="post-title-link" itemprop="url">redis学习（3）对象</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-28 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-28T00:00:00+08:00">2019-10-28</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 14:31:14" itemprop="dateModified" datetime="2019-11-02T14:31:14+08:00">2019-11-02</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前提到，redis并没有把底层的数据结构暴露给用户，而是对用户提供string、list、set、zset、hash五种类型的object，底层采用之前提到的数据结构，它对用户理论上是透明的。这种分离机制的一个好处是可以根据具体场景进行优化，比如如果hash表非常小的时候，直接用ziplist保存键值对可能会比hashtable计算并查存会更高效，所用空间也更小。</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>redis使用对象来表示数据库中的键和值，每创建一个键值对时，redis会至少创建一个键对象和值对象，对象的基本定义如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 对外暴露的类型，包括string、list、set、zset、hash</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 具体编码，目前有11种</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">// LRU时间</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">// 具体数据</span></span><br><span class="line">&#125; robj; <span class="comment">// 总长度为16字节</span></span><br></pre></td></tr></table></figure>

<h3 id="string类型的编码转换"><a href="#string类型的编码转换" class="headerlink" title="string类型的编码转换"></a>string类型的编码转换</h3><p>redis用<code>int</code>、<code>embstr</code>或<code>raw</code>来实现string类型，<code>int</code>用来保存整数，且直接保存在<code>ptr</code>字段。<code>raw</code>即<code>sds</code>，而<code>embstr</code>稍微有点特殊。它主要用来存放短字符串，确切的说是字节数小于等于44的字符串（原来是39）。这是因为redis采用jemalloc内存分配器，这个分配器会分配8，16，32，64等字节的内存，因此一次申请64字节依次存放robj和sds，而由于robj占16字节，sdshdr8占3字节，<code>&#39;\0&#39;</code>占1字节，所以能最多能保存64-16-3-1=44字节（旧版的sds头占的空间更大一点，只留了39字节给实际数据）。以下是</p>
<p>redis保存浮点数时会先将其保存为字符串而非float/double，估计是因为精度；对浮点数的操作（比如<code>INCRBYFLOAT</code>）也是先转换为浮点数再保存为字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试编码一个string类型的object以节约空间</span></span><br><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要object的类型为string</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,o,o-&gt;type == OBJ_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是OBJ_ENCODING_EMBSTR类型或OBJ_ENCODING_RAW</span></span><br><span class="line">    <span class="keyword">if</span> (!sdsEncodedObject(o)) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数不能大于1，避免共享对象被修改</span></span><br><span class="line">     <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 尝试将string编码为long</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">         <span class="comment">// 如果能够编码为long，那么尝试用一个共享对象</span></span><br><span class="line">         <span class="comment">// redis提前预置了[0, 9999]之间的整数object作为共享对象</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">            !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">            value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">        &#123;</span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            incrRefCount(shared.integers[value]);</span><br><span class="line">            <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) &#123; <span class="comment">// 如果是raw类型，那么可以释放ptr指向的对象，直接修改指针的值即可</span></span><br><span class="line">                sdsfree(o-&gt;ptr);</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">                o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) &#123; <span class="comment">// 对于embstr，则需要减少原对象的引用次数，再创建一个新的</span></span><br><span class="line">                decrRefCount(o);</span><br><span class="line">                <span class="keyword">return</span> createStringObjectFromLongLongForValue(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123; <span class="comment">// 如果这个字符串比较小</span></span><br><span class="line">        robj *emb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) <span class="keyword">return</span> o; <span class="comment">// 并且不是embstr</span></span><br><span class="line">        emb = createEmbeddedStringObject(s,sdslen(s)); <span class="comment">// 那么就创建一个新的，并释放原来的</span></span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> emb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trimStringObjectIfNeeded(o); <span class="comment">// 如果实在不能压缩，那么尝试把这个字符串前后的空格回车之类的字符删掉</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list对象的编码转换"><a href="#list对象的编码转换" class="headerlink" title="list对象的编码转换"></a>list对象的编码转换</h3><p>较早版本的list会用<code>ziplist</code>或<code>linkedlist</code>来实现，但目前统一用<code>quicklist</code>，如何节省内存完全交给<code>quicklist</code>解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypePush</span><span class="params">(robj *subject, robj *value, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;</span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line">        <span class="keyword">size_t</span> len = sdslen(value-&gt;ptr);</span><br><span class="line">        quicklistPush(subject-&gt;ptr, value-&gt;ptr, len, pos);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash对象的编码转换"><a href="#hash对象的编码转换" class="headerlink" title="hash对象的编码转换"></a>hash对象的编码转换</h3><p>hash可以用<code>ziplist</code>或<code>hashtable</code>实现，使用<code>ziplist</code>实现时，只是将键值对顺次插入，然后所有对hash表的操作都可以转换为对列表的操作。</p>
<p>对于大于<code>hash-max-ziplist-entries</code>的<code>ziplist</code>，redis会尝试将其转换为<code>hashtable</code>，默认值是512；同样的，如果任意一个键或者值的长度大于<code>hash-max-ziplist-value</code>的<code>ziplist</code>也会自动转换，默认阈值是64。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeSet</span><span class="params">(robj *o, sds field, sds value, <span class="keyword">int</span> flags)</span> </span>&#123; <span class="comment">// 更新一个KV，flags是个操作标志，可以设置是否允许hash表使用传进来的key/value，或者复制一个新的</span></span><br><span class="line">    <span class="keyword">int</span> update = <span class="number">0</span>; <span class="comment">// 如果是新增一项则为0，更新为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123; <span class="comment">// 如果是ziplist</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD); <span class="comment">// 从头节点开始</span></span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fptr = ziplistFind(fptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field), <span class="number">1</span>); <span class="comment">// 顺序查找key</span></span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果找到了key</span></span><br><span class="line">                vptr = ziplistNext(zl, fptr); <span class="comment">// 找到值，也就是ziplist的下一项</span></span><br><span class="line">                serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">                update = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                zl = ziplistDelete(zl, &amp;vptr); <span class="comment">// 从ziplist里删掉这个值</span></span><br><span class="line"></span><br><span class="line">                zl = ziplistInsert(zl, vptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value, <span class="comment">// 然后把新值写进去</span></span><br><span class="line">                        sdslen(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">            <span class="comment">// 如果没找到，那么就把新的KV写到最后</span></span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value, sdslen(value),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;ptr = zl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果大于阈值，就进行类型转换</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 如果</span></span><br><span class="line">        dictEntry *de = dictFind(o-&gt;ptr,field); <span class="comment">// 查找对应entry</span></span><br><span class="line">        <span class="keyword">if</span> (de) &#123; <span class="comment">// 如果找到了</span></span><br><span class="line">            sdsfree(dictGetVal(de)); <span class="comment">// 就释放原来的值</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123; <span class="comment">// 如果允许直接用传进来的值</span></span><br><span class="line">                dictGetVal(de) = value; <span class="comment">// 就写进去</span></span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dictGetVal(de) = sdsdup(value); <span class="comment">// 否则复制一个新的</span></span><br><span class="line">            &#125;</span><br><span class="line">            update = <span class="number">1</span>; <span class="comment">// 表示是更新操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sds f,v;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD) &#123; <span class="comment">// 如果允许直接用传进来的值，就写进去</span></span><br><span class="line">                f = field;</span><br><span class="line">                field = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = sdsdup(field);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123; <span class="comment">// 同上</span></span><br><span class="line">                v = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            dictAdd(o-&gt;ptr,f,v); <span class="comment">// 把这个新的entry写进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free SDS strings we did not referenced elsewhere if the flags</span></span><br><span class="line"><span class="comment">     * want this function to be responsible. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD &amp;&amp; field) sdsfree(field); <span class="comment">// 如果是传进来用的key，并且没有用到，那么释放</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE &amp;&amp; value) sdsfree(value); <span class="comment">// 类似</span></span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set对象的编码转换"><a href="#set对象的编码转换" class="headerlink" title="set对象的编码转换"></a>set对象的编码转换</h3><p>set可以用<code>intset</code>或<code>hashtable</code>实现，如果是<code>hashtable</code>编码，则只是单纯的将值置为<code>NULL</code>；对于<code>intset</code>，则在非int对象被添加时，或者具体总数大于<code>set-max-intset-entries</code>的时候转换为<code>hashtable</code>，默认值是512。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// 如果是hashtable</span></span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>); <span class="comment">// 这个函数只是在key不存在的时候新建一个entry</span></span><br><span class="line">        <span class="keyword">if</span> (de) &#123; <span class="comment">// 如果新建了一个entry，需要写到hashtable里</span></span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123; <span class="comment">// 如果是intset</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123; <span class="comment">// 尝试将value编码为int</span></span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success); <span class="comment">// 尝试写入intset</span></span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries) <span class="comment">// 如果添加成功，但intset里包含的数量超过阈值</span></span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT); <span class="comment">// 那么尝试转换为hashtable</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT); <span class="comment">// 否则需要先转换为hashtable</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 再尝试把这个值写进去</span></span><br><span class="line">             <span class="comment">// 由于这个hashtable之前是个intset，而我们要插入的值一定不是个合法的int值，说明它一定不在原hashtable里</span></span><br><span class="line">             <span class="comment">// 所以可以直接调用dictAdd</span></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zset对象的编码转换"><a href="#zset对象的编码转换" class="headerlink" title="zset对象的编码转换"></a>zset对象的编码转换</h3><p>zset对象的底层可以是<code>ziplist</code>或<code>zset</code>。当创建有序集合时，总是先创建<code>zset</code>并添加进去，当entry总数不大于<code>zset-max-ziplist-entries</code>且总字节数不大于<code>zset-max-ziplist-value</code>时再转换为<code>ziplist</code>。类似的，如果元素太多，也会将<code>ziplist</code>扩展为<code>zset</code>，默认的<code>zset-max-ziplist-entries</code>为128，<code>zset-max-ziplist-value</code>为64。一个典型的插入流程如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetAdd</span><span class="params">(robj *zobj, <span class="keyword">double</span> score, sds ele, <span class="keyword">int</span> *flags, <span class="keyword">double</span> *newscore)</span> </span>&#123; <span class="comment">// 在有序集合里添加一项</span></span><br><span class="line">    <span class="keyword">int</span> incr = (*flags &amp; ZADD_INCR) != <span class="number">0</span>; <span class="comment">// 增加这一项的score</span></span><br><span class="line">    <span class="keyword">int</span> nx = (*flags &amp; ZADD_NX) != <span class="number">0</span>; <span class="comment">// 只有当对应元素不存在时才进行操作</span></span><br><span class="line">    <span class="keyword">int</span> xx = (*flags &amp; ZADD_XX) != <span class="number">0</span>; <span class="comment">// 只有当对应元素存在时进行操作</span></span><br><span class="line">    *flags = <span class="number">0</span>;<span class="comment">// 置为0</span></span><br><span class="line">    <span class="keyword">double</span> curscore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isnan(score)) &#123; <span class="comment">// 不允许假如值为NAN的元素</span></span><br><span class="line">        *flags = ZADD_NAN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123; <span class="comment">// 如果底层是ziplist</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123; <span class="comment">// 尝试找到这一项，由于ziplist非定长且只能从其中一个项跳到下一项，故采取顺序查找</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123; <span class="comment">// 找到了，但不允许修改，则返回</span></span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123; <span class="comment">// 如果要求增加score</span></span><br><span class="line">                score += curscore; <span class="comment">// 那么尝试增加</span></span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123; <span class="comment">// 确保新的score合法</span></span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score; <span class="comment">// 新的score写到返回值里</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123; <span class="comment">// 如果值发生了变化，那么需要把原来的项删了，再新加一项</span></span><br><span class="line">                zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score); <span class="comment">// 这个插入操作本质上是顺序查找，然后在指定位置先插入值，再插入score，且score需要编码为字符串</span></span><br><span class="line">                *flags |= ZADD_UPDATED; <span class="comment">// 标记为update</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123; <span class="comment">// 如果没找到，且允许在元素不存在时进行操作</span></span><br><span class="line">            zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score); <span class="comment">// 那么先插入</span></span><br><span class="line">            <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries || <span class="comment">// 然后判断entry是否过多</span></span><br><span class="line">                sdslen(ele) &gt; server.zset_max_ziplist_value) <span class="comment">// 或者这个元素太大</span></span><br><span class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST); <span class="comment">// 如果是的话就转换成跳表</span></span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score; <span class="comment">// 新的score写到返回值里</span></span><br><span class="line">            *flags |= ZADD_ADDED; <span class="comment">// 设置为add操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123; <span class="comment">// 如果底层是跳表</span></span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplistNode *znode;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = dictFind(zs-&gt;dict,ele); <span class="comment">// 那么先尝试在hash表里查有没有这一项</span></span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123; <span class="comment">// 如果有</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123; <span class="comment">// 且不允许操作</span></span><br><span class="line">                *flags |= ZADD_NOP; <span class="comment">// 就返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curscore = *(<span class="keyword">double</span>*)dictGetVal(de); <span class="comment">// 否则先查到score</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123; <span class="comment">// 增加score</span></span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123; <span class="comment">// 如果score发生了变化，需要修改跳表</span></span><br><span class="line">                znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score); <span class="comment">// 修改score，简单来说就是把原来的连接关系删了，重新调整一下</span></span><br><span class="line">                dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">// 再修改hashtable里的引用</span></span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123; <span class="comment">// 如果没找到，且允许增加</span></span><br><span class="line">            ele = sdsdup(ele); <span class="comment">// 复制一份</span></span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,ele); <span class="comment">// 插入到skiplist</span></span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK); <span class="comment">// 插入到hashtable</span></span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存回收和对象共享"><a href="#内存回收和对象共享" class="headerlink" title="内存回收和对象共享"></a>内存回收和对象共享</h2><p>由于redis的对象之间没有引用关系，因此简单的引用计数就可以判断一个object是否仍然被引用。这个东西比较像C++里的智能指针，且在引用计数被减为0的时候立刻释放内存。</p>
<p>引用计数可以很方便的实现共享对象。不过这个东西有点歧义，有时候共享对象也指redis启动时创建的一系列对象。如下所示，这些对象在创建的时候会把引用计数计为<code>OBJ_SHARED_REFCOUNT</code>，且在操作引用计数的时候会判断引用计数是否为这个特殊值，如果是的话则不进行任何操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sharedObjectsStruct</span> &#123;</span></span><br><span class="line">    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,</span><br><span class="line">    *colon, *nullbulk, *nullmultibulk, *queued,</span><br><span class="line">    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,</span><br><span class="line">    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,</span><br><span class="line">    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,</span><br><span class="line">    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,</span><br><span class="line">    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,</span><br><span class="line">    *rpop, *lpop, *lpush, *rpoplpush, *zpopmin, *zpopmax, *emptyscan,</span><br><span class="line">    *select[PROTO_SHARED_SELECT_CMDS],</span><br><span class="line">    *integers[OBJ_SHARED_INTEGERS],</span><br><span class="line">    *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], <span class="comment">/* "*&lt;value&gt;\r\n" */</span></span><br><span class="line">    *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  <span class="comment">/* "$&lt;value&gt;\r\n" */</span></span><br><span class="line">    sds minstring, maxstring;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a>数据淘汰机制</h2><p>作为缓存组件，redis不保证已保存的数据会一直保存下去，持久性应当由数据库来完成。这也意味着理论上redis可以在任意时刻废弃任意对象。当然一般来说还是在内存比较紧张的时候废弃对象，目前redis大致支持LRU、LFU、TTL算法，每个object的相关信息记录在<code>robj-&gt;lru</code>里。</p>
<h3 id="LRU（Least-Recently-Used）"><a href="#LRU（Least-Recently-Used）" class="headerlink" title="LRU（Least Recently Used）"></a>LRU（Least Recently Used）</h3><p>最近最旧未使用算法，即从当前时刻开始，优先淘汰最旧未使用的对象。</p>
<p>比较精准的LRU的做法是用hash表和双向链表来实现，使用的时候如果hash表里没有就在hash表里加一项，再把链表里的指针移动到队尾；废弃的时候从队首拿出来，并从hash表里删除。当然这么搞的话每次使用时都要更新两个数据结构，相对比较麻烦。</p>
<p>redis的做法就比较简单了：从目标集合里（可以是已过期数据集合，也可以是所有数据集合）随机找几个对象，按LRU算法删掉。无论使用哪种算法，redis都是先从一个object集合里随机挑几个对象，应用相应算法进行淘汰。随机算法也比较简单，就是随机选一些桶，把桶里的元素全返回，如果不够则继续。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123; <span class="comment">// 随机取一些数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tables; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stored = <span class="number">0</span>, maxsizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> maxsteps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) &lt; count) count = dictSize(d);</span><br><span class="line">    maxsteps = count*<span class="number">10</span>; <span class="comment">// 最多尝试count*10次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于redis是渐进式hash，需要考虑这方面问题</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">            _dictRehashStep(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tables = dictIsRehashing(d) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    maxsizemask = d-&gt;ht[<span class="number">0</span>].sizemask; <span class="comment">// 两个table中比较大的那个</span></span><br><span class="line">    <span class="keyword">if</span> (tables &gt; <span class="number">1</span> &amp;&amp; maxsizemask &lt; d-&gt;ht[<span class="number">1</span>].sizemask)</span><br><span class="line">        maxsizemask = d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = random() &amp; maxsizemask; <span class="comment">// 随机取一个值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> emptylen = <span class="number">0</span>; <span class="comment">// 当前一共遇到多少个空桶</span></span><br><span class="line">    <span class="keyword">while</span>(stored &lt; count &amp;&amp; maxsteps--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tables; j++) &#123;</span><br><span class="line">            <span class="comment">// rehash不变性使我们可以忽略一些桶</span></span><br><span class="line">            <span class="keyword">if</span> (tables == <span class="number">2</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; i &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= d-&gt;ht[<span class="number">1</span>].size)</span><br><span class="line">                    i = d-&gt;rehashidx;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= d-&gt;ht[j].size) <span class="keyword">continue</span>; <span class="comment">// 越界</span></span><br><span class="line">            dictEntry *he = d-&gt;ht[j].table[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Count contiguous empty buckets, and jump to other</span></span><br><span class="line"><span class="comment">             * locations if they reach 'count' (with a minimum of 5). */</span></span><br><span class="line">             <span class="comment">// 遇到一个空桶</span></span><br><span class="line">            <span class="keyword">if</span> (he == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                emptylen++;</span><br><span class="line">                <span class="keyword">if</span> (emptylen &gt;= <span class="number">5</span> &amp;&amp; emptylen &gt; count) &#123; <span class="comment">// 如果连续遇到5个以上空桶，且总数超过目标数</span></span><br><span class="line">                    i = random() &amp; maxsizemask; <span class="comment">// 那么重新选一个位置开始</span></span><br><span class="line">                    emptylen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                emptylen = <span class="number">0</span>; <span class="comment">// 否则清空</span></span><br><span class="line">                <span class="keyword">while</span> (he) &#123; <span class="comment">// 把这个桶里的object全返回出去</span></span><br><span class="line">                    *des = he;</span><br><span class="line">                    des++;</span><br><span class="line">                    he = he-&gt;next;</span><br><span class="line">                    stored++;</span><br><span class="line">                    <span class="keyword">if</span> (stored == count) <span class="keyword">return</span> stored;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>) &amp; maxsizemask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// LRU时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123; <span class="comment">// 时钟分辨率，要求服务器的频率高于10000，可以设置</span></span><br><span class="line">        atomicGet(server.lruclock,lruclock); <span class="comment">// redis自己维护的一个始终</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock(); <span class="comment">// 系统调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lruclock = LRU_CLOCK(); <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">if</span> (lruclock &gt;= o-&gt;lru) &#123; <span class="comment">// 如果当前事件比该对象的lru时间大</span></span><br><span class="line">        <span class="keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION; <span class="comment">// 那么相减就好</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) * <span class="comment">// 否则说明过了一轮，需要再加上LRU_CLOCK_MAX</span></span><br><span class="line">                    LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LFU（Least-Frequently-Used）"><a href="#LFU（Least-Frequently-Used）" class="headerlink" title="LFU（Least Frequently Used）"></a>LFU（Least Frequently Used）</h3><p>最近最少使用算法，即在最近一段时间内，优先淘汰使用频率最低的对象。计算频次的做法也比较好理解：每过一定时间减少固定次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUGetTimeInMinutes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// LRU算法下的当前时间</span></span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123; <span class="comment">// 根据object高16位计算已经过了多久</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt; <span class="comment">// 和上面那个类似，计算的时候需要取模</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123; <span class="comment">// 降低访问频次并返回频次</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">// 高16位用来表示最近降低时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">// 低8位来表示访问次数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : <span class="number">0</span>; <span class="comment">// 衰减，假设距离上次更新过了N个周期，那么就减去N*m个统计次数</span></span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter; <span class="comment">// 注意，最后用的时候使用255-counter作为idle（空闲）值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123; <span class="comment">// 增加计数器函数，估计是考虑到counter取值范围很小，所以增加计数难度</span></span><br><span class="line">      <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">      <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">      <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL; <span class="comment">// 注意初始会给一个object设置访问频次为5，避免一个object被创建后立刻删除</span></span><br><span class="line">      <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>); </span><br><span class="line">      <span class="keyword">if</span> (r &lt; p) counter++; <span class="comment">// 看看有没有通过测试</span></span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="TTL（Time-to-Live）"><a href="#TTL（Time-to-Live）" class="headerlink" title="TTL（Time to Live）"></a>TTL（Time to Live）</h3><p>剩余生存时间，即淘汰超过存活时间的对象。这个算法就比较简单了：<code>idle = ULLONG_MAX - (long)dictGetVal(de);</code>，其中de指向expire字典里的entry，其value是以long形式存的过期时间限制。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/10/08/docker-learn1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/08/docker-learn1/" class="post-title-link" itemprop="url">docker学习（1）</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-08T00:00:00+08:00">2019-10-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-25 16:01:36" itemprop="dateModified" datetime="2019-10-25T16:01:36+08:00">2019-10-25</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近需要把某个服务容器化后搞到K8S上，提高集群利用率，因此学习一下docker和K8S</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>执行<code>wget -qO- https://get.docker.com/ | sh</code>，输入密码即可。之后可能会报个权限错<code>Got permission denied while trying to connect to the Docker daemon socket at</code>，执行<code>sudo usermod -aG docker maxiaoxin &amp;&amp; newgrp - docker</code>即可。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>docker的基本架构如下图所示，从这个意义上讲，docker更像个隔离机制而非虚拟机，毕竟虚拟机是可以允许比如在linux上跑一个windows虚拟机的，而docker不能直接做到这一点。</p>
<p>而且和虚拟机不同的是，严格来说虚拟机是模拟了一个完整的主机，至少是一个完整的操作系统，并且理论上应该可以打一个包含所有运行状态的snapshot（至少包括CPU状态、内存状态和文件状态）。而docker的镜像只包含文件状态，并且非常不建议一个container起多个进程。</p>
<p><img src="/images/container-what-is-container.png" alt="docker基本架构"></p>
<ul>
<li>容器（container）：独立运行的一个或一组应用，以及它们的运行态环境。</li>
<li>镜像（image）：运行容器的所有基础设施，包括代码、运行库、依赖和其他文件系统的对象（类似snapshot）</li>
<li>仓库（repository）：类似git或maven中的仓库，支持版本控制</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>登录：<code>docker login ${uri}</code></li>
<li>从仓库pull一个镜像：<code>docker pull ${host}/${image_name}:${version}</code></li>
<li>上传镜像：<code>docker push ${user_name}/${image_name}</code></li>
<li>列出本地镜像：<code>docker images</code></li>
<li>删除镜像：<code>docker rmi ${image_id}</code></li>
<li>导出镜像文件到本地：<code>docker save -o ${file_name} ${image_name}:${tag}</code></li>
<li>导入镜像文件：<code>docker load --input ${file_name}</code></li>
<li>对容器进行快照，生成image：<code>docker commit ${options} ${container_ID} ${image_name}:${tag}</code>，很像git的commit</li>
<li>使用镜像创建一个容器：<code>docker create ${image_name}:${version}</code></li>
<li>创建并运行一个容器：<code>docker run ${options} ${image_name}:${version} ${args}</code>，其中<code>-i</code>表示打开容器的标准输入，<code>-t</code>告诉docker为容器建立一个命令行终端，<code>-d</code>表示使容器在后台运行，<code>-c</code>可以调整容器的CPU优先级，<code>--restart=always</code>表示无论容器返回码是什么都立刻重启，<code>--restart=on-failure:5</code>表示当返回码非0时重启，且可选择重启次数</li>
<li>启动已停止的容器：<code>docker start ${container_ID}</code></li>
<li>终止/强制停止容器：<code>docker stop ${container_ID}</code>，<code>docker kill ${container_ID}</code></li>
<li>删除一个已停止的容器：<code>docker rm ${container_ID}</code></li>
<li>搜索镜像：<code>docker search ${key_word}</code></li>
<li>查看容器：<code>docker ps ${options}</code>，其中不加任何参数的话是查看运行中的容器，<code>-a</code>查看所有容器（包括已停止的），<code>-l</code>查看最新创建的容器，<code>-n</code>是个数，<code>-q</code>是只列出容器ID</li>
</ul>
<p>当然不是所有情况都适合用commit命令，也可以用<code>docker build</code>来创建一个新的镜像，需要先创建一个Dockerfile，比如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line">FROM centos:6.8</span><br><span class="line">MAINTAINER MXX</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure>

<p>其中<code>FROM</code>一定要写，表示继承自哪个image。如果是空的话可以写为<code>FROM scratch</code>，但一般不太会这么写；<code>MAINTAINER</code>是作者名；<code>RUN</code>代表要执行的命令。</p>
<p>另外还有些比较常见的命令，比如</p>
<ul>
<li><code>ADD/COPY</code>用来复制本地文件到镜像</li>
<li><code>EXPOSE</code>命令向外部开放端口，但只是个声明</li>
<li><code>CMD/ENTRYPOINT</code>命令用来描述容器启动后运行的程序等</li>
<li><code>WORKDIR</code>工作目录，如果没有会创建</li>
<li><code>USER</code>当前用户，值得一提的是我在用centos的时候，如果不加上<code>USER root</code>的话，某些情况会报权限错</li>
</ul>
<p>然后执行<code>docker build . -t ${image_name}:${tag}</code>就可以生成了。</p>
<p>值得一提的是docker有个概念layer，意指dockerfile的每条指令，或者每个commit都会产生一个“层”（类似git里一个分支上有多个commit）。之所以有这个概念，是因为docker的文件系统采用了UnionFS，以减少修改文件带来的额外存储开销，也就是只存储差分信息。假如差分存储的代价比较大（比如差分的单位是文件，假如某个1GB的文件只修改了1个byte，那么也会额外产生1GB的信息），那么层越多，镜像越大——当然层越多，不同镜像能共享的文件也就越多，这个也需要取舍。</p>
<p>一般来说启动的还是一个一直运行的服务，而如果依赖比较小的话，可以不用<code>centos</code>这样“重”的基础镜像，参考<a href="https://zhuanlan.zhihu.com/p/54640767" target="_blank" rel="noopener">最小化 Java 镜像的常用技巧</a>。不过比较坑的一点是<code>alpine</code>用的是<code>musl</code>而不是<code>glibc</code>，这将导致某些系统调用不兼容，比如<code>qsort_r</code>。当时我差点改<code>musl</code>源代码了，后来上网找了一个手写的块排加强版代码直接用。</p>
<h2 id="kubernetes相关"><a href="#kubernetes相关" class="headerlink" title="kubernetes相关"></a>kubernetes相关</h2><p>docker的任务是创建镜像，而如果调度计算资源来运行镜像需要靠kubernetes（k8s）。客户端怎么下载和配置就忽略过了，假设我们已经搞了一个镜像<code>hello/world</code>，公司的registry是<code>foo.bar.net</code>，那么常见的命令包括：</p>
<ul>
<li>创建镜像：<code>docker build . -t foo.bar.net/hello/world</code>，注意这里要写全，最好把<code>tag</code>也写上</li>
<li>登录：<code>docker login foo.bar.net</code></li>
<li>上传：<code>docker push foo.bar.net/hello/world</code></li>
<li>创建pod：<code>kubectl create -f helloworld-deployment.yaml</code></li>
<li>创建service：<code>kubectl create -f helloworld_service.yaml</code></li>
<li>创建ingress：<code>kubectl create -f helloworld-ingress.yaml</code></li>
<li>查看状态：<code>kubectl get pod -o wide|grep hello-world</code></li>
</ul>
<p>核心在于pod、service、ingress这三个概念，对应的三个配置文件分别是<code>helloworld-deployment.yaml</code>、<code>helloworld_service.yaml</code>、<code>helloworld-ingress.yaml</code>。其中Pod 是一组紧密关联的容器集合，Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现，而Ingress可以简单的理解成k8s内部的nginx, 和service配合，用作负载均衡器。具体示例可以参考<a href="https://www.mirantis.com/blog/introduction-to-yaml-creating-a-kubernetes-deployment/" target="_blank" rel="noopener">Introduction to YAML: Creating a Kubernetes deployment</a>，总之是一大堆和资源调度相关的配置。</p>
<p>刚才碰到的一个问题是，上传的文件大于1MB会报错413，那么需要在ingress的配置里加入<code>metadata:annotations:nginx.ingress.kubernetes.io/proxy-body-size: &quot;25m&quot;</code></p>
<p>有时候也需要rewrite url，需要加上<code>nginx.ingress.kubernetes.io/rewrite-target</code>，具体怎么用参考<a href="https://kubernetes.github.io/ingress-nginx/examples/rewrite/" target="_blank" rel="noopener">Rewrite</a></p>
<h3 id="配置和挂载"><a href="#配置和挂载" class="headerlink" title="配置和挂载"></a>配置和挂载</h3><p>一般来说还是应该将配置文件和docker镜像分开，在运行的时候从某个地方读，这里我常用的有三种：configMap, secrets和emptyDir。</p>
<ul>
<li>emptyDir主要用来在pod重启时不丢失这个路径下的信息，比如某个服务可能挂了，被K8S重新拉起，假如没有一个地方存储日志，就不能确定挂掉的原因了。但如果pod被删掉了，那么emptyDir也会自动删掉。</li>
<li>configMap主要存放配置信息，一种用法是把所有配置信息的键值对直接写进这个文件，然后通过环境变量传进容器。另一种是通过类似<code>kubectl create configmap ${config_name} --from-file=${dir_path}</code>创建，然后通过volumes的方式挂载到某个路径下，到时候去这里读取。但如果用yaml的方式创建/更新的话，无法引用外部文件，必须写在一个yaml配置文件里。如果是挂载目录的方式的话，至少默认这个目录是只读的。</li>
<li>secrets和configMap很像，不过主要用来存储敏感信息，比如用户名密码之类的。但一般不会在配置文件里写明文，而是写base64编码后的信息。比如要把一个keytab写进去，那么就可以用<code>cat ${file_name} | base64</code>得到其编码，再写到yaml配置文件里。至于secrets的安全性就不清楚了。类似的，默认挂载后的目录是只读的。</li>
</ul>
<p>我试了一下，采用挂载的方式，如果更新configMap和secrets后，pod上对应目录下的文件也会更新。至于环境变量是容器运行的时候写的，当然不能更新了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/10/08/redis-read2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/08/redis-read2/" class="post-title-link" itemprop="url">redis学习（2） 压缩列表、快速列表、整数集合、跳表</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-08T00:00:00+08:00">2019-10-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-30 19:19:31" itemprop="dateModified" datetime="2019-10-30T19:19:31+08:00">2019-10-30</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="压缩列表（ziplist）"><a href="#压缩列表（ziplist）" class="headerlink" title="压缩列表（ziplist）"></a>压缩列表（ziplist）</h2><p>当前版本的redis已经不使用ziplist作为列表的底层实现了，取而代之的是quicklist，但quicklist底层还是依赖ziplist。此外，hash表的底层实现也可以是ziplist，在键值较短且数量比较少的情况下会使用ziplist而非hashtable来实现hash表。</p>
<p>显然，使用ziplist的初衷是节约内存，主要是两方面：尽量使用较小的数据类型保存较小的整数，以及取消指针。既然取消了指针，而每个节点大小都可能不同，因此ziplist采用了变长数组作为实现。数组带来的一个好处是缓存友好，而朴素的链表容易产生大量不可控的零散碎片。Ziplist的大致结构类似<code>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</code>，相关定义如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度(byte)</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4</td>
<td>记录整个ziplist占用的字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4</td>
<td>记录尾节点距离起始地址有多少字节，可以用以直接计算得到尾节点地址</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2</td>
<td>记录了节点数。如果这个值等于UINT16_MAX时，需要遍历整个ziplist才能获得总节点数</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>具体保存数据的节点</td>
</tr>
<tr>
<td>zlent</td>
<td>uint8_t</td>
<td>1</td>
<td>固定为0xff，表示ziplist结尾</td>
</tr>
</tbody></table>
<p>Redis没有对ziplist结构体作出定义，仅将用一个<code>char*</code>指针指代对应的ziplist，相关操作的定义和实现在<code>ziplist.h</code>和<code>ziplist.c</code>，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_END 255</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上初始化就是给头尾相关字段赋值，一个初始化后的空列表为<code>0b000000 0a000000 0000 ff</code>，和上面的说明可以匹配的上。</p>
<p>所以核心还是<code>entry</code>的定义，ziplist的每个entry可以是一个字节数组或一个整数值，基本上每个entry都是类似<code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code>这样的结构，而对于某些entry，比如小整数，就没有<code>&lt;entry-data&gt;</code>这部分。</p>
<p><code>&lt;prevlen&gt;</code>表示之前那个entry的长度，但只能是1字节或5字节，取决于之前那个entry的长度：如果小于等于0xfe则采用1字节，否则需要置为0xfe，后4字节作为一个整数表明其长度（要说为啥不进一步细分，可能是因为太长的entry出现频率低吧）。显然，有<code>prevlen</code>后可以很容易的从后向前遍历节点，而从前向后遍历则需要解析<code>&lt;encoding&gt;</code>字段。</p>
<p><code>&lt;encoding&gt;</code>字段用来标明节点的类型和长度，根据类型及长度，可以分为以下几类：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度(byte)</th>
<th>content属性保存的值</th>
</tr>
</thead>
<tbody><tr>
<td>00pppppp</td>
<td>1</td>
<td>长度&lt;=0x3f的字节数组</td>
</tr>
<tr>
<td>01pppppp qqqqqqqq</td>
<td>2</td>
<td>长度&lt;=0x3fff的字节数组</td>
</tr>
<tr>
<td>10000000 qqqqqqqq rrrrrrrr ssssssss tttttttt</td>
<td>5</td>
<td>长度&gt;0x3fff的字节数组，这里的第一个字节前2位必须为10，后6位未定义；之后的4个字节作为整数保存字节数组长度</td>
</tr>
<tr>
<td>11000000</td>
<td>1</td>
<td>int16_t，2字节</td>
</tr>
<tr>
<td>11010000</td>
<td>1</td>
<td>int32_t，4字节</td>
</tr>
<tr>
<td>11100000</td>
<td>1</td>
<td>int64_t，8字节</td>
</tr>
<tr>
<td>11110000</td>
<td>1</td>
<td>24位有符号整数，3字节</td>
</tr>
<tr>
<td>11111110</td>
<td>1</td>
<td>8位有符号整数，1字节</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1</td>
<td>0-12之间的小整数，这里的xxxx介于0001和1101之间，由于不可以使用0000和1110、1111，所以只能代表0-12，且用的时候需要减一</td>
</tr>
<tr>
<td>11111111</td>
<td>1</td>
<td>特殊entry，表示结尾</td>
</tr>
</tbody></table>
<p>由于不同类型的encoding的第一个字节一定不同，因此仅根据第一个字节就可以判断enty的类型。</p>
<p>ziplist由于涉及压缩（不是值LZF之类的压缩算法），代码多且复杂，故只贴出插入节点相关的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>;</span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入时需要获得两个信息：插入位置，和前一个entry的length</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123; <span class="comment">// 检查是否在队尾</span></span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); <span class="comment">// 如果不在，则解码前一个entry的长度和长度段的大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl); <span class="comment">// 尝试跳到队尾的entry</span></span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123; <span class="comment">// 如果队尾不为ZIP_END，说明队伍非空</span></span><br><span class="line">            prevlen = zipRawEntryLength(ptail); <span class="comment">// 尝试解码最后一个entry的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试压缩，包括两种情况：小整数，或者字符串代表了一个long long 可以表示的整数，比如"-987654321"</span></span><br><span class="line">    <span class="comment">// 从而确定压缩后entry的长度</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        reqlen = zipIntSize(encoding); <span class="comment">// 可以根据encoding确定长度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reqlen = slen; <span class="comment">// 否则就是字符串长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen); <span class="comment">// 加上存储prevlen需要的长度，传入NULL表示只计算长度而不写入</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen); <span class="comment">// 确定encoding字段的长度，传入NULL表示只计算长度而不写入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不在队尾插入，那么需要保证下一个entry的prevlen字段足够长，以保存本entry的长度</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>; <span class="comment">// 计算所需长度和下一个entry的prevlen字段的长度之差</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123; <span class="comment">// 如果本来下一个entry的prevlen字段长为5字节，而reqlen又很短的话，需要修改相关偏移量</span></span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的ziplist长度，并realloc</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果非队尾插入，则需要移动相关内容并处理一些细节</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);  <span class="comment">// 移动相关内容</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen); <span class="comment">// 调整下一个entry的prevlen字段</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen); <span class="comment">// 修改整个列表的tail偏移量</span></span><br><span class="line"></span><br><span class="line">        zipEntry(p+reqlen, &amp;tail); <span class="comment">// 解码最后一个entry</span></span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123; <span class="comment">// 如果对不上ZIP_END，需要做一些特殊处理</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =                                           <span class="comment">// 至于为啥有可能对不上，官方说和nextdiff有关。。。反正我没想明白</span></span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则直接修改即可</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果nextdiff不为0，说明有可能调整下一个entry的长度，进而影响下下个entry的prevlen字段</span></span><br><span class="line">     <span class="comment">// 最坏情况需要把所有entry都调整并移动一遍</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要写的内容写进去</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算调整entry总量</span></span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实本质上和数组扩容类似，但由于entry之间有一定关联，需要注意的细节很多，所以代码很长</p>
<h2 id="快速列表（quicklist）"><a href="#快速列表（quicklist）" class="headerlink" title="快速列表（quicklist）"></a>快速列表（quicklist）</h2><p>当前版本的redis基本只使用quicklist作为列表的底层实现，之前采用双向链表和ziplist实现，并且在一定条件下会将ziplist转换为双向链表，而自然也可以想到将ziplist用链表的方式连接起来获得一个折中的做法，提高内存利用率和效率，其定义在quicklist.h中，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl; <span class="comment">// 指向具体数据的指针，可以是ziplist，也可以是压缩后的数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">// ziplist的字节数，无论是否压缩，都表示未压缩前的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">// ziplist中的entry数。这里的冒号是C的一个语法，表示占16位而非字节，下同</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">// 压缩方式，1表示不压缩，2表示使用LZF算法</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">// zl指向的数据结构，目前取值只能是2，表示是ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">// 当前ziplist是否已被解压</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">// 测试用</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">// 保留字节</span></span><br><span class="line">&#125; quicklistNode; <span class="comment">// 强制对齐，共32字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">// 压缩后的字节数</span></span><br><span class="line">    <span class="keyword">char</span> compressed[]; <span class="comment">// 压缩后的数据</span></span><br><span class="line">&#125; quicklistLZF; <span class="comment">// LZF压缩节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head; <span class="comment">// 头节点</span></span><br><span class="line">    quicklistNode *tail; <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count; <span class="comment">// 总entry数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">// 一共有多少个quicklistNode</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>; <span class="comment">// 一个参数，用来某个ziplist节点能够容纳多少数据项，默认是-2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">// 压缩深度，为正时表示启用压缩，当quicklistNode总数大于等于quicklist-&gt;compress*2时开始压缩</span></span><br><span class="line">&#125; quicklist; <span class="comment">// 共40字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist; <span class="comment">// quicklist指针</span></span><br><span class="line">    quicklistNode *current; <span class="comment">// 当前的quicklistNode节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi; <span class="comment">// 指向ziplist中某个entry的指针</span></span><br><span class="line">    <span class="keyword">long</span> offset; <span class="comment">// ziplist中的偏移，如果zi为空，则使用offset</span></span><br><span class="line">    <span class="keyword">int</span> direction; <span class="comment">// 方向</span></span><br><span class="line">&#125; quicklistIter; <span class="comment">// quicklist的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist; <span class="comment">// quicklist指针</span></span><br><span class="line">    quicklistNode *node; <span class="comment">// 指向的节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi; <span class="comment">// 指向的ziplist中的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value; <span class="comment">// 具体的值，如果是字符串</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval; <span class="comment">// 具体的值，如果是整数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">// 当前ziplist的大小</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">// ziplist中的偏移</span></span><br><span class="line">&#125; quicklistEntry; <span class="comment">// quicklist中的某个entry</span></span><br></pre></td></tr></table></figure>

<p>其中比较重要的参数是quicklist中的fill和compress，前者取值为正时代表ziplist内部的节点数量，最大为0xFFFF，为负时只能取值-1～-5，分别代表每个ziplist节点的字节数不能超过4kb、8kb、16kb、32kb、64kb。后者表示压缩因子，在LZF算法中取值为0～10。由于头尾节点使用比较频繁，因此头尾节点永远不会被压缩。</p>
<p>由于涉及ziplist和压缩，quicklist的读写操作都比较麻烦，以下是头部插入的代码，话说我还是不太明白为什么插入时会解压缩途经节点。。。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x) __builtin_expect(!!(x), 1) <span class="comment">// 这是GCC提供的一个特殊指令，主要用来优化cpu的分支预测，这条语句告诉编译器x为真的可能像很大(unlikely类似)，因此如果将这部分语句放到判断语句后，可以降低cpu流水线被破坏的几率</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0) <span class="comment">// 但从外部看，可以认为if (likely(x))&#123;&#125; 等价于if(x)&#125;&#123;&#125;，</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> optimization_level[] = &#123;<span class="number">4096</span>, <span class="number">8192</span>, <span class="number">16384</span>, <span class="number">32768</span>, <span class="number">65536</span>&#125;; <span class="comment">// fill为负时的限制，4kb~64kb</span></span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span></span><br><span class="line">_quicklistNodeSizeMeetsOptimizationRequirement(<span class="keyword">const</span> <span class="keyword">size_t</span> sz, <span class="comment">// 校验fill为负时是否允许继续在当前ziplist插入</span></span><br><span class="line">                                               <span class="keyword">const</span> <span class="keyword">int</span> fill) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fill &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = (-fill) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; (<span class="keyword">sizeof</span>(optimization_level) / <span class="keyword">sizeof</span>(*optimization_level))) &#123; <span class="comment">// 数组越界检测</span></span><br><span class="line">        <span class="keyword">if</span> (sz &lt;= optimization_level[offset]) &#123; <span class="comment">// 是否超过限制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node, <span class="comment">// 判断这个节点是否能够插入</span></span><br><span class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ziplist_overhead;</span><br><span class="line">    <span class="comment">// 之前提到，ziplist中插入的节点需要保存前一个节点的size，所以这里算的时候要算上这部分大小</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)</span><br><span class="line">        ziplist_overhead = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)</span><br><span class="line">        ziplist_overhead += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>))</span><br><span class="line">        ziplist_overhead += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead; <span class="comment">// 新节点的大小</span></span><br><span class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill))) <span class="comment">// 如果fill为负且没超过ziplist单节点限制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz)) <span class="comment">// 每一项数据最大字节数限制，redis写死是8192</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill) <span class="comment">// 如果当前节点的项目数小于fill</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123; <span class="comment">// 原始数据，未压缩</span></span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely( <span class="comment">// 如果允许插入新节点</span></span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123; <span class="comment">// 假如每一项都比较小，那么一般来说还是能成功的</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD); <span class="comment">// 在这个ziplist里插入数据</span></span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head); <span class="comment">// 更新这个节点的大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode(); <span class="comment">// 否则创建一个新节点</span></span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD); <span class="comment">// 插入数据</span></span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node); <span class="comment">// 并更新quicklistNode的数据</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node); <span class="comment">// quicklistNode的插入操作，这个操作可能会导致压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">void</span> __quicklistCompress(<span class="keyword">const</span> quicklist *quicklist, <span class="comment">// 节点压缩</span></span><br><span class="line">                                      quicklistNode *node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!quicklistAllowsCompression(quicklist) || <span class="comment">// 当quicklistNode总数大于等于quicklist-&gt;compress*2时开始压缩</span></span><br><span class="line">        quicklist-&gt;len &lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(quicklist-&gt;compress * <span class="number">2</span>)) <span class="comment">// redis假设头尾节点操作频繁，如果链表数太少，会导致频繁的压缩/解压缩，因此当节点较少的时候最好不压缩</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterate until we reach compress depth for both sides of the list.a</span></span><br><span class="line"><span class="comment">     * Note: because we do length checks at the *top* of this function,</span></span><br><span class="line"><span class="comment">     *       we can skip explicit null checks below. Everything exists. */</span></span><br><span class="line">    quicklistNode *forward = quicklist-&gt;head;</span><br><span class="line">    quicklistNode *reverse = quicklist-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里同时从头指针和尾指针开始向中间走，直至相遇</span></span><br><span class="line">    <span class="comment">// 从而计算得到当前链表的深度</span></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> in_depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (depth++ &lt; quicklist-&gt;compress) &#123;</span><br><span class="line">        quicklistDecompressNode(forward); <span class="comment">// 没懂这里为什么要解压缩途经节点</span></span><br><span class="line">        quicklistDecompressNode(reverse); <span class="comment">// 至少当前函数内没有用到途经节点的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forward == node || reverse == node)</span><br><span class="line">            in_depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forward == reverse) <span class="comment">// 如果没找到当前节点，则返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        forward = forward-&gt;next;</span><br><span class="line">        reverse = reverse-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_depth) <span class="comment">// 如果足够深，则尝试压缩当前节点</span></span><br><span class="line">        quicklistCompressNode(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        quicklistCompressNode(forward); <span class="comment">// 重新压缩</span></span><br><span class="line">        quicklistCompressNode(reverse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数集合（intset）"><a href="#整数集合（intset）" class="headerlink" title="整数集合（intset）"></a>整数集合（intset）</h2><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，且数量不多时，会采用整数集合作为集合键的底层实现。intset被定义在<code>intset.h</code>中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 编码方式，取值为INTSET_ENC_INT64、INTSET_ENC_INT32和INTSET_ENC_INT16</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;    <span class="comment">// contents的长度</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];  <span class="comment">// 实际内容，从小到大排列的整数，且不重复</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code>类型被声明为<code>int8_t</code>，但如何解读取决于<code>encoding</code>属性，简单来说根据<code>encoding</code>来将<code>contents</code>作为<code>int16_t[]</code>、<code>int32[]</code>、<code>int64[]</code>来处理。</p>
<p>一个比较麻烦的地方在于如果新插入的元素比当前所有的元素占用的空间大（比如把int8_t替换为int16_t），那么redis的做法是将原数组所有元素类型升级为和新元素一样大，这个操作被称为升级（upgrade），估计是因为这么搞比较简单，大概也是图省事，intset不支持降级。其他基本上增、删、改、（二分）查等一系列操作和普通的有序数组没什么区别，这里就略过了。</p>
<h2 id="有序集合-跳表（skiplist）"><a href="#有序集合-跳表（skiplist）" class="headerlink" title="有序集合/跳表（skiplist）"></a>有序集合/跳表（skiplist）</h2><p>redis采用跳表作为底层数据结构来实现有序集合，基本原理如下图，简单来说最底层是一串有序链表，然后按层数加索引。每个索引节点类似B+树，将所辖区间分成若干份，查找的时候根据要查找的值选择下层节点。</p>
<p>值得注意的是有序集合<code>zset</code>元素的唯一性由<code>dict</code>保证，<code>zskiplist</code>只保证按score有序排列</p>
<p><img src="/images/Skip_list_add_element-en.gif" alt="跳表原理"></p>
<p>redis中相关结构体定义在<code>server.h</code>中，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;              <span class="comment">// 具体的对象，默认字节流</span></span><br><span class="line">    <span class="keyword">double</span> score; <span class="comment">// 节点根据score排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>  <span class="comment">// 上一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span>                        <span class="comment">// 层级</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 同层级下一个的指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;                     <span class="comment">// 跨度</span></span><br><span class="line">    &#125; level[];                                                  <span class="comment">// 可变层级</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>  <span class="comment">// 头节点和尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;                           <span class="comment">// 总大小</span></span><br><span class="line">    <span class="keyword">int</span> level;                                                      <span class="comment">// 最高层高</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span> <span class="comment">// 有序集合，包含一个字典和一个跳表</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> min, max; <span class="comment">// 范围</span></span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">// 是否包含最大最小值</span></span><br><span class="line">&#125; zrangespec;</span><br></pre></td></tr></table></figure>

<p>可以看到，有序集合中，集合（不重复）是由<code>dict</code>实现的，而有序是由<code>zskiplist</code>实现的。一个比较奇葩的地方在于redis使用double来作为排序依据，而至少我没看到redis对score做了哪些特殊处理，甚至直接用<code>==</code>来比较两个double类型的参数。所以个人感觉以单score而非range的操作可能都会出问题，相同score的排序可能也有问题，但这里暂且不谈。其初始化流程如下，核心在于header节点的层级需要设为<code>ZSKIPLIST_MAXLEVEL</code>，以便可以直接从header节点开始能查找到任意节点。其实按说应该将header的score设置为<code>-MAX_DOUBLE</code>之类的值，但redis后面比较的时候并没有用到header的score，所以其实无所谓。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找流程很容易理解，按level从高向低查，然后从左向右查。假设要查找的score为s<sub>target</sub>，当前节点为A，正在查找第k level，下一个节点是B，那么</p>
<ol>
<li>如果当前节点已经查到目标score，则直接返回</li>
<li>如果s<sub>B</sub>&lt;s<sub>target</sub>，则移动到B，转1</li>
<li>如果level已经是0（走到最下层）则表明查找失败</li>
<li>令level-=1，转2</li>
</ol>
<p>严格来说redis排序是先按score排序，如果score相同，则按元素的值<code>ele</code>排序。由于元素是唯一的，所以skiplist一定是单调递增的。</p>
<p>可能是因为double精度的问题，或者同一个score可以有多个元素，redis不能直接根据score获得某个值，只能按查找range，其实流程也差不多。不过跳表的一个好处是可以在查找时计算出目标score的rank（在skiplist中的顺位），因为每个节点保存了<code>span</code>（区间内元素数量），那么向右走的时候累计<code>span</code>就可以获得rank</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 向下走</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; <span class="comment">// 如果能向右走</span></span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score || <span class="comment">// 右边的节点比当前节点score小</span></span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp; <span class="comment">// 或者相等，但ele值比当前目标值小或相等</span></span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span; <span class="comment">// 累计当前节点当前层的span</span></span><br><span class="line">            x = x-&gt;level[i].forward; <span class="comment">// 向右走</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点可能已经找到了，那么就直接返回</span></span><br><span class="line">        <span class="comment">// 但由于header的ele可以为Null，且header实际是无效的，所以还是要检查一下是否是x-&gt;ele是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是插入节点，首先查找到目标位置，然后增加一个节点，此节点的level是随机出来的，创建出来后和前后节点连接起来，并更新相关的span值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// 随机层级</span></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>)) <span class="comment">// 取一个0~0xFFFF之间的随机数，和一个常数（这里是0.25*0xFFFF）比，如果测试通过就+1</span></span><br><span class="line">        level += <span class="number">1</span>; <span class="comment">// 合理性且不论，但基本上层级越高概率越低</span></span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; <span class="comment">// 然后取不大于最高level的返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;  <span class="comment">// 要更新的所有节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];  <span class="comment">// rank排行，表示这个节点在有序集合中的顺序</span></span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;  <span class="comment">// 第i层的rank</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x; <span class="comment">// 意味着我们的新节点在i层的后继节点是update[i]，并且一定会更新update[i].span</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    level = zslRandomLevel(); <span class="comment">// 随机拿到一个层级</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123; <span class="comment">// 如果刚好比已知的层级都高，那么需要更新header节点</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length; <span class="comment">// 注意，这个时候还没有插入新节点，所以这些层的span是所有节点数</span></span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    x = zslCreateNode(level,score,ele); <span class="comment">// 创建一个新节点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward; <span class="comment">// 连接相同层级上的链表</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x; <span class="comment">// 其实就是链表插入操作</span></span><br><span class="line"></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]); <span class="comment">// 调整span信息</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>; <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123; <span class="comment">// 加上新节点带来的span</span></span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 设置其他信息</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/29/redis-read1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/29/redis-read1/" class="post-title-link" itemprop="url">redis学习（1） 简单动态字符串、链表和字典</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-29 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-29T00:00:00+08:00">2019-09-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-28 20:57:30" itemprop="dateModified" datetime="2019-10-28T20:57:30+08:00">2019-10-28</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>还是对着《Redis设计与实现》看，不过由于redis源码比较短，可以对比着看源代码。</p>
<p>Redis源码可以在<a href="https://redis.io/download" target="_blank" rel="noopener">官网</a>找，目前最新的stable版是5.0.5。不过如果是在Clion里看的话最好还是搞成cmake工程比较方便，可以参考<a href="https://github.com/Nov11/redis-4.0.2-with-cmakelist-for-reading-code-in-clion" target="_blank" rel="noopener">redis-4.0.2-with-cmakelist-for-reading-code-in-clion</a>，把<a href="/files/CMakeLists.txt">CMakeLists.txt</a>扔到工程目录下，然后针对5.0.5修改一下。</p>
<p>首先，redis并没有直接暴露很多底层的数据结构给用户，而是为用户暴露了以下五种类型的对象，可以通过<code>TYPE KEY_NAME</code>获得</p>
<ul>
<li>OBJ_STRING：字符串</li>
<li>OBJ_LIST：列表</li>
<li>OBJ_SET：集合</li>
<li>OBJ_ZSET：有序集合</li>
<li>OBJ_HASH：哈希表</li>
</ul>
<p>每种类型的实现则不一定、可能动态变化，理论上对用户是透明的，可以通过<code>OBJECT ENCODING KEY_NAME</code>获得，包括，</p>
<ul>
<li>OBJ_ENCODING_RAW：简单动态字符串（Simple Dynamic String, sds）</li>
<li>OBJ_ENCODING_INT：long类型整数</li>
<li>OBJ_ENCODING_HT 2：hash表</li>
<li>OBJ_ENCODING_ZIPMAP：压缩字典</li>
<li>OBJ_ENCODING_LINKEDLIST：双向链表，已弃用，采用quicklist代替</li>
<li>OBJ_ENCODING_ZIPLIST：压缩列表</li>
<li>OBJ_ENCODING_INTSET：整数集合</li>
<li>OBJ_ENCODING_SKIPLIST：跳表</li>
<li>OBJ_ENCODING_EMBSTR：embstr编码的SDS</li>
<li>OBJ_ENCODING_QUICKLIST：快列表？不知道怎么翻译</li>
<li>OBJ_ENCODING_STREAM 10：listpack，主要用来实现redix tree</li>
</ul>
<h2 id="简单动态字符串（Simple-Dynamic-String-sds）"><a href="#简单动态字符串（Simple-Dynamic-String-sds）" class="headerlink" title="简单动态字符串（Simple Dynamic String, sds）"></a>简单动态字符串（Simple Dynamic String, sds）</h2><p>在<code>sds.h</code>中定义，类似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">// 字符串长度，可以用O(1)时间获得字符串长度</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">// 一共申请了多少字节的内存</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">// 用来区分sdshdr版本</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 指向字符串的数组，简单来说redis的字符串和正常c字符串类似，也是以`\0`结尾，故兼容c标准库字符串函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先要说一下c的变长数组（flexible array），定义为变长数组后，这个结构体的长度实际上就可以是不定长且连续的。显然这种struct成员只能放在最后定义，用来处理流之类的不定长数据非常方便。</p>
<p>严格来说<code>sdshdr</code>不是字符串而是字节流，因为字节流是可以在中间包含<code>\0</code>的，而c风格字符串不可以。</p>
<p>redis字符串正常用起来和普通c字符串类似。但是当长度发生变化时，如果<code>len &lt; alloc</code>，则可以先尝试从buf里分配，从而避免频繁申请/释放内存；<code>flags</code>则是用来区分字符串版本，因为<code>len</code>和<code>alloc</code>本身的长度可以为8、16、32、64bit四个版本，且可以在使用中动态调整。以下是重新申请空间的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis对<code>sdshdr</code>结构体的操作总是传入<code>buf</code>指针，通过<code>buf[-1]</code>来判断类型，再进行下一步操作。如果<code>avail</code>足够用，则直接增加<code>len</code>即可。否则，先确定新字符串的长度，然后尽可能多的尝试分配内存，再检查一下<code>type</code>是否发生了变化（比如需要用16位的length来代替8位的length），如果没发生变化，则返回<code>realloc</code>后的指针即可，否则需要重新申请一块内存，把字符串内的数据copy过去后，再修改header信息。</p>
<h2 id="链表（list）"><a href="#链表（list）" class="headerlink" title="链表（list）"></a>链表（list）</h2><p>相对来说链表比较简单，redis实现了双向链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><code>listNode</code>定义了前驱、后继节点和指向实际数据的指针； <code>list</code>包含了头、尾指针、链表长度，以及节点复制、释放、比较的函数指针；<code>listIter</code>是迭代器。其他的基本链表操作函数就忽略了。</p>
<p>另外redis已弃用双向链表，采用quicklist实现列表</p>
<h2 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h2><p>Redis的字典使用了hash表作为底层实现，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key; </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;  <span class="comment">// value，如果是基本类型则可以不需要额外空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个entry</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);   <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);  <span class="comment">// 复制key</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);   <span class="comment">// 复制value</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2); <span class="comment">// 比较key</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);  <span class="comment">// 释放key</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);    <span class="comment">// 释放value</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;  <span class="comment">// dictEntry[N]代表了hash值为N的桶（数组）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// table数组的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 方便获取hash值对应到哪个桶</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  <span class="comment">// 一共保存了多少个节点</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;  <span class="comment">// 节点操作函数指针集合</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据，方便操作hash表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];        <span class="comment">// 维护了两个hash表，ht[1]主要用来进行rehash，一般使用ht[0]</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">// rehash索引，-1表示没有在rehash</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">// 一共有多少个相关的iterator</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;  <span class="comment">// 指向dict的指针</span></span><br><span class="line">    <span class="keyword">long</span> index;  <span class="comment">// 索引值</span></span><br><span class="line">    <span class="keyword">int</span> table;  <span class="comment">// 应该访问dict.ht[0]还是dict.ht[1]</span></span><br><span class="line">    <span class="keyword">int</span>  safe;  <span class="comment">// 是否为安全模式，如果为1表示可以在迭代期间进行add、find等操作，否则只能执行dictNext()</span></span><br><span class="line">    dictEntry *entry, *nextEntry; <span class="comment">// 当前的entry和下一个entry</span></span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;  <span class="comment">// 迭代器指纹，表示字典是否在迭代期间是否变化</span></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<p>Hash表的桶长度必须为2的倍数（计为N），这样对N求模的时候，可以改为对N-1求与。如果hash冲突，则用<code>dictEntry-&gt;next</code>来串起来形成单链表。</p>
<p>这样做另一个好处是，在扩表rehash的时候，某个桶里的key只能被重新rehash到特定的两个桶里。比如桶大小为0b1000，那么对于任意的key，会落在hash(key)&amp;0b111的桶内，计为b0。如果桶增长为0b10000，那么会落在hash(key)&amp;0b1111=(hash(key)&amp;0b1000) | (hash(key)&amp;0b111)，即取决于hash(key)写为二进制后的第4位是否为1。当然更重要的是缩表时，由于某些桶也只能映射到同一个桶里，那么把两个链表连在一起就可以了。不管扩表还是缩表，新的hash表桶数量还是取决于节点数。</p>
<p>Redis的rehash过程是渐进式的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis每次只处理10*n个桶，那么如果刚巧这些桶都没有数据，那么可能这一趟下来一个节点也不处理。rehashidx代表了正在rehash哪个桶，每次rehash的时候都是从ht[0]迁移到ht[1]，对于每个节点，会从ht[0]删除，再加到ht[1]里。最后检查ht[0]-&gt;used是否为0，以判断rehash是否结束。如果结束，则释放ht[0]，将ht[0]指向ht[1]，清空ht[1]，并重置rehashidx。</p>
<p>渐进式rehash的好处是不会长时间阻塞（除非某个桶里的节点数非常多，当然也可以改成按节点个数来决定一趟rehash持续多长时间，但暂且不论），但对其他操作会有一定影响。不过redis单线程的特性会减少非常多的锁和同步带来的问题（比如多线程环境下对rehashidx的操作必须加锁，移动节点也必须加锁来保证原子性），因此这些处理会变得比较简单，比如添加操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently. */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出每次添加的时候都会尝试推进rehash过程（如果存在的话），然后根据rehashidx向对应的ht里插入数据；类似的，查询时两个表都会查。不过扩表和缩表的时机暂时没查到，据说和负载因子（<code>used/size</code>）有关，过大会扩表，过小会缩表。</p>
<p>还有一个问题在于rehash时迭代器的行为，迭代器分为safe和unsafe两种，safe的话则会增加dict的迭代器计数（这个计数器大于0时会禁止rehash），unsafe则会记下当前字典的指纹（hash值，取决于两个hash表的指针值、size、used），在释放的时候如果指纹不匹配则报错。遍历就是挨个桶遍历，每个桶顺着链表去查，遍历完一个ht后再遍历下一个，相关代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">long</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the 'next' here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个问题在于<code>dictScan</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction* bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></span><br><span class="line"><span class="comment">         * operates on the masked bits */</span></span><br><span class="line">        v |= ~m0;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">        v = rev(v);</span><br><span class="line">        v++;</span><br><span class="line">        v = rev(v);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment">         * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);</span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                next = de-&gt;next;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment the reverse cursor not covered by the smaller mask.*/</span></span><br><span class="line">            v |= ~m1;</span><br><span class="line">            v = rev(v);</span><br><span class="line">            v++;</span><br><span class="line">            v = rev(v);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fn</code>和<code>bucketfn</code>分别代表扫到一个节点和扫到一个桶时要调用的自定义函数。这里<code>v</code>是一个游标（cursor），初始可以设置为0，某种意义上代表了要扫哪个bucket，也是这个扫表算法的核心：从二进制的高位开始递增，比如当mask为0b111时，0b000会自增为0b100。核心算法为<code>v |= ~m0; v = rev(v); v++; v = rev(v);</code>，由于高位被置为1（<code>v |= ~m0</code>），那么反转后自增再反转，就一定会让有效的最高位自增1。</p>
<p>而对于正在rehash的表，则会先去扫<code>ht[0]-&gt;mask&amp;v</code>和<code>ht[1]-&gt;mask&amp;v</code>这两个桶，依次扫size较大的那个hash table有而size较小的hash table没有的桶（自增算法同上），最后v会自增到以较小的mask为掩码、按高位自增的下一个数字，并返回。下次调用时，会以这个数字先开始扫两个表对应的桶，再作为低位、从高位开始自增并扫桶，直到它自增到以较小的mask为掩码、按高位自增的下一个数字。举个例子，当较大的mask为0b11111，较小的mask为0b111，v为0时，会：</p>
<ul>
<li>扫ht[0][0]和ht[1][0]，然后依次扫ht[1]的0b10000、0b01000、0b11000，然后返回0b100</li>
<li>扫ht[0][0b100]和ht[1][0b100]，然后依次扫ht[1]的0b10100、0b01100、0b11100，然后返回0b010</li>
<li>扫ht[0][0b10]和ht[1][0b10]，然后依次扫ht[1]的0b10010、0b01010、0b11010，然后返回0b110</li>
<li>扫ht[0][0b110]和ht[1][0b110]，然后依次扫ht[1]的0b10110、0b01110、0b11110，然后返回0b001</li>
<li>…</li>
<li>扫ht[0][0b111]和ht[1][0b111]，然后依次扫ht[1]的0b10111、0b01111、0b11111，然后返回0</li>
</ul>
<p>顺序为0、16 、8、24、4、20、12、28、2、18、10、26、6、22、14、30、1、17、9、25、5、21、13、29、3、19、11、27、7、23、15、31</p>
<p>其中按位反转算法如下，原理我也不懂，但这个算法可以把比如0b00000010反转为0b01000000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Function to reverse bits. Algorithm from:</span></span><br><span class="line"><span class="comment"> * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">rev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s = <span class="number">8</span> * <span class="keyword">sizeof</span>(v); <span class="comment">// bit size; must be power of 2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask = ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((s &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mask ^= (mask &lt;&lt; s);</span><br><span class="line">        v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粗看起来，这种扫表方式和正常的逐次扫表相比，并没有什么特别的优势。但如前文所述，扩表的时候，一个key只可能被rehash到低位和原桶一样的桶里；缩表的时候，也一定会被rehash到hash(key)低位对应的桶里。因此，比如一个桶从0b111扩展到0b11111，如果0b100被扫过、v变成了0b010，那么0b??100再也不会被扫到，因为按翻转后的顺序，0b??100&lt;0b00010，而之后是从0b00010开始自增的，且不会漏扫（不考虑新增的节点）。类似的，如果从0b11111缩表到0b111，如果0b00000被扫过、v变成了0b10000，那么接下来会按0b000开始扫缩表后的桶，这样的话可能会重复扫这一个桶，但不会漏扫。而正常的按顺序扫表，缩表的时候很可能漏扫一片，扩表的时候则很可能会重复扫一片。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/24/jvm-exception/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/24/jvm-exception/" class="post-title-link" itemprop="url">JVM和异常处理</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-24 00:00:00 / Modified: 21:00:45" itemprop="dateCreated datePublished" datetime="2019-09-24T00:00:00+08:00">2019-09-24</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前读《深入理解JVM》的时候，把异常处理那段跳过去了，现在补上</p>
<p>Java代码里的<code>try{}catch(){}finally{}</code>很容易理解，而编译为.class文件后结构也是类似的，只是多了一个Exception table，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">foo</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      JSONArray array = <span class="keyword">new</span> JSONArray(args);</span><br><span class="line">      <span class="keyword">return</span> array.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException e)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace(System.out);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">      t.printStackTrace(System.err);</span><br><span class="line">    &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>会被编译为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private static java.lang.String foo(java.lang.String[]) throws java.io.IOException;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=4, args_size=1</span><br><span class="line">         0: new           <span class="comment">#2                  // class org/json/JSONArray</span></span><br><span class="line">         3: dup</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: invokespecial <span class="comment">#3                  // Method org/json/JSONArray."&lt;init&gt;":(Ljava/lang/Object;)V</span></span><br><span class="line">         8: astore_1</span><br><span class="line">         9: aload_1</span><br><span class="line">        10: invokevirtual <span class="comment">#4                  // Method org/json/JSONArray.toString:()Ljava/lang/String;</span></span><br><span class="line">        13: astore_2</span><br><span class="line">        14: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        17: ldc           <span class="comment">#6                  // String finally</span></span><br><span class="line">        19: invokevirtual <span class="comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        22: aload_2</span><br><span class="line">        23: areturn</span><br><span class="line">        24: astore_1</span><br><span class="line">        25: new           <span class="comment">#9                  // class java/io/IOException</span></span><br><span class="line">        28: dup</span><br><span class="line">        29: aload_1</span><br><span class="line">        30: invokespecial <span class="comment">#10                 // Method java/io/IOException."&lt;init&gt;":(Ljava/lang/Throwable;)V</span></span><br><span class="line">        33: athrow</span><br><span class="line">        34: astore_1</span><br><span class="line">        35: aload_1</span><br><span class="line">        36: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        39: invokevirtual <span class="comment">#12                 // Method java/lang/Exception.printStackTrace:(Ljava/io/PrintStream;)V</span></span><br><span class="line">        42: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        45: ldc           <span class="comment">#6                  // String finally</span></span><br><span class="line">        47: invokevirtual <span class="comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        50: goto          83</span><br><span class="line">        53: astore_1</span><br><span class="line">        54: aload_1</span><br><span class="line">        55: getstatic     <span class="comment">#14                 // Field java/lang/System.err:Ljava/io/PrintStream;</span></span><br><span class="line">        58: invokevirtual <span class="comment">#15                 // Method java/lang/Throwable.printStackTrace:(Ljava/io/PrintStream;)V</span></span><br><span class="line">        61: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        64: ldc           <span class="comment">#6                  // String finally</span></span><br><span class="line">        66: invokevirtual <span class="comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        69: goto          83</span><br><span class="line">        72: astore_3</span><br><span class="line">        73: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        76: ldc           <span class="comment">#6                  // String finally</span></span><br><span class="line">        78: invokevirtual <span class="comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        81: aload_3</span><br><span class="line">        82: athrow</span><br><span class="line">        83: aconst_null</span><br><span class="line">        84: areturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target <span class="built_in">type</span></span><br><span class="line">             0    14    24   Class org/json/JSONException</span><br><span class="line">             0    14    34   Class java/lang/Exception</span><br><span class="line">             0    14    53   Class java/lang/Throwable</span><br><span class="line">             0    14    72   any</span><br><span class="line">            24    42    72   any</span><br><span class="line">            53    61    72   any</span><br></pre></td></tr></table></figure>

<p>异常表对应了<code>try-catch</code>语句中的异常处理部分，比如<code>0    14    24   Class org/json/JSONException</code>表示如果在第0到第14行字节码运行过程中，如果出现<code>JSONException</code>异常，则跳转至34行；而对于<code>finally</code>语句，则是简单的将相关代码复制了3份，放到各个catch语句块后面，最后加一个<code>goto</code>指令跳转到<code>try-catch-finally</code>语句块后。（这种<code>goto</code>的用法和C对异常结果的处理方法非常类似）</p>
<p>异常一般有以下几种产生方式：</p>
<ol>
<li><code>athrow</code>指令抛出异常</li>
<li>执行/调用过程中同步产生的异常，比如OOM、除0错</li>
<li>由执行环境（比如JVM）产生的异常，和代码执行本身没有关系，比如一个线程对另一个线程执行<code>Thread.stop()</code>操作</li>
</ol>
<p>关于JVM如何捕获和处理异常，可以参考<a href="https://www.zhihu.com/question/53054894/answer/133229470" target="_blank" rel="noopener">读完CSAPP异常控制流之后，对Java异常机制的疑惑? - RednaxelaFX的回答 - 知乎</a>，简单来说，<code>athrow</code>出来的异常JVM总是能想办法捕获的，而对于系统报错，可以先向OS注册一个signal handler，并转换为Java层面异常抛出。</p>
<p>在捕获到异常后，JVM会去顺序查找异常表，如果from、to、type都满足，就使用那个handler处理；如果始终无法正确处理，则弹出栈帧，重复这一过程；如果到最后都没有正确处理，则本线程终止。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
