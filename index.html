<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="读书笔记">
<meta property="og:url" content="https://maxiaoxin.github.io/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记">
  <link rel="canonical" href="https://maxiaoxin.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2020/03/12/ceph2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/03/12/ceph2/" class="post-title-link" itemprop="url">Ceph学习（2） Object映射关系和BlueStore简介</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-03-12 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-12T00:00:00+08:00">2020-03-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-24 16:05:10" itemprop="dateModified" datetime="2020-03-24T16:05:10+08:00">2020-03-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ceph使用Rados存储实际数据。对象存储的一个特点是不支持/不需要很多文件系统的特性，比如目录，因此ceph采用了绕过文件系统、通过直接管理磁盘的方式来提高存读效率。</p>
<h2 id="Object映射关系"><a href="#Object映射关系" class="headerlink" title="Object映射关系"></a>Object映射关系</h2><h3 id="Pools（存储池）"><a href="#Pools（存储池）" class="headerlink" title="Pools（存储池）"></a>Pools（存储池）</h3><p>个人理解很像S3的bucket概念，可以将object进行分组区分，便于管理，比如防止重名、设置quota、设置存储类型（多副本/纠错）、ruleset、副本数等。</p>
<p>相对于S3的bucket，ceph中的pool的主要作用还是可以为不同组的object设置不同ruleset。比如可以创建两个pool，分别用以保存冷、热数据，对于热数据可以设置采用多副本模式、使用SSD osd，而对于冷数据可以使用raid模式、机械硬盘，从而提高效率。又或者对于不太重要的数据，可以将隔离级别降低，提高系统利用率。</p>
<p>每个pool有唯一的id。创建Ceph时有一些默认的pool，比如rbd，其id为0。常见的关于pool的操作包括：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ceph osd lspools <span class="comment"># 列出pools</span></span><br><span class="line">ceph osd pool create &#123;pool-name&#125; &#123;pg-num&#125; [&#123;pgp-num&#125;] [replicated] [crush-ruleset-name] [expected-num-objects] <span class="comment"># 创建pool</span></span><br><span class="line">ceph osd pool <span class="built_in">set</span>-quota &#123;pool-name&#125; [max_objects &#123;obj-count&#125;] [max_bytes &#123;bytes&#125;] <span class="comment"># 设置配额</span></span><br><span class="line">ceph osd pool delete &#123;pool-name&#125; [&#123;pool-name&#125; --yes-i-really-really-mean-it] <span class="comment"># 删除pool</span></span><br><span class="line">ceph osd pool rename &#123;current-pool-name&#125; &#123;new-pool-name&#125; <span class="comment"># 重命名pool</span></span><br><span class="line">rados df <span class="comment"># 查看统计信息</span></span><br><span class="line">ceph osd pool <span class="built_in">set</span> &#123;poolname&#125; size &#123;num-replicas&#125; <span class="comment"># 设置副本数</span></span><br></pre></td></tr></table></figure>

<h3 id="Placement-Groups（归置组）"><a href="#Placement-Groups（归置组）" class="headerlink" title="Placement Groups（归置组）"></a>Placement Groups（归置组）</h3><p>为了实现不同pool之间的隔离，Ceph并没有将object直接映射到osd，而是引入了placement group作为中间层，实现两级映射，如下图所示</p>
<p><img src="/images/ceph_pg_map.jpeg" alt="Ceph组织架构"></p>
<p>大致是通过oid(object id)和一些meta信息（如副本总数）算出一个hash值，得到pgid(placement group id)，再用pgid和crushmap算出映射到哪些osd。由于 Ceph 集群必须能增大或缩小、并动态地重均衡。如果让客户端“知道”哪个 OSD 有哪个对象，就会导致客户端和 OSD 紧耦合；相反， CRUSH 算法把对象映射到归置组、然后再把各归置组映射到一或多个 OSD ，这一间接层可以让 Ceph 在 OSD 守护进程和底层设备上线时动态地重均衡。</p>
<p>pgid全局唯一，由monitor统一管理，一般是类似{pid}.1, {pid}.2, {pid}.3, … 这样的形式，即以pool id为前缀。由于pool的id是全局唯一的，因此只要每个pool内的pgid不冲突就可以保证pgid全局唯一。</p>
<p>与CRUSH算法类似，oid到pgid的映射也需要考虑扩展性和负载均衡。这个问题很像redis的hash表的扩展，redis采用的策略是使用2<sup>n</sup>作为掩码，从而导致扩展时每个桶迁移的时候只有一半的数据需要迁移。不过ceph并没有规定pg_num只能取2<sup>n</sup>，因此采用了stable_mod算法，以减少迁移量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint32 <span class="title">stable_mod</span><span class="params">(uint32 hash, uint32 pg_num, uint32 mask)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((hash &amp; mask) &lt; pg_num)&#123;</span><br><span class="line">    <span class="keyword">return</span> hash &amp; mask;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hash &amp; (mask &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路和之前提到的类似，通过将二进制低位相同的object尽量放置在一起。但简单的用掩码做与运算，会导致一部分object落在无效的pg上，因此将这些无效的pg重映射到低位相同的pg，达到类似的效果。</p>
<p>显然这种做法会导致平均意义上部分pg映射到的object数是其他pg的两倍，不过迁移时确实能降低大部分移动工作。比如pg总数从10个提高到13个时，大概有18.75%的数据需要迁移，而如果用直接取摸的做法会有92.307%的数据要迁移。考虑到pgid到OSD的映射也起到一定负载均衡的效果，因此总的来说这个算法还是比较理想的。</p>
<p>pg扩展时一部分数据迁移称为pg分裂。采用stable_mod的另一个好处是，在使用FileStore作为存储引擎时，可以以逆序hash作为目录的方式存储object，这样当pg分裂时可以通过改动一部分子目录就可以获得待迁移的数据，再将其移动到对应的osd即可。</p>
<p>由此可以建立object-PG-OSD的映射关系。对于多副本模式，ceph写的时候会先去请求primary OSD，primary OSD接受到请求后会向所有副本发起写请求并写入本地，在所有副本响应成功后通知客户端写成功。读流程相对而言比较简单，直接读某个副本即可。</p>
<h2 id="BlueStore简介"><a href="#BlueStore简介" class="headerlink" title="BlueStore简介"></a>BlueStore简介</h2><p>为了提高访问磁盘的效率，ceph可以选择使用BlueStore直接管理硬盘，不再进行rados对象和文件之间的转换，从而简化I/O路径。基本架构如下图所示，</p>
<p><img src="/images/ceph_bluestore.jpg" alt="BlueStore基本架构"></p>
<p>简单来说，BlueStore默认采用位图模式管理磁盘，并使用RockDB管理元数据；且BlueStore实现了一个小的文件系统BlueFS，支持BlueRocksEnv接口，从而能够运行RocksDB。BlueStore和BlueFS可以共享设备，也可以指定不同设备。BlueStore中的数据大致分为三类：</p>
<ul>
<li>对象数据，一般保存在慢速设备中</li>
<li>元数据（如onode），由BlueFS直接管理，保存在高速设备中</li>
<li>WAL，由BlueFS直接管理，保存在超高速设备中</li>
</ul>
<p>实际上如果没有足够容量的高速设备，WAL和sst也可以保存在慢速设备中，BlueStore会将这部分硬盘空间标为BlueFS正在使用。</p>
<p>管理磁盘和内存最大的不同点在于磁盘需要以块为单位扇入/扇出，通常会以block为单位（默认4k）读写，不过为了管理方便ceph的最小分配单元min_alloc_size是block大小的整数倍（SSD默认16K，HDD默认64K）。如下图所示，Bluestore中的一个object的元数据对应于一个onode数据结构，被持久化到rocksdb中。每个onode包含若干lextent（逻辑段，可以不连续，即bluestore支持稀疏写，数据校验、压缩、共享也是以lextent为基本单位的），每个lextent会映射到某个blob上的一个区间。一个blob可能包含多个pextent，这些pextent最终对应于磁盘上的某一块数据。</p>
<p><img src="/images/ceph_bluestore_disk_arch.jpg" alt="Object到磁盘的映射"></p>
<p>Bluestore的读流程相对简单，只需要读到相应的block并为空洞补0即可。写流程比较复杂，即使同一个写操作也会按照min_alloc_size进行判断，拆分成若干大写（do_write_big，对齐写）和小写（do_write_small，非对齐写），具体流程可以参考<a href="http://www.sysnote.org/2016/08/19/ceph-bluestore/" target="_blank" rel="noopener">ceph存储引擎bluestore解析</a>和<a href="http://blog.wjin.org/posts/ceph-bluestore.html" target="_blank" rel="noopener">Ceph BlueStore</a>，注意在覆盖写的时候可能会需要将WAL写入rocksdb。按我理解，对于对象存储，用对齐写的概率远高于非对齐写，因此对写效率的提升是很明显的。此外，copy操作会产生带引用计数的共享blob，当发生修改时会采用copy-on-write。</p>
<p>关于缓存，BlueStore中需要缓存两类数据：元数据（如onode）和用户数据。常见的缓存淘汰算法有LRU（Least Recently Used）和LFU（Least Frequently Used），分别优先淘汰最晚访问和最近一段时间访问频率最少的缓存，BlueStore中的元数据使用LRU算法进行管理。用户数据使用2Q算法：它使用了三个队列A1in、A1out和Am，其中A1out不保存实际数据。当有新的缓存被加载进来时，首先进入A1in队列，且被命中时不会提升其热度，直到它淘汰进入A1out。当A1out中某一项被命中时，则将其移入Am，即认为它是真正的热数据；Am中被淘汰的项也会进去A1out。采用这种算法可以识别访问相关性带来的缓存命中提高。</p>
<p>这只是bluestore的基本流程，上层还需要根据不同的PG和object进行判断，非常复杂。感觉对磁盘管理理解的还是很肤浅，以后要补习一下常见的文件系统是如何管理磁盘的。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2020/03/03/ceph1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2020/03/03/ceph1/" class="post-title-link" itemprop="url">Ceph学习（1） CRUSH简介</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2020-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-03T00:00:00+08:00">2020-03-03</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-12 15:42:52" itemprop="dateModified" datetime="2020-03-12T15:42:52+08:00">2020-03-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学习ceph的起因是听说ceph对小文件的读写支持很好，但也有地方说ceph更适合大文件的存储，所以还是自己确认一下。前端时间一直断断续续的看Ceph相关的书（《Ceph设计原理与实现》），现在也应该做一下笔记了。</p>
<p>Ceph基本架构如下，可以看到用户可以通过四种方式访问ceph（动态库、对象存储API、块存储访问、posix文件系统访问），无论哪种，最终还是落盘到RADOS上，这也是ceph的核心。</p>
<p>本地集群搭建可以参考<a href="https://juejin.im/post/5e17eff0f265da3e1a59a0ab" target="_blank" rel="noopener">Ubuntu通过docker快速搭建Ceph测试集群（单机部署）</a></p>
<p><img src="/images/ceph_arch.png" alt="Ceph基本架构"></p>
<p>Ceph存储的核心是RADOS（Reliable Autonomic Distributed Object Store，可靠自主的分布式对象存储），基本原理是我们通过object key和一些集群信息计算一个hash值，这个hash值会将其唯一的映射到某一台或者几台具体的存储设备上：只要object key和集群信息不变，那么这个映射关系就不会变；只要hash足够优秀，那么最终各个存储设备就会负载均衡。通过这种方式，我们在避免访问一个中心化的节点的同时，将数据分散在多台机器中，从而得到一个分布式的存储系统。</p>
<p><img src="/images/ceph_rados_arch.png" alt="RADOS基本架构"></p>
<p>这里有几个核心概念：</p>
<ul>
<li>OSD（Object Storage Device，对象存储设备）：一个逻辑或物理上的存储单元，可以简单理解为一个主机。有时候也指OSD守护进程。一个object的数据最终会存储在某一个OSD上。</li>
<li>MDS（Metadata server，元数据服务器）：保存ceph元数据的服务</li>
<li>MON（Monitor，监视器）：Ceph监控进程</li>
<li>CRUSH（Controlled Replication Under Scalable Hashing）：ceph用户计算object地址的伪随机算法</li>
<li>PG（Placement Group，归置组）：对象的集合，用以简化object地址计算</li>
<li>Ceph集群运行图（Cluster Map）：Ceph 依赖于 Ceph 客户端和 OSD ，因为它们知道集群的拓扑，这个拓扑由 5 张图共同描述，统称为“集群运行图”：<ul>
<li>Montior Map： 包含集群的 fsid（Ceph作为文件系统时的文件系统标识符） 、位置、名字、地址和端口，也包括当前版本、创建时间、最近修改时间。要查看监视器图，用 ceph mon dump 命令。</li>
<li>OSD Map： 包含集群 fsid 、创建时间、最近修改时间、存储池列表、副本数量、归置组数量、 OSD 列表及其状态（如 up 、 in ）。要查看OSD运行图，用 ceph osd dump 命令。</li>
<li>PG Map：包含归置组版本、其时间戳、最新的 OSD 运行图版本、占满率、以及各归置组详情，像归置组 ID 、 up set 、 acting set 、 PG 状态（如 active+clean ），和各存储池的数据使用情况统计。</li>
<li>CRUSH Map：包含存储设备列表、故障域树状结构（如设备、主机、机架、行、房间、等等）、和存储数据时如何利用此树状结构的规则。</li>
<li>MDS Map： 包含当前 MDS 图的版本、创建时间、最近修改时间，还包含了存储元数据的存储池、元数据服务器列表、还有哪些元数据服务器是 up 且 in 的。要查看 MDS 图，执行 ceph mds dump 。</li>
</ul>
</li>
</ul>
<p>Ceph 存储系统支持“池”概念，它是存储对象的逻辑分区。Ceph 客户端从监视器获取一张集群运行图，并把对象写入存储池。存储池的 size 或副本数、 CRUSH 规则集和归置组数量决定着 Ceph 如何放置数据。</p>
<p>由此可见，RADOS的核心是CRUSH，它直接影响了RADOS的性能。</p>
<p>考虑一个简单的情况：我们有一大堆objects（每个object对应唯一id），和一大堆主机，如何将这些object保存在这些主机上，使得</p>
<ul>
<li>可以通过objectID和少量额外信息（如当前集群拓扑图），唯一计算出其所属主机（可能有多个）</li>
<li>统计意义上object存放应当达到负载均衡，且允许不同主机拥有不同的负载能力，允许多个副本保存在不同主机/机柜等单位上</li>
<li>object或主机的加入/删除尽量少的影响其他object的存放位置</li>
<li>object存放的先后顺序不应当影响计算结果</li>
<li>同一object的不同副本应保存在不同主机上</li>
</ul>
<p>为了达到这些目标，Sage等人提出了CRUSH算法（<a href="https://www.ssrc.ucsc.edu/Papers/weil-sc06.pdf" target="_blank" rel="noopener">CRUSH: Controlled, Scalable, Decentralized Placement of Replicated Data</a>）。为了方便描述，CRUSH以树的形式描述集群拓扑图，并引入了两种节点bucket和device，分别表示树的中间节点和叶节点，其中只有device设备是实际的承载数据的最终设备。不同节点有不同的权重，用于描述其负载能力，以便达成负载均衡：显然，上层节点的权重是其所有直接子节点的权重之和。一个典型的集群拓扑结构如下图所示：</p>
<p><img src="/images/ceph_cluster_top.png" alt="典型的集群拓扑结构"></p>
<h2 id="选择算法概述"><a href="#选择算法概述" class="headerlink" title="选择算法概述"></a>选择算法概述</h2><p>在介绍CRUSH算法前，需要简单了解下RUSH算法。RUSH（Replication Under Scalable Hashing）是一个算法族，它的目标是将含有多个副本的object映射到一个可扩展的存储设备集合上。论文详见<a href="https://www.ssrc.ucsc.edu/Papers/honicky-ipdps04.pdf" target="_blank" rel="noopener">Replication Under Scalable Hashing: A Family of Algorithms for Scalable Decentralized Data Distribution</a>。RUSH中的子集群大致对应于CRUSH中的bucket，对于某个bucket，最基本的需求是从bucket中选取符合object key为x、副本号为r的子节点，称该函数为c(r,x)。不同的bucket可以有不同的策略，目前ceph支持四种不同类型的bucket，如下：</p>
<h3 id="Uniform-Buckets"><a href="#Uniform-Buckets" class="headerlink" title="Uniform Buckets"></a>Uniform Buckets</h3><p>适用于子节点权重完全一致且不太可能改变的情况，例如公司采购一批设备后就不动了。</p>
<p>这类bucket的计算方式为c(r,x) = (hash(x) + rp) mod m，其中p是一个预先随机指定的素数，显然这个算法是O(1)的。由于p和m互质，对于不同的r，c(r,x)一定不相同，这保证了不同副本保存在不同节点上。</p>
<p>当然，添加/删除节点后，几乎所有的c(r,x) 都会变化，会引起大量的数据迁移。</p>
<h3 id="List-Buckets"><a href="#List-Buckets" class="headerlink" title="List Buckets"></a>List Buckets</h3><p>这类bucket允许节点权重不同，所使用的算法为RUSH<sub>P</sub>，原始的计算流程大致如下（具体参数的含义可以参考原论文）：</p>
<p><img src="/images/ceph_rushq.jpeg" alt="RUSHQ算法"></p>
<p>个人理解，RUSH<sub>P</sub>按照节点从新到旧的顺序查找，尝试找到一个能够通过检测标准的节点再加入。对于节点j，其权重为m’<sub>j</sub>，0~j-1的总权重为n’<sub>j</sub>，z是一个由x,j确定的介于[0, m’<sub>j</sub>+n’<sub>j</sub>]的随机数，素数p≥m’<sub>j</sub>。令z’=(z+r*p) mod (m’<sub>j</sub>+n’<sub>j</sub>)，如果z’&lt;m’<sub>j</sub>，则认为测试通过。显然查找object的复杂度是O(n)</p>
<p>当n’<sub>j</sub>足够大的时候，我们可以保证在[0,R)之间至多有一个r能够通过测试，这意味着不同副本可以落在不同节点上。如果所有节点都没测试通过，个人猜测可以扔在某个固定节点上，也可以调整r，直到测试通过</p>
<p>由于是按节点添加时间的顺序从新到旧测试的，因此当有新节点加入时，只有应当落在新节点的object会被迁移。不过如果某个中间节点被删除，由于n’<sub>j</sub>发生了变化，所以对各个节点上的object分布都会有影响。</p>
<h3 id="Tree-Buckets"><a href="#Tree-Buckets" class="headerlink" title="Tree Buckets"></a>Tree Buckets</h3><p>与List buckets非常相似，只是将bucket按照二叉树组织，原始的计算流程大致如下：</p>
<p><img src="/images/ceph_rusht.jpeg" alt="RUSHT算法"></p>
<p>简单来说，RUSH<sub>T</sub>算法会尝试将object放置在左/右子树中，测试标准与RUSH<sub>P</sub>很像，只是比较的时候按左/右子树的权重判断。显然查找object的复杂度是O(logn)</p>
<p>图中没有给出<code>hash(x,node.index,r,0)</code>的算法。单从图中给出的算法看，个人理解这种树形结构可能会造成副本放置在同一台主机上。至于如何处理这种冲突，个人猜测可以不断的调整r，直到选到一个可用的节点。</p>
<p>由于选择节点是看左右子树的权重比，因此比如当左子树权重增大时，左子树已测试通过的object不会变化，但需要调整右子树（对于减小的情况也类似）。因此叶节点的加入/删除会影响集群中半数的object的分布。</p>
<p>我看到一种说法是</p>
<h3 id="Straw-Buckets"><a href="#Straw-Buckets" class="headerlink" title="Straw Buckets"></a>Straw Buckets</h3><p>Straw算法的核心是为根据object key、副本号和节点权重，为每个节点计算一个hash值，选hash值最大的那个节点。显然查找object的复杂度是O(logn)。</p>
<p>一个比较奇怪的地方在于原straw算法对权重做了特殊处理。可见，修正后的权重与其他元素有关，因此添加和删除节点时会造成不相关元素的迁移。原论文对hash算法描述的很简略，个人猜测搞这么麻烦是为了让数据分布的更均匀</p>
<p><img src="/images/ceph_straw.jpeg" alt="Straw算法"></p>
<p>所以ceph后来使用了straw2算法，更符合算法描述</p>
<p><img src="/images/ceph_straw2.jpeg" alt="Straw2算法"></p>
<p>可以看出，在添加/删除节点的时候，只对刚好hash值落在这个节点上的object会有影响。因此straw2算法的抵御结构变化的效果最好，故ceph将其作为默认的选择算法。</p>
<h2 id="Cluter-Map"><a href="#Cluter-Map" class="headerlink" title="Cluter Map"></a>Cluter Map</h2><p>Cluter Map是Ceph集群拓扑结构的逻辑描述。Ceph集群通常是“数据中心-机架-主机-磁盘”这样的树形结构，且叶节点的ID为正，内部节点的ID为负。</p>
<p>常见的节点类型包括osd (or device)、host、chassis、rack、row、pdu、pod、room、datacenter、zone、region、root</p>
<p>比如我们刚才启动的集群，默认的crushmap结构如下，可以看到确实是个树形结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># devices</span><br><span class="line">device 0 osd.0</span><br><span class="line">device 1 osd.1</span><br><span class="line">device 2 osd.2</span><br><span class="line"></span><br><span class="line"># buckets</span><br><span class="line">host c05592a743f2 &#123;</span><br><span class="line">        id -2           # do not change unnecessarily</span><br><span class="line">        # weight 1.000</span><br><span class="line">        alg straw</span><br><span class="line">        hash 0  # rjenkins1</span><br><span class="line">        item osd.0 weight 1.000</span><br><span class="line">&#125;</span><br><span class="line">host 4c637dadfc46 &#123;</span><br><span class="line">        id -3           # do not change unnecessarily</span><br><span class="line">        # weight 2.000</span><br><span class="line">        alg straw</span><br><span class="line">        hash 0  # rjenkins1</span><br><span class="line">        item osd.1 weight 2.000</span><br><span class="line">&#125;</span><br><span class="line">host c88b7c736087 &#123;</span><br><span class="line">        id -4           # do not change unnecessarily</span><br><span class="line">        # weight 3.000</span><br><span class="line">        alg straw</span><br><span class="line">        hash 0  # rjenkins1</span><br><span class="line">        item osd.2 weight 3.000</span><br><span class="line">&#125;</span><br><span class="line">root default &#123;</span><br><span class="line">        id -1           # do not change unnecessarily</span><br><span class="line">        # weight 6.000</span><br><span class="line">        alg straw</span><br><span class="line">        hash 0  # rjenkins1</span><br><span class="line">        item c05592a743f2 weight 1.000</span><br><span class="line">        item 4c637dadfc46 weight 2.000</span><br><span class="line">        item c88b7c736087 weight 3.000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Placement-Rule"><a href="#Placement-Rule" class="headerlink" title="Placement Rule"></a>Placement Rule</h2><p>Ceph支持自定义placement rule完成数据映射，每条placement rule可以包含多个操作，包括三类：</p>
<ol>
<li>take: 从cluster map中选择指定编号的bucket，并以此作为后续的输入，如默认的规则是从root开始选择的</li>
<li>select: 从输入的bucket当中选择指定类型和数量的item。目前ceph支持两种select算法，分别是firstn和indep，分别对应多副本策略和纠错码策略</li>
<li>emit: 输出最终选择结果并返回</li>
</ol>
<p>一个典型的rule如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># rules</span><br><span class="line">rule replicated_ruleset &#123;</span><br><span class="line">        ruleset 0</span><br><span class="line">        type replicated</span><br><span class="line">        min_size 1</span><br><span class="line">        max_size 10</span><br><span class="line">        step take default</span><br><span class="line">        step chooseleaf firstn 0 type host</span><br><span class="line">        step emit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心还是在于select算法的选择，典型的firstn算法如下图所示，搜索具体的某个节点大致是个深搜的过程。流程中随机因子r是由当前副本id和重试次数共同决定。</p>
<p><img src="/images/ceph_firstn.jpeg" alt="firstn算法"></p>
<p>选择OSD失败可能包括hash冲突、过载、网络隔离/延迟、宕机。hash冲突无法避免，但后面几种情况可能会恢复，那么读的时候应该如何处理？和写副本流程一致？有一个中心化的组件用以记录特殊情况？</p>
<p>此外，ceph支持对OSD设置reweight，简单来说是个权重掩码，用于人工干预某个OSD的权重，降低其被选中的概率。将reweight设为0可以临时屏蔽某个OSD。</p>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>最后记录一些可能用到的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crushtool -o --build --num_osds ... <span class="comment"># 手动创建crushmap</span></span><br><span class="line">ceph osd getcrushmap -o &#123;compiled-crushmap-filename&#125; <span class="comment"># 导出当前集群的crushmap至指定文件</span></span><br><span class="line">crushtool -d &#123;compiled-crushmap-filename&#125; -o &#123;decompiled-crushmap-filename&#125; <span class="comment"># 将导出的crushmap文件反编译为可编辑版本</span></span><br><span class="line">crushtool -c &#123;decompiled-crushmap-filename&#125; -o &#123;compiled-crushmap-filename&#125; <span class="comment"># 将可编辑版本编译为二进制crushmap文件</span></span><br><span class="line">crushtool -i &#123;compiled-crushmap-filename&#125; --<span class="built_in">test</span> --min-x 0 --max-x 9 --num-rep 3 --rule-set 0 --show_mappings <span class="comment"># 模拟输入一些文件，输出映射结果</span></span><br><span class="line">crushtool -i &#123;compiled-crushmap-filename&#125; --<span class="built_in">test</span> --min-x 0 --max-x 1000000 --num-rep 3 --rule-set 0 --show_utilization <span class="comment"># 仅统计分布概况</span></span><br><span class="line">ceph osd setcrushmap -i &#123;compiled-crushmap-filename&#125; <span class="comment"># 重设crushmap</span></span><br><span class="line">ceph osd df tree <span class="comment"># 查看整个集群的空间利用率</span></span><br><span class="line">ceph osd reweight &#123;osd_numberic_id&#125; &#123;reweight&#125; <span class="comment"># 设置某个osd的reweight值</span></span><br></pre></td></tr></table></figure>

<p>有些地方还不是很明白，之后确定了可能会改。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/30/kmp-find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/30/kmp-find/" class="post-title-link" itemprop="url">用NFA解释KMP算法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-30 00:00:00 / Modified: 20:55:16" itemprop="dateCreated datePublished" datetime="2019-12-30T00:00:00+08:00">2019-12-30</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法" target="_blank" rel="noopener">KMP算法</a>是一个比较经典的字串搜索算法，相信学过一点算法的都知道。我一直觉得KMP算法理解起来非常反人类，尤其是我这种脑子比较轴的人，所以这里用NFA来解释KMP算法。leetcode原题在<a href="https://leetcode-cn.com/problems/implement-strstr/submissions/" target="_blank" rel="noopener">实现 strStr()</a>。</p>
<h2 id="NFA模拟字符串匹配"><a href="#NFA模拟字符串匹配" class="headerlink" title="NFA模拟字符串匹配"></a>NFA模拟字符串匹配</h2><p>如何用状态机来模拟字串搜索呢？假设目标串为<code>S=&quot;aabaabbcaabbccc&quot;</code>，模式串为<code>P=&quot;aabbcaab&quot;</code>，那么就可以制造这样一个NFA：</p>
<p>0<ruby>→ <rt>a</rt></ruby>1<ruby>→ <rt>a</rt></ruby>2<ruby>→ <rt>b</rt></ruby>3<ruby>→ <rt>b</rt></ruby>4<ruby>→ <rt>c</rt></ruby>5<ruby>→ <rt>a</rt></ruby>6<ruby>→ <rt>a</rt></ruby>7<ruby>→ <rt>b</rt></ruby>8</p>
<p>这里隐去了不成功的状态转移路径，所有未标注的状态转移路径都指向状态0，比如状态1在遇到非<code>a</code>的情况下应该跳转到0。</p>
<p>然后维持一个不重复的状态集，每解析一个目标串的字符，就尝试将集合中所有状态按照这个字符向前转移一次，初始集合为<code>{0}</code>，且转移后都要重新加入状态0。当状态集合包含最终状态（这里是状态8）时，我们认为匹配成功，否则认为匹配失败。那么针对于这个匹配，我们的状态转移过程是：</p>
<p>{0}<ruby>→ <rt>a</rt></ruby>{0,1}<ruby>→ <rt>a</rt></ruby>{0,1,2}<ruby>→ <rt>b</rt></ruby>{0,3}<ruby>→ <rt>a</rt></ruby>{0,1}<ruby>→ <rt>a</rt></ruby>{0,1,2}<ruby>→ <rt>b</rt></ruby>{0,3}<ruby>→ <rt>b</rt></ruby>{0,4}<ruby>→ <rt>c</rt></ruby>{0,5}<ruby>→ <rt>a</rt></ruby>{0,1,6}<ruby>→ <rt>a</rt></ruby>{0,1,2,7}<ruby>→ <rt>b</rt></ruby>{0,3,8}</p>
<p>可见最终的状态集合包含了目标状态8，因此匹配成功。</p>
<p>为什么可以用这样一个NFA来模拟字符串匹配过程？</p>
<ol>
<li>假设我们从目标串任意位置i开始，从初始集合{0}开始运行NFA，那么如果这个位置i与模式串匹配，那么最终一定会转移到最终状态，反之亦然</li>
<li>因此我们可以从目标串所有位置开始同时运行同一个NFA，只要其中一个转移到了状态8，那么就说明转移成功</li>
<li>由于所有初始集合均为{0}，而{0}是这些过程中任意集合的子集，且之后的状态转移路径完全相同，因此可以进行合并，即可以通过从前向后遍历目标串字符，并根据这些字符进行状态转移，就得到了同样的效果</li>
</ol>
<p>感觉说的不是特别清楚，有兴趣的可以看看编译原理。</p>
<h2 id="NFA到DFA"><a href="#NFA到DFA" class="headerlink" title="NFA到DFA"></a>NFA到DFA</h2><p>带着一个状态集跑NFA也是一个选择，但似乎可以更简化一些，比如我们可以仿照NFA转DFA的原理来重新思考这个问题。NFA转DFA的原理大致是将NFA的状态集合看作DFA的一个状态，然后不停扩展DFA的状态集合，直至不再变化。不过这里有些细小的差别：新增的状态集合需要再加一个状态0。</p>
<p>仍然以上面那个例子为例，</p>
<ul>
<li>{0}可以通过a转移到{0,1}，其他转移到{0}</li>
<li>{0,1}可以通过a转移到{0,1,2}，其他转移到{0}</li>
<li>{0,1,2}可以通过b转移到{0,3}，通过a转移到{0,1,2}，其他转移到{0}</li>
<li>{0,3}可以通过b转移到{0,4}，通过a转移到{0,1}，其他转移到{0}</li>
<li>{0,4}可以通过c转移到{0,5}，通过a转移到{0,1}，其他转移到{0}</li>
<li>…</li>
<li>{0,1,2,7}可以通过b转移到{0,3,8}，通过a转移到{0,1,2}，其他转移到{0}</li>
</ul>
<p>仔细观察这个扩展过程，有以下特点：</p>
<ol>
<li>每次都只会新增一个状态，且只和上一个状态集有关。比如{0,1,2}通过b转移到{0,3}，状态3由状态2而来，状态集{0,3}只和{0,1,2}有关</li>
<li>假设上一个状态集合为[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]，[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>]一定已经处理过，且s<sub>k</sub>一定会通过P[s<sub>k</sub>]转移到新状态s<sub>k</sub>+1</li>
<li>s<sub>k</sub>只能通过P[s<sub>k</sub>]转移到s<sub>k</sub>+1。对于非P[s<sub>k</sub>]的字符，s<sub>k</sub>只能转移到状态0，故状态集[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]遇到非P[s<sub>k</sub>]的字符的字符，转移后的状态集等同于状态集[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>]遇到相同字符转移后的状态集，且这个状态集一定已经处理过（证明起来比较麻烦，可以试试用数学归纳法）</li>
</ol>
<p>因此我们可以用状态s<sub>k</sub>来唯一指代状态集合[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]，且状态子集[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>]由状态s<sub>k-1</sub>唯一指定。换言之，可以记录一个数组prev，顺着这个数组，就能从状态s<sub>k</sub>找到全部的[s<sub>0</sub>, s<sub>1</sub>, s<sub>k-1</sub>, s<sub>k</sub>]。</p>
<p>那么如何来求prev呢？还是按照NFA转DFA中的扩展思路，假设对于状态s<sub>k</sub>，它所指代的状态集合为{s<sub>k</sub>,s<sub>k-1</sub>,…,s<sub>1</sub>,s<sub>0</sub>}={s<sub>k</sub>, prev[s<sub>k</sub>], prev[prev[s<sub>k</sub>]], …, 0}，其中s<sub>k</sub>可以通过P[s<sub>k</sub>]转移到s<sub>k</sub>+1，那接下来的问题就在于prev[s<sub>k</sub>], prev[prev[s<sub>k</sub>]], …, 0能通过P[s<sub>k</sub>]转移到哪。考虑其中的一个状态s<sub>m</sub>，有</p>
<ul>
<li>如果P[s<sub>m</sub>]==P[s<sub>k</sub>]，则s<sub>m</sub>可以通过P[s<sub>k</sub>]转移到s<sub>m</sub>+1，否则转移到0</li>
<li>假设s<sub>m</sub>可以通过P[s<sub>k</sub>]转移到s<sub>m</sub>+1，而s<sub>m</sub>+1已经被处理过，那么prev[s<sub>m</sub>]也可以通过P[s<sub>k</sub>]转移到prev[s<sub>m</sub>]+1，且prev[s<sub>m</sub>]+1==prev[s<sub>m</sub>+1]。这还是由于新状态只能由特定字符转换而来导致的。</li>
</ul>
<p>还是拿上面那个举例，已知prev[{1,2,3,4,5,6}]={0,1,0,0,0,1}，也就是已经计算得到状态6了，现在要计算状态7。状态6可以通过字符a转换到状态7，而状态prev[6]=1可以通过字符a转换到状态2，故prev[7]=2。也就是说，状态集{6,1,0}通过字符a转移到了状态集{7,2,1,0}。更一般的做法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makePrev</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prev)</span></span>&#123;</span><br><span class="line">  prev.resize(pattern.length()+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  prev[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.size(); ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> pi = prev[i];</span><br><span class="line">    <span class="keyword">while</span> (pi &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[pi])&#123;</span><br><span class="line">      pi = prev[pi];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pi == <span class="number">-1</span> || pattern[i] == pattern[pi])&#123; <span class="comment">// prev[0]设为-1主要是为了方便这里能合并if判断</span></span><br><span class="line">      prev[i+<span class="number">1</span>] = pi+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev[i+<span class="number">1</span>] = pi;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，假设我们已经得到了DFA，那么应该如何运行呢？之前提到，我们可以用最后一个状态s<sub>k</sub>来唯一指代一个状态集合来作为DFA的状态，而DFA中的状态能转移到哪得把状态集里所有状态都扫一遍。因此假设当前字符为c，有</p>
<ul>
<li>如果P[s<sub>k</sub>]==c，则转移到状态s<sub>k</sub>+1，否则得查P[prev[s<sub>k</sub>]]</li>
<li>下一个状态集至少有状态0</li>
</ul>
<p>因此可以这么判断：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (needle.size() &gt; haystack.size())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (needle.empty())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev;</span><br><span class="line">  makePrev(needle, prev);</span><br><span class="line">  <span class="keyword">int</span> successIndex = needle.size();</span><br><span class="line">  <span class="keyword">int</span> pi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.size(); ++i)&#123;</span><br><span class="line">    <span class="keyword">char</span> c = haystack[i];</span><br><span class="line">    <span class="keyword">while</span> (pi &gt;= <span class="number">0</span> &amp;&amp; c != needle[pi])&#123;</span><br><span class="line">      pi = prev[pi];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (++pi &gt;= successIndex)&#123; <span class="comment">// prev[0]设为-1后这里也能合并判断</span></span><br><span class="line">      <span class="keyword">return</span> i-needle.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实代码写出来就非常像KMP了，只是对于状态转移，KMP的解释是后缀匹配，但我个人很难理解后缀匹配，用笔算着算着就晕了。用状态转移解释的话，虽然说着麻烦，但自己笔算推演一下就很容易理解。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/13/opencv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/13/opencv/" class="post-title-link" itemprop="url">opencv简单使用</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-13 00:00:00 / Modified: 16:16:10" itemprop="dateCreated datePublished" datetime="2019-12-13T00:00:00+08:00">2019-12-13</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前试了一下，将ImageIO换成opencv后，图片转换效率和内存使用率有明显提升，比如同一张大图，ImageIO大概能用十来秒，opencv平均用时1秒左右，果断换了。</p>
<p>我编译出来opencv的动态链接库后，放到线上运行时还会报错<code>libstdc++.so</code>和<code>libjasper.so</code>找不到对应的版本，拷一个过去就可以了。</p>
<p>基本操作还是将原图转换为Mat，再做一大堆操作（旋转、缩放等），最后编码为目标图。</p>
<p>需要注意的有两点：</p>
<ul>
<li>opencv使用了大量堆外内存，所以需要把堆外内存调大点（<code>-XX:MaxDirectMemorySize</code>参数），并且几乎所有使用了堆外内粗的对象都要及时release</li>
<li>直接读文件可以用<code>imread()</code>，读内存用<code>imdecode()</code>，但这种方式会导致exif信息丢失，导致exif中如果有Orientation信息时，会导致转换后相对于原图旋转/翻转，因此要手动旋转/翻转。据说高版本的<code>imread()</code>会自动选择/翻转。</li>
</ul>
<p>但是对于动图，我暂时还没找到opencv的处理方法，所以还是用gifsicle+libwebp。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原图转换为Mat</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Mat <span class="title">bytes2mat</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">  MatOfByte matOfByte = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    matOfByte = <span class="keyword">new</span> MatOfByte(bytes);</span><br><span class="line">    <span class="keyword">return</span> Imgcodecs.imdecode(matOfByte, Imgcodecs.IMREAD_UNCHANGED);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (matOfByte != <span class="keyword">null</span>)&#123;</span><br><span class="line">      matOfByte.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转/翻转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Mat <span class="title">doOrientation</span><span class="params">(Mat mat, Orientation orientation)</span></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (orientation)&#123;</span><br><span class="line">    <span class="keyword">case</span> TOP_LEFT:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TOP_RIGHT:</span><br><span class="line">      Core.flip(mat, mat, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BOTTOM_RIGHT:</span><br><span class="line">      Core.flip(mat, mat, -<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BOTTOM_LEFT:</span><br><span class="line">      Core.flip(mat, mat, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LEFT_TOP:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RIGHT_TOP:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      Core.flip(mat, mat, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RIGHT_BOTTOM:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      Core.flip(mat, mat, -<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LEFT_BOTTOM:</span><br><span class="line">      Core.transpose(mat, mat);</span><br><span class="line">      Core.flip(mat, mat, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩放+质量，也可以是别的什么操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] convertImage(<span class="keyword">byte</span>[] srcBytes, Orientation orientation, Size sz, String ext, <span class="keyword">int</span> quality)&#123;</span><br><span class="line">  Mat srcMat = <span class="keyword">null</span>;</span><br><span class="line">  Mat dstMat = <span class="keyword">null</span>;</span><br><span class="line">  MatOfByte dstMatByte = <span class="keyword">null</span>;</span><br><span class="line">  MatOfInt thumbParams = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    srcMat = bytes2mat(srcBytes);</span><br><span class="line">    <span class="keyword">if</span> (srcMat == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (orientation != <span class="keyword">null</span>)&#123;</span><br><span class="line">      doOrientation(srcMat, orientation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Size sz = <span class="keyword">new</span> Size(params.getDstWidth(), params.getDstHeight());</span><br><span class="line">    dstMat = <span class="keyword">new</span> Mat(sz, CvType.CV_8U);</span><br><span class="line">    Imgproc.resize(srcMat, dstMat, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ext.equals(<span class="string">".jpeg"</span>))&#123;</span><br><span class="line">        thumbParams = <span class="keyword">new</span> MatOfInt(Imgcodecs.IMWRITE_JPEG_QUALITY, quality);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ext.equals(<span class="string">".webp"</span>))&#123;</span><br><span class="line">        thumbParams = <span class="keyword">new</span> MatOfInt(Imgcodecs.IMWRITE_WEBP_QUALITY, quality);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dstMatByte = <span class="keyword">new</span> MatOfByte();</span><br><span class="line">    <span class="keyword">if</span> (thumbParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Imgcodecs.imencode(ext, dstMat, dstMatByte, thumbParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Imgcodecs.imencode(ext, dstMat, dstMatByte);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dstMatByte.toArray();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (srcMat != <span class="keyword">null</span>)&#123;</span><br><span class="line">      srcMat.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dstMat != <span class="keyword">null</span>)&#123;</span><br><span class="line">      dstMat.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dstMatByte != <span class="keyword">null</span>)&#123;</span><br><span class="line">      dstMatByte.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (thumbParams != <span class="keyword">null</span>)&#123;</span><br><span class="line">      thumbParams.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/11/gcc-upgrade/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/11/gcc-upgrade/" class="post-title-link" itemprop="url">用于编译的docker镜像搭建</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-11 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-11T00:00:00+08:00">2019-12-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-12 14:14:28" itemprop="dateModified" datetime="2019-12-12T14:14:28+08:00">2019-12-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有些库编译的时候，可能本地能过，但线上跑不了，所以需要以类似线上的环境建立一个docker镜像，在里面编译完后使用。我这里是编译opencv的时候有这种需求。线上是centos6，所以我用的基础镜像也是<code>centos:6</code>。</p>
<h3 id="基础编译环境"><a href="#基础编译环境" class="headerlink" title="基础编译环境"></a>基础编译环境</h3><ul>
<li>centos: <code>yum groupinstall &quot;Development Tools&quot;</code></li>
<li>ubuntu: <code>apt-get install -y build-essential</code></li>
</ul>
<h3 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h3><p>opencv对cmake版本有要求，所以需要升级一下cmake</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz    </span><br><span class="line">tar xvf cmake-3.6.2.tar.gz &amp;&amp; <span class="built_in">cd</span> cmake-3.6.2/</span><br><span class="line">./bootstrap</span><br><span class="line">gmake</span><br><span class="line">gmake install <span class="comment"># root权限</span></span><br></pre></td></tr></table></figure>

<p>然后执行<code>cmake --version</code>看看有没有生效</p>
<h3 id="高版本的gcc"><a href="#高版本的gcc" class="headerlink" title="高版本的gcc"></a>高版本的gcc</h3><p>按说这个不是必选项，但我用低版本的gcc编译opencv出了各种问题，比如<code>opencv/3rdparty/openexr/IlmThread/IlmThreadPool.cpp:49:19: error: atomic: No such file or directory</code>，所以还是升级一下</p>
<p>可以参考<a href="https://blog.51cto.com/2716255/1965617" target="_blank" rel="noopener">曲折的gcc升级详细步骤</a>，这几个依赖包能装都装一下，最好手动装，yum有点坑。我遇到的一个问题是线上gcc寻找头文件和库的路径有点问题，似乎不会搜索<code>/usr/local</code>，并且<code>--with-isl-lib</code>这样的参数实际上在编译期间是无效的。所以安装的时候可以重新指定路径，或者手动copy到<code>/usr/include</code>和<code>/lib64</code>下。</p>
<p><code>./configure --enable-checking=release --enable-languages=c,c++ --disable-multilib --with-isl-include=/usr/local/isl/include --with-isl-lib=/usr/local/isl/lib/</code></p>
<p>编译出来gcc后，还遇到一个问题是编译opencv时报错<code>Error: no such instruction</code>，这个问题在于升级gcc的时候没有升级<code>assembler(/usr/bin/as)</code>，版本过低，因此需要再升级<code>binutils</code>。</p>
<p>不过我编译<code>binutils</code>的时候会报错<code>as.c:704:44: error: ‘TARGET_CANONICAL’ undeclared (first use in this function)</code>等一大堆错误，参考<a href="https://www.cnblogs.com/shakin/p/4276434.html" target="_blank" rel="noopener">使用zeranoe的自动化脚本mingw-w64-build-3.6.4在ubutun14.04_64bit上交叉编译ffmpeg 2.5</a>，可以把这几个变量取消掉<code>unset LIBRARY_PATH CPATH C_INCLUDE_PATH PKG_CONFIG_PATH CPLUS_INCLUDE_PATH INCLUDE</code></p>
<p>这几个依赖库make完后都可以执行<code>make check</code>来检测下是否正常。</p>
<h3 id="ant"><a href="#ant" class="headerlink" title="ant"></a>ant</h3><p>这个可以用<code>yum</code>或者<code>apt</code>之类的安装，也可以去官网下载，但无论哪种，都需要添加一个环境变量<code>ANT_HOME</code>，并且把<code>$ANT_HOME/bin</code>加到<code>PATH</code>里，<code>$ANT_HOME/lib</code>加到<code>CLASSPATH</code>里</p>
<p>至于jdk怎么安装就不提了</p>
<h3 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h3><p>此外还需要预安装一些编解码库，包括<code>zlib</code>,<code>jpeg</code>,<code>tiff</code>,<code>jasper</code>,<code>png</code>。我编译时报错<code>error: &#39;read&#39; is not a member of &#39;cv::TiffDecoderBufHelper&#39;</code>，需要加一个选项<code>-DBUILD_TIFF=ON</code></p>
<p>还有一个问题是，如果出现<code>Java wrappers: NO</code>，需要再安装python2.7以上，参考<a href="https://segmentfault.com/a/1190000000654227" target="_blank" rel="noopener">CENTOS 6.5 安装 Python 2.7 总结</a></p>
<p>正常的cmake流程即可，注意<code>cmake</code>完后需要看下有没有开启java选项</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=OFF -DBUILD_TESTS=OFF -D CMAKE_INSTALL_PREFIX=/opt/soft ..</span><br><span class="line">make -j16</span><br><span class="line"><span class="comment"># 可以不install，所以前面的prefix也可以不指定</span></span><br></pre></td></tr></table></figure>

<h3 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h3><p>可以找一个和线上环境相似的镜像，我直接用<code>centos:6</code>了，基本上需要运行这几条命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础工具</span></span><br><span class="line">yum -y groupinstall <span class="string">"Development Tools"</span></span><br><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake，从本地copy一个过来</span></span><br><span class="line"><span class="comment"># docker cp cmake-3.6.2 $&#123;docker_pid&#125;:/tmp/</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/cmake-3.6.2 &amp;&amp; ./bootstrap &amp;&amp; gmake &amp;&amp; gmake install</span><br><span class="line"></span><br><span class="line"><span class="comment"># jdk，注意安装完要添加环境变量JAVA_HOME，一般是/usr/lib/jvm/java-1.8.0-openjdk.x86_64</span></span><br><span class="line">yum install -y java-1.8.0-openjdk-devel.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># ant，注意安装完要添加环境变量将ANT_HOME，一般是/usr/share/ant</span></span><br><span class="line">yum install -y ant</span><br><span class="line"></span><br><span class="line"><span class="comment"># gcc依赖</span></span><br><span class="line">wget http://ftp.yz.yamagata-u.ac.jp/pub/GNU/gmp/gmp-6.1.2.tar.xz <span class="comment"># 太慢就挂代理，用法是wget $&#123;url&#125; -e use_proxy=yes -e http_proxy=$&#123;proxy&#125;</span></span><br><span class="line">tar -xvf gmp-6.1.2.tar.xz &amp;&amp; <span class="built_in">cd</span> gmp-6.1.2 &amp;&amp;  ./configure  --prefix=/usr/<span class="built_in">local</span>/gmp &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget http://ftp.gnu.org/gnu/mpfr/mpfr-4.0.2.tar.gz</span><br><span class="line">tar -xvf mpfr-4.0.2.tar.gz &amp;&amp; <span class="built_in">cd</span> mpfr-4.0.2 &amp;&amp; ./configure --with-gmp-include=/usr/<span class="built_in">local</span>/gmp/include  --with-gmp-lib=/usr/<span class="built_in">local</span>/gmp/lib --prefix=/usr/<span class="built_in">local</span>/mpfr &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget https://ftp.gnu.org/gnu/mpc/mpc-1.1.0.tar.gz</span><br><span class="line">tar -xvf mpc-1.1.0.tar.gz &amp;&amp; <span class="built_in">cd</span> mpc-1.1.0 &amp;&amp;  ./configure --with-mpfr-include=/usr/<span class="built_in">local</span>/mpfr/include  --with-mpfr-lib=/usr/<span class="built_in">local</span>/mpfr/lib --with-gmp-include=/usr/<span class="built_in">local</span>/gmp/include --with-gmp-lib=/usr/<span class="built_in">local</span>/gmp/lib --prefix=/usr/<span class="built_in">local</span>/mpc &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=/usr/<span class="built_in">local</span>/gmp/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line">wget http://isl.gforge.inria.fr/isl-0.22.tar.bz2</span><br><span class="line">tar -xvf isl-0.22.tar.bz2 &amp;&amp; <span class="built_in">cd</span> isl-0.22 &amp;&amp;  ./configure   --with-gmp-prefix==/usr/<span class="built_in">local</span>/gmp --prefix=/usr/<span class="built_in">local</span>/isl &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">wget ftp://gcc.gnu.org/pub/gcc/infrastructure/cloog-0.18.1.tar.gz</span><br><span class="line">tar -xvf  cloog-0.18.1.tar.gz &amp;&amp; <span class="built_in">cd</span> cloog-0.18.1 &amp;&amp;  ./configure   --with-gmp-prefix==/usr/<span class="built_in">local</span>/gmp -with-isl-prefix=/usr/<span class="built_in">local</span>/isl --prefix=/usr/<span class="built_in">local</span>/cloog &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># gcc</span></span><br><span class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-9.2.0/gcc-9.2.0.tar.gz</span><br><span class="line"><span class="built_in">export</span> C_INCLUDE_PATH=/usr/<span class="built_in">local</span>/mpfr/include:/usr/<span class="built_in">local</span>/isl/include:/usr/<span class="built_in">local</span>/mpc/include:<span class="variable">$C_INCLUDE_PATH</span></span><br><span class="line"><span class="comment"># 这里不知道为啥，修改LD_LIBRARY_PATH或者/etc/ld.so.conf都不生效，只能把上面几个编译出来的动态链接库都扔到/usr/lib64/下</span></span><br><span class="line">./configure -<span class="built_in">enable</span>-checking=release -<span class="built_in">enable</span>-languages=c,c++ -<span class="built_in">disable</span>-multilib --with-gmp=/usr/<span class="built_in">local</span>/gmp/  --with-mpfr=/usr/<span class="built_in">local</span>/mpfr --with-mpc=/usr/<span class="built_in">local</span>/mpc</span><br><span class="line"></span><br><span class="line"><span class="comment"># binutils</span></span><br><span class="line">wget https://ftp.gnu.org/gnu/binutils/binutils-2.33.1.tar.gz -e use_proxy=yes -e http_proxy=<span class="variable">$&#123;proxy&#125;</span></span><br><span class="line"><span class="built_in">unset</span> LIBRARY_PATH CPATH C_INCLUDE_PATH PKG_CONFIG_PATH CPLUS_INCLUDE_PATH INCLUDE</span><br><span class="line">tar -xvf binutils-2.33.1.tar.gz</span><br><span class="line"> ./configure --prefix=/usr</span><br><span class="line"> make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一大堆编解码库</span></span><br><span class="line"> yum install -y zlib-devel.x86_64 libjpeg-turbo-devel.x86_64 jasper-devel.x86_64 libtiff-devel.x86_64  libpng-devel.x86_64</span><br><span class="line"></span><br><span class="line"> <span class="comment"># python 2.7</span></span><br><span class="line"> wget https://www.python.org/ftp/python/2.7.8/Python-2.7.8.tgz</span><br><span class="line">tar xf Python-2.7.8.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-2.7.8</span><br><span class="line">./configure --prefix=/usr/ &amp;&amp; make -j8 &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># opencv，从本地copy一个过去</span></span><br><span class="line"><span class="comment"># docker cp opencv $&#123;docker_pid&#125;:/tmp/</span></span><br><span class="line"><span class="built_in">cd</span> /tmp/opencv &amp;&amp; mkdir build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=OFF -DBUILD_TESTS=OFF -DBUILD_TIFF=ON ..</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<p>可以全部搞完再<code>docker commit</code>，也可以搞完一步就commit一下，看情况了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/12/05/hbase-buckload2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/12/05/hbase-buckload2/" class="post-title-link" itemprop="url">记录一下HBase BulkLoad使用过程中遇到的坑</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-12-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-05T00:00:00+08:00">2019-12-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-06 10:49:08" itemprop="dateModified" datetime="2019-12-06T10:49:08+08:00">2019-12-06</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这段时间被bulkload搞的头大，记录一些问题：</p>
<h2 id="HFile权限问题"><a href="#HFile权限问题" class="headerlink" title="HFile权限问题"></a>HFile权限问题</h2><p>HBase执行bulkload时需要对应HFile目录的读写权限。网上通用做法是递归<code>chmod</code>相关目录，感觉比较麻烦。</p>
<p>最好在临时文件所在的根目录为hbase用户增加default acl，并且要在<code>hdfs-site.xml</code>中增加<code>fs.permissions.umask-mode=000</code>这一项</p>
<p>默认的<code>fs.permissions.umask-mode</code>应该是022，这会导致新创建子目录的mask为’r-x’，hbase用户写操作失败。</p>
<h2 id="HBase的hadoop-client版本需要与hdfs版本相对应"><a href="#HBase的hadoop-client版本需要与hdfs版本相对应" class="headerlink" title="HBase的hadoop-client版本需要与hdfs版本相对应"></a>HBase的hadoop-client版本需要与hdfs版本相对应</h2><p>由于hbase region server需要加载HFile，即会去读写相关HFile文件，因此hadoop-client和hdfs版本不匹配会出现一些奇奇怪怪的问题。</p>
<p>我遇到的情况是2.6版本的<code>hadoop-client</code>访问2.4的hdfs会报权限错。但奇怪的是如果hbase访问hdfs有问题，那么region server根本不应该能跑起来，只能说是玄学。</p>
<h2 id="生成不同table的HFILE"><a href="#生成不同table的HFILE" class="headerlink" title="生成不同table的HFILE"></a>生成不同table的HFILE</h2><p>貌似<code>HFileOutputFormat2</code>只支持对于单表生成数据，那么如果需要通过某一过程同时生成两个以上表的HFILE就不能直接用了。最典型的例子是从表A把数据挪动到表B，再把表A数据删除。个人做法还是把<code>createRecordWriter()</code>方法抽取出来，毕竟自己通过<code>HFileWriter</code>去写，万一出问题了呢。</p>
<p>这里推荐一个博文<a href="http://www.zhangrenhua.com/2016/01/28/hadoop-Hbase%E5%BF%AB%E9%80%9F%E5%86%99%E5%85%A5%E8%A7%A3%E6%83%91%E4%B9%8BHFile/" target="_blank" rel="noopener">Hbase快速写入解惑之HFile</a>，里面有一个简单的本地生成HFile的例子。跑MapReduce的时候也可以参考</p>
<p>但本地生成的HFile，还需要再copy到HBase所在的HDFS集群的某个目录下，再执行<code>doBulkLoad()</code></p>
<p>这里有另一个问题是如果通过mapreduce作业生成HFile时，需不需要通过reduce来生成HFile。个人感觉还是自己控制会方便一点，建议把reduce num置为0，然后在map过程中将数据写入对应目录的不同taskId的子目录下，最后bulkload。</p>
<h2 id="写入HFile的时候需要保证KeyValue按字典序排序"><a href="#写入HFile的时候需要保证KeyValue按字典序排序" class="headerlink" title="写入HFile的时候需要保证KeyValue按字典序排序"></a>写入HFile的时候需要保证KeyValue按字典序排序</h2><p>比如要写1000行数据，每行有50个KeyValue，那么这50000个KeyValue都必须按字典序排序。</p>
<p>只使用<code>HFileOutputFormat2</code>的话不需要注意这一点，它会自动排序。</p>
<h2 id="尽量利用timestamp进行同步"><a href="#尽量利用timestamp进行同步" class="headerlink" title="尽量利用timestamp进行同步"></a>尽量利用timestamp进行同步</h2><p>由于绕开了RS，我们在写数据的时候无法通过CAS判断是否应当写入，那么timestamp就成了数据同步依据的唯一选择，但怎么用timestamp还得看具体情况</p>
<p>设t0&lt;t1&lt;t2，t0时刻我们决定清空比较早期的用户记录，如果扫表和生成HFile的时间很长，而用户t1时刻增加了记录，不指定deleteMarker的timestamp的话，在t2时刻进行bulkload时会删除这条记录，这显然是违背业务逻辑的</p>
<p>说起来为了时间戳同步这事还改动了其他模块的部分处理逻辑，真是肝疼。比如HBase timestamp有一个坑是，你可以在修改时指定一个时间戳去改，假如每次指定的timestamp相同，那么你有可能改成功。但如果某次操作是以相同timestamp写一个deleteMarker进去，那么之后再以相同时间戳写入就会失败（一直是deleteMarker），直到hbase执行compact。这个问题会导致我们不方便把一个timestamp分配给某个具体业务，以此为依据进行数据的增删改查——当然了，如果某个timestamp被置为deleteMarker，那么比这个timestamp更小的数据就有可能被compact掉。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/12/hbase-buckload/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/12/hbase-buckload/" class="post-title-link" itemprop="url">HBase BulkLoad简单用法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-12T00:00:00+08:00">2019-11-12</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-24 20:12:53" itemprop="dateModified" datetime="2019-11-24T20:12:53+08:00">2019-11-24</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>再更新一下，之前介绍的搞法会需要先通过MR作业生成一些HFile文件，但其实不一定需要用MR完成。这点可以看<code>HFileOutputFormat2.class</code>的源码，其中写HFile的核心是<code>createRecordWriter()</code>，而这个方法其实并没有用到MR作业的任何特性。</p>
<p>那么就可以自己手动把这段代码提取出来，生成一个类似<code>RecordWriter&lt;ImmutableBytesWritable, Cell&gt;</code>的类，这样可以直接在本地（或者别的什么地方）生成HFile。因此流程可以进一步简化为：</p>
<ol>
<li>直接将要写入的数据写入HFile</li>
<li>令hbase加载生成的HFile</li>
</ol>
<p>当然这个类是不是线程安全的我就不太清楚了，建议用之前加个锁，或者再优化一下代码</p>
<hr>
<p>最近发现BulkLoad这个好东西，记录一下</p>
<p>简单来说，正常的HBase写操作需要先经过Region Server，再通过一系列复杂操作后才会生成HFile并落盘（比如写WAL、flush、split等），进而生效。由于hbase的一个具体的region server是单点的，如果某个作业的写入量较大，很可能会把region server打爆。而我们知道，HBase持久化是通过HFile保存的，那么反过来，如果把写操作聚合成为一个HFile，再让hbase去加载这个hfile，那么就完成了写入操作，这样做可以省下大量的region server操作，降低负载，这个操作称为bulkload。</p>
<p>Bulkload大致步骤包括：</p>
<ol>
<li>生成要处理的数据。至于如何生成、生成什么格式得看具体场景，但无论如何，需要能被接下来的mapreduce作业访问到</li>
<li>提交一个mapreduce作业，这个作业需要读取步骤1中生成的数据，并转换为HFile。这个HFile一般可以放在hbase所在hdfs集群上的某个临时目录下面</li>
<li>令hbase加载步骤2生成的HFile</li>
</ol>
<p>网上大多数教程是讲如何导入数据，那么这里就讲讲如何批量删除数据。假设我们要删的数据保存在<code>/tmp/input.txt</code>里，以每行写一个timestamp和一个key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1573542224666,test157354-1958983957411631613/hello-00000</span><br><span class="line">1573542224674,test157354-1958983957411631613/hello-00001</span><br><span class="line">1573542224680,test157354-1958983957411631613/hello-00002</span><br><span class="line">1573542224687,test157354-1958983957411631613/hello-00003</span><br><span class="line">1573542224693,test157354-1958983957411631613/hello-00004</span><br><span class="line">1573542224700,test157354-1958983957411631613/hello-00005</span><br><span class="line">1573542224707,test157354-1958983957411631613/hello-00006</span><br><span class="line">1573542224713,test157354-1958983957411631613/hello-00007</span><br><span class="line">1573542224724,test157354-1958983957411631613/hello-00008</span><br><span class="line">1573542224730,test157354-1958983957411631613/hello-00009</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来要写一个mapper，将一行数据转换为KeyValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">ImmutableBytesWritable</span>, <span class="title">KeyValue</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">      String[] tokens = value.toString().split(<span class="string">","</span>, <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">long</span> ts = Long.parseLong(tokens[<span class="number">0</span>]);</span><br><span class="line">      String rowKey = tokens[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      Delete delete = <span class="keyword">new</span> Delete(rowKey.getBytes());</span><br><span class="line">      delete.deleteFamily(FAMILY_TO_BE_DELETE, ts);</span><br><span class="line"></span><br><span class="line">      ImmutableBytesWritable row = <span class="keyword">new</span> ImmutableBytesWritable(rowKey.getBytes());</span><br><span class="line">      <span class="keyword">for</span> (List&lt;Cell&gt; cells : delete.getFamilyCellMap().values())&#123;</span><br><span class="line">        <span class="keyword">for</span> (Cell cell : cells)&#123;</span><br><span class="line">          KeyValue kv = KeyValueUtil.ensureKeyValue(cell);</span><br><span class="line">          context.write(row, kv);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注意这里需要自己将Delete转换为KeyValue。如果是正常写数据，直接将mapper的输出类设为Put就行</p>
<p>然后初始化并启动一个mapreduce job。其核心在于<code>HFileOutputFormat2.configureIncrementalLoad()</code>，这个方法会进一步设置一些job的属性，比如各种输入输出类型。有兴趣的话可以看看源码，如果不满意可以自行修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Path filePath = <span class="keyword">new</span> Path(<span class="string">"file:///tmp/input.txt"</span>);</span><br><span class="line">Path hfilePath = <span class="keyword">new</span> Path(<span class="string">"/tmp/"</span> + tableName + <span class="string">"/"</span> + UUID.randomUUID().toString());</span><br><span class="line">Job job = Job.getInstance(conf, <span class="string">"bulkLoad"</span>);</span><br><span class="line">job.setJarByClass(DeleteMapper.class);</span><br><span class="line">job.setMapperClass(DeleteMapper.class);</span><br><span class="line">HTable table = getHTable(tableName);</span><br><span class="line">HFileOutputFormat2.configureIncrementalLoad(job, table);</span><br><span class="line">FileInputFormat.addInputPath(job, filePath);</span><br><span class="line">FileOutputFormat.setOutputPath(job, hfilePath);</span><br><span class="line">job.waitForCompletion(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>如果job能正常运行，那么会在<code>&quot;/tmp/&quot; + tableName + &quot;/&quot; + UUID.randomUUID().toString()</code>下生成一些HFile。最后加载这些HFile，最好在加载完后把HFile删掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadIncrementalHFiles loadFiles = <span class="keyword">new</span> LoadIncrementalHFiles(conf);</span><br><span class="line">HTable table = getHTable(tableName);</span><br><span class="line">loadFiles.doBulkLoad(hfilePath, table);</span><br></pre></td></tr></table></figure>

<p>实际上现在很多hbase的操作都是想办法直接操作HFile而非直接访问region server，从而降低对线上服务的影响。目前没有在启用hbase加密的集群上试过，据说因为加解密是在region server上完成的，那么估计就不能用这种方式了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/09/redis-read6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/09/redis-read6/" class="post-title-link" itemprop="url">redis学习（6）事件</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-09T00:00:00+08:00">2019-11-09</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-12 21:32:05" itemprop="dateModified" datetime="2019-11-12T21:32:05+08:00">2019-11-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>redis总体架构是reactor模型，即通过不断等待并处理一个个事件来完成任务，其支持的事件类型可以分为文件事件和时间事件。redis的主进程实际上就是这样的一个过程，从源码可以看到，<code>main()</code>函数最后会调一个<code>aeMain()</code>的函数，它的内部是一个事件循环，处理事件的过程在<code>aeProcessEvents()</code>里完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不要求处理时间事件和文件事件则立刻返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// AE_DONT_WAIT标志表示是否需要尽快返回</span></span><br><span class="line">     <span class="comment">// 如果是的话，则将等待时间设的尽可能短</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要尽快处理一个时间事件，就找一个最近的</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123; <span class="comment">// 如果找到了</span></span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms = <span class="comment">// 就计算还要多久开始</span></span><br><span class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">                shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123; <span class="comment">// 并将其设为最长等待时间</span></span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123; <span class="comment">// 否则检查一下是否需要立即返回</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不需要的话就可以block任意久</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll一下有多少个文件事件就绪</span></span><br><span class="line">        <span class="comment">// 这个地方可能会sleep</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历文件事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">// 需要记录一下是否已经执行该事件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个地方有个特殊的标志是AE_BARRIER</span></span><br><span class="line">            <span class="comment">// 每个FileEvent有两个回调函数，分别是读操作和写操作</span></span><br><span class="line">            <span class="comment">// 一般会先读后写，比如先读完用户请求、处理完后再写回去</span></span><br><span class="line">            <span class="comment">// 但有时候需要先写后读，比如应当先落盘再通知用户已成功处理</span></span><br><span class="line">            <span class="comment">// 如果设置了AE_BARRIER，则表示先写后读</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行读操作</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行写操作</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果要求先写后读，那么这里还要执行一下读操作</span></span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是先检查有没有文件事件就绪，如果有就处理，没有的话依次处理已就绪的时间事件</p>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>基本上所有网络请求都是文件事件，比如先初始化并监听一个socket，直到数据过来。监听socket可以是evport、epoll、kqueue、select，这几个函数的使用优先级依次降低，具体用哪个和当前操作系统有关，linux上一般是epoll。redis将这些I/O复用函数统一整合包装成诸如<code>aeApiCreate()</code>、<code>aeApiAddEvent()</code>、<code>aeApiPoll()</code>之类的函数。其中最主要的还是<code>aeApiPoll()</code>，这个函数会阻塞当前线程，直到有事件就绪或超时，然后返回已就绪的句柄。一般认为<code>evport</code>、<code>kqueue</code>、<code>epoll</code>都是O(1)的时间复杂度，而<code>select</code>是O(n)。</p>
<p>一个完整的用户请求可能包含多个文件事件。以TCP请求为例，在服务器初始化时，会加入一系列以<code>acceptTcpHandler()</code>为回调函数的读事件，事件触发后会<code>accept()</code>用户请求，创建一个<code>client</code>和一个以<code>readQueryFromClient()</code>为回调函数的读事件。等这个事件再触发后，会去读用户传过来的数据，解析命令并处理请求，最后返回客户端。</p>
<p>值得一提的是，这里<code>poll</code>完了以后只是说句柄可以读/写了，而不是数据已经读完了，因此poll完后还需要自己调<code>read()</code>，这一步还是阻塞读。当然如果CPU处理不过来也会阻塞。</p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>时间事件的处理逻辑在<code>processTimeEvents()</code>里。相对来说时间事件没那么复杂，时间到了就执行。server维护了一个时间事件链表，每个时间事件结构体里维护了执行时间点、回调函数和一些别的数据。在加入一个时间事件时会将其插入表头，每次处理时间事件时会扫这个链表，如果一个事件的时间到了就执行。执行完后判断是不是重复事件，如果是（标志为<code>AE_NOMORE</code>）则调整其待执行时间，否则将其ID置为<code>AE_DELETED_EVENT_ID</code>，下次处理时间事件时执行它的<code>finalizerProc()</code>回调函数，并从链表中移除。</p>
<p>理论上扫整个链表确实耗时，不过redis内置的时间事件很少，一般也只有<code>serverCron()</code>。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/05/redis-read5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/05/redis-read5/" class="post-title-link" itemprop="url">redis学习（5）持久化</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-05T00:00:00+08:00">2019-11-05</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-06 21:11:51" itemprop="dateModified" datetime="2019-11-06T21:11:51+08:00">2019-11-06</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对于单机数据库而言，持久化的思路大致分两种，一种是把当前状态（主要是数据，更具体的说是KV对）全部打包保存起来，恢复的时候直接装填；另一种是把所有写操作记录下来，恢复的时候回放这些操作。这两种思路分别对应于redis的RDB文件和AOF文件。</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>可以认为RDB是一种全量备份，其中RDB持久化的方式大致有两种，一种是服务器阻塞并备份，直至结束后再继续服务（<code>SAVE</code>、<code>FLUSHALL</code>命令）；另一种是fork一个子进程，由子进程去进行备份，子进程备份期间禁止再次启动子备份进程（<code>BGSAVE</code>或定时事件）。fork的一个好处是相当于对内存空间进行了快照操作，子线程访问到的数据都是某一时刻“正确的”数据，也就是这一时刻redis数据库的快照。无论哪种，最终调用的都是<code>rdbSave()</code>函数。</p>
<p>可以在redis服务器设置自动备份条件，保存在<code>redisServer-&gt;saveparams</code>里，主要条件有两个：时间间隔和操作次数。时间间隔很容易理解，操作次数则保存在<code>redisServer-&gt;dirty</code>，所有写操作都会增加<code>dirty</code>次数。因此在定时任务<code>serverCron()</code>里会检查各个条件是否已满足，满足则执行<code>rdbSaveBackground()</code></p>
<p><code>rdbSave()</code>是先创建一个临时文件，成功写入后再重命名为指定filename，核心的写操作是由<code>rdbSaveRio()</code>完成的，大致包括以下步骤：</p>
<ol>
<li>写入REDIS魔数和版本号</li>
<li>调用<code>rdbSaveInfoAuxFields()</code>保存redis辅助信息（AUX）</li>
<li>调用<code>rdbSaveModulesAux()</code>保存各个模块的AUX</li>
<li>遍历各个database，保存其id、object数、失效object数等，并遍历其键空间，获得每个object信息并保存</li>
<li>保存object时，如果开启RDB-AOF混合开关会从父进程读增量数据，这个地方没看懂</li>
<li>遍历并保存lua脚本</li>
<li>写入结束时的一些AUX和校验和</li>
</ol>
<p>在保存每个object时，还需要写入这个object的过期信息、LRU（如果开启相应开关）、LFU（如果开启相应开关）、type和具体数据。这部分代码比较复杂，总的来说大致流程是先按某种规则转换为数字/字符串，如果开启压缩则对字符串进行压缩，再写入文件。比如有序集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123; <span class="comment">// 如果有序集合采用ziplist实现</span></span><br><span class="line">    <span class="keyword">size_t</span> l = ziplistBlobLen((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)o-&gt;ptr);  <span class="comment">// 拿到ziplist长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,o-&gt;ptr,l)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 以裸字符串信息写入文件</span></span><br><span class="line">        nwritten += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123; <span class="comment">// 如果以skiplist实现</span></span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n = rdbSaveLen(rdb,zsl-&gt;length)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 那么先保存总长度</span></span><br><span class="line">        nwritten += n;</span><br><span class="line"></span><br><span class="line">        zskiplistNode *zn = zsl-&gt;tail; <span class="comment">// 从尾节点开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (zn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = rdbSaveRawString(rdb, <span class="comment">// 以裸字符串形式保存这个节点的值</span></span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)zn-&gt;ele,sdslen(zn-&gt;ele))) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nwritten += n;</span><br><span class="line">        <span class="keyword">if</span> ((n = rdbSaveBinaryDoubleValue(rdb,zn-&gt;score)) == <span class="number">-1</span>) <span class="comment">// 以double形式保存这个节点的score</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten += n;</span><br><span class="line">        zn = zn-&gt;backward; <span class="comment">// 向前走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管可以fork一个子进程来备份，但载入RDB文件还是必须得阻塞执行。无论是RDB还是AOF，文件写完后都会调用<code>_exit()</code>，这个函数会给它的父进程发一个<code>SIGCHLD</code>信号，父进程接受到这个信号会做一些扫尾操作，比如<code>dirty、lastsave、lastbgsave_status</code>之类的，定义在<code>backgroundSaveDoneHandler()</code>里</p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF的思路和HBase的WAL类似，都是通过记录写操作来持久化的。假如一开始数据为空，那么记录所有写操作当然可以重放出当前状态。但如果写AOF时数据不为空，且丢失了之前的写操作记录，那么就需要把存量数据先转换为写操作再记录下来。</p>
<p>在打开AOF持久化功能时，客户端每发送一条命令，如果造成数据变动（<code>server-&gt;dirty</code>发生变化），那么就会调用<code>propagate()</code>函数来把写操作写入AOF并传播到从节点。写入AOF调用的是<code>feedAppendOnlyFile()</code>函数，基本上是将命令还原为等价的redis命令字符串再写入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123; <span class="comment">// 将命令写入AOF文件</span></span><br><span class="line">    sds buf = sdsempty();</span><br><span class="line">    robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123; <span class="comment">// 需要额外加一条select命令</span></span><br><span class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid); <span class="comment">// snprintf是一个相对安全的格式化输出函数，第二个参数表示缓冲区最大长度</span></span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>, <span class="comment">// 将select命令写入buf</span></span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        server.aof_selected_db = dictid; <span class="comment">// 重置AOF正在使用的database id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand || <span class="comment">// 过期命令</span></span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]); <span class="comment">// 这个函数会将过期命令统一转换为PEXPIREAT</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123; <span class="comment">// 对于setex和setexp命令</span></span><br><span class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">"SET"</span>,<span class="number">3</span>);</span><br><span class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv); <span class="comment">// 会转换为一个写入命令</span></span><br><span class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]); <span class="comment">// 和一个过期命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123; <span class="comment">// 类似的，set命令也可能包含过期信息</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        robj *exarg = <span class="literal">NULL</span>, *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,argv); <span class="comment">// 先添加一个写命令</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; i ++) &#123; <span class="comment">// 因此需要取出过期参数</span></span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"ex"</span>)) exarg = argv[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"px"</span>)) pxarg = argv[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        serverAssert(!(exarg &amp;&amp; pxarg));</span><br><span class="line">        <span class="keyword">if</span> (exarg) <span class="comment">// 然后写入过期命令</span></span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               exarg);</span><br><span class="line">        <span class="keyword">if</span> (pxarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               pxarg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他命令直接写入即可</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON) <span class="comment">// 如果开启AOF，则将buf写入server.aof_buf</span></span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) <span class="comment">// 如果有后台子进程在运行，那么需要把这些新增的信息加进去</span></span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到实际上这个写操作只是将数据写入<code>server.aof_buf</code>，最后会统一通过<code>flushAppendOnlyFile()</code>落盘，其频率可以是<code>always</code>、<code>everysec</code>、或<code>no</code>。</p>
<p>当然这种记录写操作的一个缺点是日志可能越来越大，回放也会越来越慢，因此需要AOF重写，即丢弃之前的记录，从当前状态开始，将数据转换为等价的写操作并保存，对应的命令就是<code>BGREWRITEAOF</code>。同样的，重写结束后主进程会调用<code>backgroundRewriteDoneHandler()</code>做一些扫尾工作，比如把重写期间新产生的写操作添加进AOF文件里。另外解析出来的命令如果操作数太多，会将其分成多个命令，避免客户端缓冲区溢出。</p>
<p>一个自然而然的想法是，存量数据用RDB存，增量数据用AOF存。事实上redis4.0后增加了RDB-AOF混合持久化，持久化的文件前半段是RDB格式，后半段是AOF格式。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/11/02/redis-read4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/11/02/redis-read4/" class="post-title-link" itemprop="url">redis学习（4）数据库</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-11-02 00:00:00 / Modified: 20:16:42" itemprop="dateCreated datePublished" datetime="2019-11-02T00:00:00+08:00">2019-11-02</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>redis将数据按数据库（database）进行区分，有点像namespace。<code>redisServer</code>结构体维护了一个指向<code>redisDb</code>数组的指针，第i号database所使用的就是<code>redisDb[i]</code>，其定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;  <span class="comment">// 存放具体数据的字典，也称键空间（keyspace）</span></span><br><span class="line">    dict *expires; <span class="comment">// 存放设有超时时间的key的字典</span></span><br><span class="line">    dict *blocking_keys; <span class="comment">// 用以实现阻塞操作</span></span><br><span class="line">    dict *ready_keys; <span class="comment">// 用以实现阻塞操作</span></span><br><span class="line">    dict *watched_keys; <span class="comment">// 用以实现监控key</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">// 数据库id</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl; <span class="comment">// 平均TTL，只用来统计数据</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;  <span class="comment">// 需要整理碎片的key</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h2 id="键空间"><a href="#键空间" class="headerlink" title="键空间"></a>键空间</h2><p>dict存放了这个database的所有键和值，键都是<code>string</code>类型的<code>robj</code>，值可以是之前提到的5种<code>robj</code>。基本上常见的KV数据库的CRUD流程大概就和操作一个dict差不多，当然也有一些额外的操作：</p>
<ul>
<li>几乎所有操作前都要检查这个key有没有过期（过期信息在<code>redisDb-&gt;expires</code>字典里），如果过期则认为这个键不存在，且如果发现过期的键，则<ul>
<li>如果是master节点，需要将过期操作推送到slave节点和AOF文件</li>
<li>发送一个<code>NOTIFY_EXPIRED</code>事件</li>
<li>根据<code>lazyfree-lazy-expire</code>判断是否立即删除这个key，和删除操作类似类似</li>
</ul>
</li>
<li>同样的，几乎所有操作都会修改对应object的<code>lru</code>（最近访问时间/访问频次）</li>
<li>判断操作类型是否正确，比如<code>sadd</code>命令只能操作<code>set</code>对象</li>
<li>如果对现有的对象进行了修改，则需要根据<code>redisDb-&gt;watched_keys</code>判断这个key是否有监控，如果有的话需要将相关的<code>client</code>的flag添加<code>CLIENT_DIRTY_CAS</code>标记，并发送修改事件</li>
<li>对于删除操作，需要根据<code>lazyfree-lazy-expire</code>配置判断是否立即删除这个key<ul>
<li>同步删就是个dict删除操作，且如果是集群模式还要修改对应的slot</li>
<li>异步删的话需要从keyspace里去掉这个entry，然后判断对应的类型是否“容易”删除（目前是根据<code>quicklist</code>、<code>skiplist</code>、<code>hashtable</code>所含元素的多少来判断），如果容易删除就和同步删的操作类似，否则增加一个<code>bio_job</code>让后台线程删（这里终于用到同步了）</li>
</ul>
</li>
<li>读数据的时候还需要统计缓存命中次数</li>
</ul>
<p>这里代码分布在不同函数里，就只贴删除相关的代码了。顺便感慨一下单线程的好处，单线程意味着几乎所有操作都具有原子性（如果不是刻意打断的，比如rehash），如果是多线程的话需要加非常多的判断和锁，想想就很麻烦。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> lazy)</span> </span>&#123; <span class="comment">// 删除接口</span></span><br><span class="line">    <span class="keyword">int</span> numdel = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123; <span class="comment">// 依次删除要删除的键</span></span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]); <span class="comment">// 判断是否已过期</span></span><br><span class="line">        <span class="keyword">int</span> deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) : <span class="comment">// 同步或异步删除</span></span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123; <span class="comment">// 如果删除成功</span></span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[j]); <span class="comment">// 则需要通知所有watch这个键的client</span></span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC, <span class="comment">// 然后发送一个删除事件</span></span><br><span class="line">                <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++; <span class="comment">// 并增加一个dirty计数</span></span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; 同步删除</span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr); <span class="comment">// 在expires里删除这条记录</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123; <span class="comment">// 然后从键空间里删除这条记录</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key); <span class="comment">// 如果是集群模式还要修改slot</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; <span class="comment">// 异步删除</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr); <span class="comment">// 先从expires里删除这条记录</span></span><br><span class="line"></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr); <span class="comment">// 然后从db-&gt;dict里删掉这个entry，但还没删具体数据</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123; <span class="comment">// 如果这个entry存在</span></span><br><span class="line">        robj *val = dictGetVal(de); <span class="comment">// 那么先拿到这个值</span></span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val); <span class="comment">// 再计算要删这个值的难度，大致就是根据hashtable、skiplist、quicklist的长度来判断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == <span class="number">1</span>) &#123; <span class="comment">// 如果难度超过阈值，且引用计数为1，说明应当释放内存</span></span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>); <span class="comment">// 那么增加要惰性删除的object数</span></span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="comment">// 把这个值扔到待删除队列里</span></span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>); <span class="comment">// 并把这个entry的value置空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (de) &#123; <span class="comment">// 这样一通操作下来，就可以立即删除entry里的key和value</span></span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de); <span class="comment">// 删除这个entry的key和value（其实是引用计数-1）</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key); <span class="comment">// 如果是集群模式还要修改slot</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>每个object都可以设置过期时间，可以指定过多长时间后失效（<code>EXPIRE</code>和<code>PEXPIRE</code>），或者在某一时刻后失效（<code>EXPIREAT</code>和<code>PEXPIREAT</code>）。不过这几个命令最后都转换为在某个时刻过期来实现，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExpire</span><span class="params">(client *c, redisDb *db, robj *key, <span class="keyword">long</span> <span class="keyword">long</span> when)</span> </span>&#123; <span class="comment">// 设置过期时间</span></span><br><span class="line">    dictEntry *kde, *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单来说就是保存到db-&gt;expires里，键和db-&gt;dict的键共享，值则作为一个long保存到entry-&gt;val里</span></span><br><span class="line">    kde = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,kde != <span class="literal">NULL</span>);</span><br><span class="line">    de = dictAddOrFind(db-&gt;expires,dictGetKey(kde));</span><br><span class="line">    dictSetSignedIntegerVal(de,when);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slave节点需要记录这个过期时间</span></span><br><span class="line">    <span class="keyword">int</span> writable_slave = server.masterhost &amp;&amp; server.repl_slave_ro == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &amp;&amp; writable_slave &amp;&amp; !(c-&gt;flags &amp; CLIENT_MASTER))</span><br><span class="line">        rememberSlaveKeyWithExpire(db,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expireGenericCommand</span><span class="params">(client *c, <span class="keyword">long</span> <span class="keyword">long</span> basetime, <span class="keyword">int</span> unit)</span> </span>&#123; <span class="comment">// 处理过期命令</span></span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>], *param = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> when; <span class="comment">// 过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, param, &amp;when, <span class="literal">NULL</span>) != C_OK) <span class="comment">// 过期时间存放在client-&gt;argv[2]里，是一个long型对象</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unit == UNIT_SECONDS) when *= <span class="number">1000</span>;</span><br><span class="line">    when += basetime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果不存在这个键，则不进行任何处理</span></span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经过期了，且不是master节点或者loading状态</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt;= mstime() &amp;&amp; !server.loading &amp;&amp; !server.masterhost) &#123;</span><br><span class="line">        robj *aux;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c-&gt;db,key) : <span class="comment">// 那么需要先进行删除操作</span></span><br><span class="line">                                                    dbSyncDelete(c-&gt;db,key);</span><br><span class="line">        serverAssertWithInfo(c,key,deleted);</span><br><span class="line">        server.dirty++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要将用户命令修改为DEL或UNLINK，发送一个删除事件，并返回</span></span><br><span class="line">        aux = server.lazyfree_lazy_expire ? shared.unlink : shared.del;</span><br><span class="line">        rewriteClientCommandVector(c,<span class="number">2</span>,aux,key);</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        addReply(c, shared.cone);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则就设置一下过期时间，发送expire事件并返回</span></span><br><span class="line">        setExpire(c,c-&gt;db,key,when);</span><br><span class="line">        addReply(c,shared.cone);</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"expire"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否过期也很简单，因为expires里保存了具体的过期时间，那么对比一下就行了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; <span class="comment">//取出过期时间</span></span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> || <span class="comment">// 没找到就返回-1</span></span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然能在expires里找到这个key，那么理论上键空间里也应该有这个key</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de); <span class="comment">// 以有符号整数的形式取出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; <span class="comment">// 判断这个key是否过期</span></span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key); <span class="comment">// 具体过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 小于0表示永不过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// loading状态不做过期检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前时间，具体为啥做判断我也不清楚</span></span><br><span class="line">    <span class="keyword">mstime_t</span> now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 键如果没过期就返回没过期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 只有master节点能够认为过期的键已失效</span></span><br><span class="line"></span><br><span class="line">    server.stat_expiredkeys++; <span class="comment">// 统计过期键</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire); <span class="comment">// 向slave节点和AOF文件发送过期操作</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED, <span class="comment">// 发送一个事件</span></span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : <span class="comment">// 然后同步或异步的删除</span></span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过期数据删除策略"><a href="#过期数据删除策略" class="headerlink" title="过期数据删除策略"></a>过期数据删除策略</h2><p>《Redis设计与实现》里提到了三种删除策略：</p>
<ul>
<li>定时删除：由于我们知道什么时候过期，那么可以开启一个定时器，在对应时间唤醒一个删除操作</li>
<li>惰性删除：读到过期数据的时候再将其删除</li>
<li>定期删除：隔一段时间清理过期的数据</li>
</ul>
<p>显然第一种做法最精确，且能保证内存消耗最小，前提是需要创建和删除timer，这个timer的代价一般不会太小。第二种做法一方面会造成内存泄漏（过期数据不访问就不会被删除），另一方面会提高读写延时，因为删除一个复杂的对象还是很花时间的。</p>
<p>Redis做法是第三种，且理论上这个线程是可以侦测当前CPU是否空闲，从而决定删除频率。具体做法和redis的事件机制有关，之后再看看。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
