<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="读书笔记">
<meta property="og:url" content="https://maxiaoxin.github.io/page/3/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记">
  <link rel="canonical" href="https://maxiaoxin.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/16/jvm7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/16/jvm7/" class="post-title-link" itemprop="url">JVM学习（7）编译期优化</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-16 00:00:00 / Modified: 21:08:08" itemprop="dateCreated datePublished" datetime="2019-09-16T00:00:00+08:00">2019-09-16</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一章主要介绍关于在.java代码编译为.class文件时使用的一些优化技术。实际操作时一般用javac来实现，其编译过程大致分为3个过程：</p>
<ol>
<li>解析和填充符号表</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程</li>
</ol>
<p>这三个步骤的关系如下：</p>
<p><img src="/images/jvm_compile_process.png" alt="javac编译顺序"></p>
<p>Javac编译动作入口是<code>com.sun.tools.javac.main.JavaCompiler</code>类，基本流程如下</p>
<p><img src="/images/jvm_javac_flow.png" alt="javac"></p>
<h2 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h2><h3 id="词法和语法分析"><a href="#词法和语法分析" class="headerlink" title="词法和语法分析"></a>词法和语法分析</h3><p>词法分析是将源码的字符流转变为标记（token）集合的过程，词法分析由<code>com.sun.tools.javac.parser.Scanner</code>来实现。</p>
<p>语法分析是根据token序列构造抽象语法树（abstract syntax tree，AST），它的每个节点代表一个语法结构（construct），语法分析由<code>com.sun.tools.javac.tree.JCTree</code>来实现。之后的操作都是基于AST。</p>
<h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><p>填充符号表的过程对应上图中的<code>enterTrees()</code>，符号表（symbol table）是由一组符号地址和符号信息构成的表格，在各个编译阶段都会用到：语义分析时，需要根据符号表进行语义检查（如检查一个名字的使用是否和声明一致）和产生中间代码；在目标代码生成阶段，在对符号进行地址分配时需要用到符号表。</p>
<p>这个阶段由<code>com.sun.tools.javac.comp.Enter</code>类来实现，其出口是一个待处理列表（to do list），包含了每一个编译单元的AST顶级节点，以及package-info.java（如果有的话）的顶级节点</p>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>JDK1.5后支持了注解（annotation），可以作用于运行期；JDK1.6后提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，即允许开发者对编译器的行为做一定干涉。</p>
<p>具体可以参考<a href="https://github.com/linxiaoyang/JSR269TEST" target="_blank" rel="noopener">实践JSR269关于编译期注解的使用且搞清Lombok实现原理</a>，注意如果是自己写的话，要依赖<code>$JAVA_HOME/lib/tools.jar</code>这个包，并且由于这个步骤在编译期而非运行期，调试时需要对类似<code>javac -processor ...</code>这样的命令进行调试。</p>
<h2 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h2><p>得到AST不代表源码符合逻辑，因此需要再对其进行语义检查和分析，包括标注检查和控制流分析两个步骤，分别对应图1中<code>attribute()</code>和<code>flow()</code>方法</p>
<h3 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h3><p>主要检查类似变量使用前是否被声明、变量与赋值之间的数据类型是否匹配、常量折叠等。常量折叠是针对能在编译期计算出来的常量进行计算和简化，减少运行期负担。相关的类是<code>com.sun.tools.javac.comp.Attr</code>和<code>com.sun.tools.javac.comp.Check</code>。</p>
<h3 id="数据和控制流分析"><a href="#数据和控制流分析" class="headerlink" title="数据和控制流分析"></a>数据和控制流分析</h3><p>和类加载时控制流分析类似，可以检查出诸如程序局部变量在使用前是否赋值、方法的每条路径是否都有返回值、所有异常都被处理等。还有些只能在编译期检查出来，比如一个局部变量被声明为<code>final</code>，可能编译出来的.class文件会没有相关修饰符，而编译期可以检查这个变量是否被修改过。相关的类是<code>com.sun.tools.javac.comp.Flow</code>。</p>
<h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>语法糖（syntactic sugar）是指编程语言中增加的某些语法，它对语言功能没有影响，但更方便书写。Java的语法糖比如泛型（类型擦除）、变长参数（传个数组进去）、自动拆箱/装箱（如<code>int</code>和<code>Integer</code>转换）。这些语法糖在编译期会被还原成基础的语法结构。相关的类是<code>com.sun.tools.javac.comp.TransTypes</code>和<code>com.sun.tools.javac.comp.Lower</code>。</p>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>JDK1.5后增加了泛型，不过java是伪泛型：比如<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>在java里是同一类，而在C#里是两个不同的类，java在编译后会把具体类型替换为Object，在相关位置加入强制类型转换代码。</p>
<p>不过类型擦除只是对Code属性中的字节码进行擦除，Signature里还有泛型信息，因此可以通过反射得到参数化类型，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(List&lt;T&gt; a, Set&lt;Integer&gt; b)</span></span>&#123;</span><br><span class="line">    a.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class cls = HelloWorld.class;</span><br><span class="line">    Method method = cls.getDeclaredMethod(<span class="string">"hello"</span>, List.class, Set.class);</span><br><span class="line">    System.out.println(((ParameterizedTypeImpl)method.getGenericParameterTypes()[<span class="number">0</span>]).getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(((ParameterizedTypeImpl)method.getGenericParameterTypes()[<span class="number">1</span>]).getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T</span></span><br><span class="line"><span class="comment">// class java.lang.Integer</span></span><br></pre></td></tr></table></figure>

<h4 id="自动装箱-拆箱和遍历循环"><a href="#自动装箱-拆箱和遍历循环" class="headerlink" title="自动装箱/拆箱和遍历循环"></a>自动装箱/拆箱和遍历循环</h4><p>这些解释起来比较简单，比如这样一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : list)&#123;</span><br><span class="line">      s += i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可能会被翻译为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">        Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">4</span>)&#125;);</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator iter = list.iterator(); iter.hasNext();)&#123;</span><br><span class="line">      <span class="keyword">int</span> i = ((Integer)iter.next()).intValue();</span><br><span class="line">      s += i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当然自动拆箱/装箱里有些坑，比如各路面试里都特别喜欢考因为类似<code>IntegerCache</code>及其上下界，导致自动装箱后的引用相同等等。简单来说由于<code>Integer</code>等类型是不可变的，也就不用担心线程安全等问题，因此可以对一些经常出现的常量（比如<code>Integer.valueOf()</code>）这种的可以进行cache，比如<code>Integer</code>里默认会对<code>[-128, 127]</code>这个范围内的数字进行cache，避免每次因为<code>Integer.valueOf()</code>创建新的对象。不过<code>new Integer()</code>总会创建新的对象。</p>
<p>另一个坑是循环时对数组进行操作，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"123"</span>);</span><br><span class="line">    list.add(<span class="string">"456"</span>);</span><br><span class="line">    list.add(<span class="string">"798"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">      list.remove(s);</span><br><span class="line">      System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 报错java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>

<p>解语法糖后可以看到这种删除方式会导致迭代器不可用，因此需要改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; iter = list.iterator(); iter.hasNext();)&#123;</span><br><span class="line">  System.out.println(iter.next());</span><br><span class="line">  iter.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>Java默认如果检测到某条分支永远不会执行到，会拒绝编译，最典型的是<code>return;</code>后的语句。所以一般会用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这样的方式来避免拒绝编译。实际上控制流分析后也会把相关代码忽略掉。</p>
<p>另外比如内部类、枚举类、断言语句、<code>switch</code>枚举类和字符串、<code>try</code>的自动关闭资源等都是通过语法糖实现的。</p>
<h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>字节码生成是javac编译过程的最后一个阶段，由<code>com.sun.tools.javac.jvm.Gen</code>类完成，除了将之前生成的信息转为字节码落盘外，还进行了少量代码添加和转换工作。比如把<code>&lt;cinit&gt;()</code>涉及到的语句合并在一起、将字符串加操作用<code>StringBuilder</code>或<code>StringBuffer</code>替换等。</p>
<p>完成对语法树的遍历和调整后，会把填充了所有所需信息的符号表交给<code>com.sun.tools.javac.jvm.ClassWriter.writeClass()</code>来输出为字节码文件。至此编译结束。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/10/jvm6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/10/jvm6/" class="post-title-link" itemprop="url">JVM学习（6）JVM字节码执行引擎</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-10T00:00:00+08:00">2019-09-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-12 17:11:08" itemprop="dateModified" datetime="2019-09-12T17:11:08+08:00">2019-09-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于JVM规范本身就是个虚拟概念，因此JVM执行引擎也是个标准，具体实现时会有优化，但要保证执行语义符合规范：即从外观（facade）上看，所有JVM虚拟机的执行引擎都是一致的。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧（stack frame）是用于支持JVM进行方法调用和方法执行的数据结构，是运行时数据区中虚拟机栈（virtual machine stack）的栈数据，栈帧保存了方法的局部变量表、操作数栈、动态连接、方法返回地址等信息。之前提到方法表Code属性，里面有栈帧大小的限制，因此一个栈帧占用内存大小在编译期就决定了，具体占多大内存取决于JVM实现。</p>
<p><img src="/images/jvm_stack_frame.png" alt="栈帧结构"></p>
<p>对于某个线程而言，只有栈顶的栈帧是有效的（称为当前栈帧<code>current stack frame</code>），与其相关联的方法称为当前方法<code>current method</code>，所有字节码指令都只针对当前栈帧操作。</p>
<p>与大多数物理机使用基于寄存器的指令框架不同，JVM使用的是基于栈的架构，比如两个数相加需要先把两个数入栈，然后<code>iadd</code>指令把栈顶两个数拿出来相加再入栈，而寄存器就没这么麻烦。一般来说基于栈的指令集会慢一些，好处是可移植，比如上图中的各个区域的大小都可以随便调整（相对的，同一物理机的每个寄存器的特性都不太一样，不同物理机可能寄存器数目都不一样），所以JVM实际执行的时候会对这些指令进行优化。</p>
<h3 id="局部变量表（local-variable-table）"><a href="#局部变量表（local-variable-table）" class="headerlink" title="局部变量表（local variable table）"></a>局部变量表（local variable table）</h3><p>用于存放方法参数和方法内部定义的局部变量，方法的Code属性的<code>max_locals</code>数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表的基本单位是slot，规范没有指明一个slot有多大，只是说每个slot都可以存放一个<code>boolean, byte, char, shot, int, float, reference, returnAddress</code>类型，那么具体实现的时候，一个slot可以用32位，也可以用64位来存。其中，JVM没有指定<code>reference</code>长度一定要多少，甚至可以不是指针，但要求它能做到：</p>
<ul>
<li>从这个引用可以直接或间接地查找到对象在java堆中的数据存放的起始地址索引</li>
<li>从这个引用可以直接或间接地查找到对象所属数据类型在方法区中存储的类型信息（RTTI）</li>
</ul>
<p><code>returnAddress</code>现在用的比较少，较早的JVM使用这条指令实现异常处理，现在由异常表代替。</p>
<p><code>long</code>和<code>double</code>要求是64位，因此一般会占两个slot。对局部变量表的索引从0开始，以slot为单位，如果遇到连在一起的slot却分开用时应该抛出异常。JVM通过局部变量表来实现参数传递的，如果方法不是静态方法，那么会先把<code>this</code>传为第0号局部变量，之后的参数顺序写入。参数分配完后再根据方法体内部定义的变量顺序和作用域分配其余slot。</p>
<p>可以通过重复利用slot来节省栈帧空间，比如当前字节码PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的slot就可以交给其他变量使用。更进一步，如果之前的变量所在的slot被复写了，那么它所指的object就可以被回收，相反如果没被复写，即使超出了它的作用域也不一定会被及时回收。一个技巧是可以及时为变量赋值为<code>null</code>来加快GC。</p>
<p>最后，java不会为局部变量预设初始值，因此开发人员必须手动为局部变量设初值，否则编译不过，也通不过JVM字节码校验。</p>
<h3 id="操作数栈（operand-stack）"><a href="#操作数栈（operand-stack）" class="headerlink" title="操作数栈（operand stack）"></a>操作数栈（operand stack）</h3><p>用于进行具体运算，方法的Code属性的<code>max_stack</code>定义了操作数栈的最大深度，且单位也是slot。方法开始执行的时候操作数栈为空，随着方法运行会有各种入栈出栈操作，且操作数栈中的数据类型必须和字节码指令的序列严格匹配，不过这个是在编译期和校验期做的。</p>
<p>另外，理论上栈帧之间是完全独立的，实际上可以做一些优化，让两个栈帧部分重叠，这样就避免了额外的参数传递。</p>
<p><img src="/images/jvm_stack_share_vars.png" alt="两个栈帧之间数据共享"></p>
<h3 id="动态连接（dynamic-linking）"><a href="#动态连接（dynamic-linking）" class="headerlink" title="动态连接（dynamic linking）"></a>动态连接（dynamic linking）</h3><p>每个栈帧都包含一个指向常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态调用（dynamic linking）。C++是通过虚函数表来实现多态的，而JAVA则是通过先查找所属类、再解析符号引用/函数表来确定调用哪个方法。</p>
<h3 id="方法返回地址（Normal-Abrupt-Method-Invocation-Completion）"><a href="#方法返回地址（Normal-Abrupt-Method-Invocation-Completion）" class="headerlink" title="方法返回地址（Normal/Abrupt Method Invocation Completion）"></a>方法返回地址（Normal/Abrupt Method Invocation Completion）</h3><p>方法返回分为两种，一种是正常遇到返回指令结束方法调用，另一种是抛出异常且没有被正确处理（此时没有返回值）。无论如何退出，都需要在栈帧中保存一些信息，以便返回值上层调用位置。</p>
<p>方法退出时需要将栈帧出栈，需要恢复上层方法的局部变量表和操作数栈，将返回值（如果有）压入上层的操作数栈，调整PC计数器的值以指向方法调用指令后的一条指令等。</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>JVM允许添加一些附加信息到栈帧（比如调试信息），取决于JVM具体实现。一般把动态连接、方法返回地址和其他附加信息全部归位一类，称为栈帧信息。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用在方法执行之前，目的是找到应当调用哪个方法。由于class文件没有类似C的连接步骤，一切方法调用都是符号引用，因此需要先将符号引用解析为直接引用，而实际上可能需要在类加载期间、甚至在运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析（resolution）"><a href="#解析（resolution）" class="headerlink" title="解析（resolution）"></a>解析（resolution）</h3><p>首先，JVM提供了5中调用字节码的指令，分别是：</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用实例构造器<code>&lt;init&gt;</code>、私有方法、父类方法</li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</li>
</ul>
<p>在之前的章节提到过，类加载过程中有解析的步骤，其中会把一部分符号引用转换为直接引用，而能够转换的前提是在执行前就能确定是哪个方法，且在运行中不可变。符合这一条件的方法有：静态方法、私有方法、实例构造器、父类方法、final方法这几种。关于final方法，可以参考<a href="https://juejin.im/entry/58c4811161ff4b005d94fed2" target="_blank" rel="noopener">Final of Java，这一篇差不多了</a>，简单来说即final方法还是用<code>invokevirtual</code>调用，但可以在编译期确定，且可以被内联。</p>
<h3 id="分派（dispatch）"><a href="#分派（dispatch）" class="headerlink" title="分派（dispatch）"></a>分派（dispatch）</h3><p>解析调用可以在编译阶段唯一确定，而分派调用则可以是静态的或动态的，且根据宗量（argument，个人理解是方法签名）可以分为单分派和多分派，两两组合可以分为静态单分派、静态多分派、动态单分派、动态多分派。</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>编译期根据调用时的类型来确定使用哪个签名，值得注意的地方有两点：</p>
<ol>
<li>是编译器“看到”的参数类型，而不是实际类型。比如<code>foo((A)B)</code>和<code>foo(B)</code>可能调用了两个完全不同的方法。这个类型称为静态类型（static type）或外观类型（apparent type）</li>
<li>如果没有严格匹配的方法，那么编译器会尝试类型转换，选择一个更为“合适”的方法，比如对于<code>foo(char)</code>、<code>foo(int)</code>、<code>foo(Character)</code>、<code>foo(char...)</code>这几个方法时，如果输入参数是<code>&#39;a&#39;</code>，那么调用优先级依次降低。</li>
</ol>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派，Java的动态分派主要通过<code>invokevirtual</code>指令来实现，这个指令运行时解析过程大致分为以下几步：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C</li>
<li>从这个类开始，按照继承关系从下到上查找匹配的方法，如果找到则进行权限校验，通过则返回这个方法的直接引用，否则抛出<code>java.lang.illegalAccessError</code></li>
<li>如果一直没找到，则抛出<code>java.lang.AbstractMethodError</code></li>
</ol>
<h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><p>简单来说就是根据一个参数还是多个参数来进行分派（包括<code>this</code>）。事实上，java只支持静态多分派和动态单分派，即的动态分派只根据<code>this</code>来选择方法版本。C# 4.0后通过<code>dynamic</code>关键字可以支持动态多分配，参考<a href="https://chodounsky.net/2014/01/29/dynamic-dispatch-in-c-number/" target="_blank" rel="noopener">Dynamic Dispatch in C#</a>，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface IBar &#123;&#125;</span><br><span class="line">public class Bar : IBar &#123;&#125;</span><br><span class="line">public sealed class FooBar : Bar &#123;&#125;</span><br><span class="line"></span><br><span class="line">// Simple helper for demonstration</span><br><span class="line">public static class ConsolePrinter</span><br><span class="line">&#123;</span><br><span class="line">    public static void Print(IBar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;IBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Print(Bar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Print(FooBar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;FooBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new Bar();</span><br><span class="line">var foo = new FooBar();</span><br><span class="line">IBar ibar = new FooBar();</span><br><span class="line"></span><br><span class="line">IBar[] items = &#123; bar, foo, ibar &#125;;</span><br></pre></td></tr></table></figure>

<p>定义了三个不同的实例，放到同一个数组里，那么执行的结果应当是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach (var item in items)</span><br><span class="line">&#123;</span><br><span class="line">    ConsolePrinter.Print(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints IBar</span><br><span class="line">// prints IBar</span><br><span class="line">// prints IBar</span><br></pre></td></tr></table></figure>

<p>而如果在foreach循环中用dynamic来解释，结果就不同了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach (dynamic item in items)</span><br><span class="line">&#123;</span><br><span class="line">    ConsolePrinter.Print(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints Bar</span><br><span class="line">// prints FooBar</span><br><span class="line">// prints FooBar</span><br></pre></td></tr></table></figure>

<p>这意味着C#中会在运行时解析dynamic类型，拿到具体的对应类型后再决定方法签名，也就实现了动态多分派（虽然这个例子只有一个参数，还是单分配）</p>
<h4 id="动态分派的实现"><a href="#动态分派的实现" class="headerlink" title="动态分派的实现"></a>动态分派的实现</h4><p>理论上可以在运行时解析方法的符号链接，不过一般在实现中会用虚方法表（virtual method table, vtable，类似在<code>invokeinterface</code>时会用到interface method table, itable），如下图所示：</p>
<p><img src="/images/jvm_vtable.jpg" alt="JVM 虚方法表"></p>
<p>每个类维护了一个虚表，如果没有重写某个方法，就和父类的入口地址保持一致，这些可以在载入时实现。</p>
<h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>动态类型语言的关键特征是，它的类型检查的主体过程在运行期而非编译期。JVM中<code>invokespecial、invokevirtual、invokeinterface、invokestatic</code>的“参数”实际上都包含了“哪个类中的哪个方法”这一信息。比如<code>foo.bar()</code>这个调用，如果<code>foo</code>所声明的类型没有实现<code>bar()</code>方法，那么就无法编译通过；而在动态类型语言中，甚至可以不要求<code>bar()</code>被定义过都有可能正常执行，即使<code>foo</code>确实没定义过这个方法、也没有相关的语法糖，只要没执行到这条语句也不会报错。</p>
<p>JDK1.7后引入了<code>invokedynamic</code>指令和<code>java.lang.invoke</code>包，用以实现动态调用，而在JDK1.8里引入的lambda表达式使用了<code>invokedynamic</code>，具体可以参考<a href="https://colobu.com/2014/11/06/secrets-of-java-8-lambda/" target="_blank" rel="noopener">Java 8 Lambda 揭秘</a>和<a href="https://my.oschina.net/haogrgr/blog/367391" target="_blank" rel="noopener">JDK8中Lambda表达式底层实现浅析(一)</a>。在学习<code>invokedynamic</code>之前，需要先了解<code>MethodHandle</code>。</p>
<h4 id="MethodHandle"><a href="#MethodHandle" class="headerlink" title="MethodHandle"></a>MethodHandle</h4><p>简单来说<code>MethodHandle</code>有点像C/C++的函数指针，在此之前java为了实现函数指针需要用<code>interface</code>，而使用<code>interface</code>时需要先实例化一个类再调用这个类的某个方法，<code>MethodHandle</code>相对来说会“轻量级”一些，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"foo1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"foo2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? <span class="keyword">new</span> Foo1() : <span class="keyword">new</span> Foo2();</span><br><span class="line">    getPrintlnMH(obj).invokeExact();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">    <span class="keyword">return</span> MethodHandles.lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodHandles.lookup().findVirtual()</code>用以查找在指定类中符合给定方法签名且符合调用权限的方法句柄，并且由于这个方法不是静态方法，需要绑定<code>this</code>，所以要把<code>reveiver</code>传给<code>bindTo()</code>。</p>
<p>可以看到Foo1和Foo2之间没有继承关系，也可以通过方法签名找到并调用指定方法：这和反射有些相似，但反射（reflection）和MethodHandle实际区别很大：</p>
<ol>
<li>反射是在模拟java代码层次的方法调用，而MethodHandle是在模拟字节码层次的调用，比如<code>MethodHandles.lookup()</code>中的<code>findStatic()、findVirtual()、findSpecial()</code>分别对应字节码<code>invokestatic、invokevirtual&amp;invokeinterface、invokespecial</code>这几个字节码指令的执行权限调用行为，这在使用反射时不需要关心</li>
<li>反射中的<code>java.lang.reflect.Method</code>对象远比<code>MethodHandle</code>机制中的<code>java.lang.invoke.MethodHandle</code>对象所含的信息多，前者是方法在java一端的全面映像，包含了方法的签名、描述符、方法属性表中的各种属性的java端表示方式、执行权限等信息，而后者只包含与执行该方法相关的信息。</li>
<li>原则上由于<code>MethodHandle</code>是字节码调用的模拟，理论上可以在这方面做一些优化。</li>
<li>反射API设计目标是为java语言服务的，而<code>MethodHandle</code>则设计为可以为所有JVM支持的语言服务。</li>
</ol>
<h4 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h4><p>某种程度上<code>invokedynamic</code>和<code>MethodHandle</code>的目标类似，都是为了解决<code>invoke*</code>的分派规则由JVM决定的问题，让开发者有更高的查找目标方法的自由度。JDK1.8实现lambda表达式时使用了<code>invokedynamic</code>，下面是一段代码和它对应的反编译数据，生成的.class在<a href="/files/HelloWorld.class">这里</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    Runnable r = ()-&gt; System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">#1 = Methodref          #8.#27         // java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">   <span class="comment">#2 = InvokeDynamic      #0:#32         // #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">   <span class="comment">#3 = InterfaceMethodref #33.#34        // java/lang/Runnable.run:()V</span></span><br><span class="line">   <span class="comment">#4 = Fieldref           #35.#36        // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   <span class="comment">#5 = String             #37            // hello</span></span><br><span class="line">   <span class="comment">#6 = Methodref          #38.#39        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   <span class="comment">#7 = Class              #40            // HelloWorld</span></span><br><span class="line">   <span class="comment">#8 = Class              #41            // java/lang/Object</span></span><br><span class="line">   <span class="comment">#9 = Utf8               &lt;init&gt;</span></span><br><span class="line">  <span class="comment">#10 = Utf8               ()V</span></span><br><span class="line">  <span class="comment">#11 = Utf8               Code</span></span><br><span class="line">  <span class="comment">#12 = Utf8               LineNumberTable</span></span><br><span class="line">  <span class="comment">#13 = Utf8               LocalVariableTable</span></span><br><span class="line">  <span class="comment">#14 = Utf8               this</span></span><br><span class="line">  <span class="comment">#15 = Utf8               LHelloWorld;</span></span><br><span class="line">  <span class="comment">#16 = Utf8               main</span></span><br><span class="line">  <span class="comment">#17 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#18 = Utf8               args</span></span><br><span class="line">  <span class="comment">#19 = Utf8               [Ljava/lang/String;</span></span><br><span class="line">  <span class="comment">#20 = Utf8               r</span></span><br><span class="line">  <span class="comment">#21 = Utf8               Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#22 = Utf8               Exceptions</span></span><br><span class="line">  <span class="comment">#23 = Class              #42            // java/lang/Throwable</span></span><br><span class="line">  <span class="comment">#24 = Utf8               lambda$main$0</span></span><br><span class="line">  <span class="comment">#25 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#26 = Utf8               HelloWorld.java</span></span><br><span class="line">  <span class="comment">#27 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span></span><br><span class="line">  <span class="comment">#28 = Utf8               BootstrapMethods</span></span><br><span class="line">  <span class="comment">#29 = MethodHandle       #6:#43         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#30 = MethodType         #10            //  ()V</span></span><br><span class="line">  <span class="comment">#31 = MethodHandle       #6:#44         // invokestatic HelloWorld.lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#32 = NameAndType        #45:#46        // run:()Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#33 = Class              #47            // java/lang/Runnable</span></span><br><span class="line">  <span class="comment">#34 = NameAndType        #45:#10        // run:()V</span></span><br><span class="line">  <span class="comment">#35 = Class              #48            // java/lang/System</span></span><br><span class="line">  <span class="comment">#36 = NameAndType        #49:#50        // out:Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#37 = Utf8               hello</span></span><br><span class="line">  <span class="comment">#38 = Class              #51            // java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#39 = NameAndType        #52:#53        // println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#40 = Utf8               HelloWorld</span></span><br><span class="line">  <span class="comment">#41 = Utf8               java/lang/Object</span></span><br><span class="line">  <span class="comment">#42 = Utf8               java/lang/Throwable</span></span><br><span class="line">  <span class="comment">#43 = Methodref          #54.#55        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#44 = Methodref          #7.#56         // HelloWorld.lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#45 = Utf8               run</span></span><br><span class="line">  <span class="comment">#46 = Utf8               ()Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#47 = Utf8               java/lang/Runnable</span></span><br><span class="line">  <span class="comment">#48 = Utf8               java/lang/System</span></span><br><span class="line">  <span class="comment">#49 = Utf8               out</span></span><br><span class="line">  <span class="comment">#50 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#51 = Utf8               java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#52 = Utf8               println</span></span><br><span class="line">  <span class="comment">#53 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#54 = Class              #57            // java/lang/invoke/LambdaMetafactory</span></span><br><span class="line">  <span class="comment">#55 = NameAndType        #58:#62        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#56 = NameAndType        #24:#10        // lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#57 = Utf8               java/lang/invoke/LambdaMetafactory</span></span><br><span class="line">  <span class="comment">#58 = Utf8               metafactory</span></span><br><span class="line">  <span class="comment">#59 = Class              #64            // java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  <span class="comment">#60 = Utf8               Lookup</span></span><br><span class="line">  <span class="comment">#61 = Utf8               InnerClasses</span></span><br><span class="line">  <span class="comment">#62 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#63 = Class              #65            // java/lang/invoke/MethodHandles</span></span><br><span class="line">  <span class="comment">#64 = Utf8               java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  <span class="comment">#65 = Utf8               java/lang/invoke/MethodHandles</span></span><br><span class="line">&#123;</span><br><span class="line">  public HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LHelloWorld;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.Throwable;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: invokedynamic <span class="comment">#2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">         5: astore_1</span><br><span class="line">         6: aload_1</span><br><span class="line">         7: invokeinterface <span class="comment">#3,  1            // InterfaceMethod java/lang/Runnable.run:()V</span></span><br><span class="line">        12: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 6</span><br><span class="line">        line 5: 12</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      13     0  args   [Ljava/lang/String;</span><br><span class="line">            6       7     1     r   Ljava/lang/Runnable;</span><br><span class="line">    Exceptions:</span><br><span class="line">      throws java.lang.Throwable</span><br><span class="line"></span><br><span class="line">  private static void lambda<span class="variable">$main</span><span class="variable">$0</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line">         0: getstatic     <span class="comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         3: ldc           <span class="comment">#5                  // String hello</span></span><br><span class="line">         5: invokevirtual <span class="comment">#6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"HelloWorld.java"</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     public static final <span class="comment">#60= #59 of #63; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: <span class="comment">#29 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">    Method arguments:</span><br><span class="line">      <span class="comment">#30 ()V</span></span><br><span class="line">      <span class="comment">#31 invokestatic HelloWorld.lambda$main$0:()V</span></span><br><span class="line">      <span class="comment">#30 ()V</span></span><br></pre></td></tr></table></figure>

<p><code>invokedynamic</code>的操作形式是<code>invokedynamic indexbyte1 indexbyte2 0 0</code>，其中后两个0是写死的以便之后扩展，前两个参数联合起来<code>(indexbyte1 &lt;&lt; 8) | indexbyte2</code>指向常量池中的一项被称为动态调用点（call site）的符号引用，这里为字节码为<code>ba 0002 00 00</code>，即CallSite为第二个常量，其结构体声明为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_InvokeDynamic_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 bootstrap_method_attr_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>bootstrap_method_attr_index</code>指向了<code>bootstrap_methods</code>数组中的某个<code>bootstrap method</code>，从反编译出的信息可以看到这个<code>invokedynamic</code>的字节码指令为<code>12 0000 0020</code>，标明它的引导方法是第0个，方法类型参考第32个常量<code>run:()Ljava/lang/Runnable;</code>。引导方法<code>Bootstrap Method</code>被保存在新增的<code>BootstrapMethods</code>属性中，其完整定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 num_bootstrap_methods;</span><br><span class="line">    &#123;   u2 bootstrap_method_ref;</span><br><span class="line">        u2 num_bootstrap_arguments;</span><br><span class="line">        u2 bootstrap_arguments[num_bootstrap_arguments];</span><br><span class="line">    &#125; bootstrap_methods[num_bootstrap_methods];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里相关的二进制代码为<code>1c 00 00 00 0c 00 01 00 1d 00 03 00 1e 00 1f 00 1e</code>，表示只有一个引导方法，对应的<code>MethodHandle</code>为<code>java/lang/invoke/LambdaMetafactory.metafactory</code>这一静态方法，其完整签名为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">metafactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MethodHandles.Lookup caller, // 代表查找上下文与调用者的访问权限, 使用invokedynamic指令时, JVM会自动自动填充这个参数, 这里JVM为我们填充为Lookup(HelloWorld.class, (PUBLIC | PRIVATE | PROTECTED | PACKAGE)</span>) 意思是这个Lookup实例可以访问HelloWorld类的所有成员.</span></span><br><span class="line"><span class="function">    String invokedName,  <span class="comment">//  要实现的方法的名字, 使用invokedynamic时, JVM自动帮我们填充(填充内容来自常量池InvokeDynamic.NameAndType.Name), 这里填充为run</span></span></span><br><span class="line"><span class="function">    MethodType invokedType,  <span class="comment">// 调用点期望的方法参数的类型和返回值的类型(方法signature). 使用invokedynamic指令时, JVM会自动自动填充这个参数，填充内容来自常量池InvokeDynamic.NameAndType.Type), 在这里参数为空, 返回值类型为java/lang/Runnable, 表示这个调用点的目标方法的参数为空, 然后invokedynamic执行完后会返回一个Runnable实例</span></span></span><br><span class="line"><span class="function">    MethodType samMethodType,  <span class="comment">// 函数对象将要实现的接口方法类型, 这里运行时, 值为()V，即Runnable.run()方法的类型</span></span></span><br><span class="line"><span class="function">    MethodHandle implMethod, <span class="comment">// 一个直接方法句柄(DirectMethodHandle), 描述在调用时将被执行的具体实现方法 (包含适当的参数适配, 返回类型适配,和在调用参数前附加上捕获的参数), 在这里为 HelloWorld.lambda$main$0:()V 方法的方法句柄. </span></span></span><br><span class="line"><span class="function">    MethodType instantiatedMethodType) <span class="comment">// 函数接口方法替换泛型为具体类型后的方法类型, 通常和samMethodType一样，除非发生了类型擦除</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> LambdaConversionException</span></span><br></pre></td></tr></table></figure>

<p>在执行<code>invokedynamic</code>时会执行其关联的引导方法，前三个参数由JVM自动填充，后三个参数来自属性表中的<code>bootstrap_arguments</code>。可以看到，lambda表达式的具体实现被编译成了<code>HelloWorld.lambda$main$0:()V</code>这样一个静态方法。执行完引导方法后，会返回一个<code>CallSite</code>对象，它的<code>target</code>属性关联了所调用的方法句柄，最后执行这个方法句柄。</p>
<p>值得一提的是，lambda表达式只是在“生成”的时候调用了<code>invokedynamic</code>，比如上面那个例子，即使没有<code>r.run();</code>这句，也会产生一条<code>invokedynamic</code>指令，换句话说实际上这里<code>invokedynamic</code>产生了一个<code>Runnable</code>对象，然后把它赋值到了一个局部变量。</p>
<h2 id="基于栈的字节码解释引擎"><a href="#基于栈的字节码解释引擎" class="headerlink" title="基于栈的字节码解释引擎"></a>基于栈的字节码解释引擎</h2><p>这段内容其实没啥好说的，举个例子，比如这样一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">4</span>;</span><br><span class="line">c = (a-c)*b;</span><br></pre></td></tr></table></figure>

<p>会翻译为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_1</span><br><span class="line">1: istore_1</span><br><span class="line">2: iconst_2</span><br><span class="line">3: istore_2</span><br><span class="line">4: iconst_4</span><br><span class="line">5: istore_3</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_3</span><br><span class="line">8: isub</span><br><span class="line">9: iload_2</span><br><span class="line">10: imul</span><br><span class="line">11: istore_3</span><br></pre></td></tr></table></figure>

<p>意思是把常量1入栈，出栈后保存到局部变量1；常量2入栈，出栈后保存到局部变量2；常量4入栈，出栈后保存到局部变量3；局部变量1和3分别入栈，出栈两个int、相减后入栈，将变量2入栈，出栈两个变量、相乘后出栈，此时栈里只有一个int（-6），最后出栈并保存到变量3。</p>
<p>可以看出真的这么跑的化执行效率很低，一般JVM都会对此进行优化。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/06/jvm5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/06/jvm5/" class="post-title-link" itemprop="url">JVM学习（5）类加载机制</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-06T00:00:00+08:00">2019-09-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-09 16:11:25" itemprop="dateModified" datetime="2019-09-09T16:11:25+08:00">2019-09-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有了.class文件后，还需要一系列步骤加载进JVM才能运行。简单来说，一个类从被加载至JVM，到卸载出内存为止，整个生命周期包括加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）、卸载（unloading）7个阶段。其中验证、准备、解析三个部分称为连接（linking），顺序如下图所示。</p>
<p><img src="/images/jvm_class_lifecycle.png" alt="类的生命周期"></p>
<p>JVM没有规定什么时候开始加载，但规定了5种情况必须对类进行初始化：</p>
<ol>
<li>遇到<code>new、getstatic、putstatic、invokestatic</code>这四条指令码。比如new一个对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法的时候。</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时</li>
<li>初始化一个类时，需要先初始化其父类</li>
<li>虚拟机启动时，用户指定的主类需要先被初始化</li>
<li>使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic、REF_putStatic、REF_invokeStatic</code>的方法句柄对应的类需要初始化</li>
</ol>
<p>这五种场景中的行为称为对一个类的主动引用，除此之外的引用类的方式都不会触发初始化，称为被动引用，比如</p>
<ol>
<li>通过子类引用父类的静态字段，不会触发子类的初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化（如<code>SomeClass[] arr= new SomeClass[];</code>）</li>
<li>引用某个类的静态常量</li>
</ol>
<p>其中2虽然不会导致这个类的初始化，但会触发一个<code>[Lorg.fenixsoft.classloading.SomeClass</code>的类初始化，它由JVM自动生成、直接继承自<code>java.lang.Object</code>，由newarray触发，代表了一个元素类型为<code>org.fenixsoft.classloading.SomeClass</code>的一维数组，数组中应有的属性和方法（如<code>length、clone</code>）都实现在这个类。Java中对数组的访问会使用这个类提供的方法（底层使用了<code>xaload、xastore</code>等指令保证不会越界），所以相对<code>C/C++</code>安全。</p>
<p>此外，接口在初始化时不要求父接口全部完成初始化，只有在真正使用父接口的时候（如引用接口中定义的常量）才会初始化。并且接口也会生成<code>&lt;cinit&gt;</code>的类构造器，用于初始化接口中定义的成员变量。</p>
<h2 id="加载（loading）"><a href="#加载（loading）" class="headerlink" title="加载（loading）"></a>加载（loading）</h2><p>加载阶段JVM需要做以下事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>常见的获取二进制字节流的方式有：</p>
<ol>
<li>从.class文件直接获得</li>
<li>从zip包中获得，比如JAR,EAR,WAR</li>
<li>从网络中获得，比如Applet</li>
<li>运行时计算生成，比如动态代理，java.lang.reflect.Proxy就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为”$Proxy”的代理类的二进制字节流</li>
<li>由其他文件生成，比如JSP</li>
<li>从数据库中读取<br>…</li>
</ol>
<p>除了获得字节流的方式外，开发人员还可以自定义个一个ClassLoader去控制如何读取字节流。</p>
<p>数组类比较特殊，它是由JVM直接创建的，一个数组类（简称为C）的创建过程需要遵循以下规则：</p>
<ol>
<li>如果数组的组件类型（Component Type，指数组去掉一个维度后的类型）是引用类型，则递归的加载这个组件类型，之后数组C将在这个组件类型所属的ClassLoader的类命名空间上被标志</li>
<li>如果组件类型不是引用类型，则会标识与Bootstrap Classloader关联。</li>
<li>数组类的可见性与它的组件的可见性保持一致，如果组件类型不是引用类型，则默认为public</li>
</ol>
<p>加载完成后，JVM外部的二进制字节流就按虚拟机所需的格式存储在方法区之中，方法区中的数据格式由JVM自行定义。然后在内存中实例化一个java.lang.Class对象（HotSpot将这个对象放在了方法区），这个对象将作为程序访问方法区中这些类型数据的外部接口。</p>
<h2 id="验证（verification）"><a href="#验证（verification）" class="headerlink" title="验证（verification）"></a>验证（verification）</h2><p>简单来说就是确保这些二进制字节流格式符合JVM规范，且不会对JVM有危害。</p>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>检验其是否符合Class文件规范，且能被当前JVM兼容，包括</p>
<ol>
<li>以<code>0xcafebabe</code>开头</li>
<li>主、次版本号能否被JVM兼容</li>
<li>常量池中的常量是否有不被支持的类型（检查常量tag标志）</li>
<li>指向常量的各种索引值中是否有指向不存在或不符合类型的常量</li>
<li><code>CONSTANT_Utf8_info</code>类型的常量中是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除或附加的其他信息<br>…</li>
</ol>
<p>只有经过文件格式验证后的字节流才会保存到方法区，后面三个验证阶段全部基于方法区的数据，不会直接操作字节流</p>
<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>确保Class数据描述的语义符合java语言规范要求，包括</p>
<ol>
<li>这个类是否有父类（除了<code>java.lang.Object</code>都应该有父类）</li>
<li>这个类是否继承了一个<code>final</code>类</li>
<li>如果这个类不是<code>abstract</code>，那么是否实现了所有父类/接口中要求实现的方法</li>
<li>类中的字段、方法是否与父类矛盾（如覆盖了父类的<code>final</code>字段、不符合规则的方法重载）<br>…</li>
</ol>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>验证操作码，包括</p>
<ol>
<li>确保任意时刻操作数栈的数据类型和指令代码序列都能配合工作，例如不会出现按<code>long</code>去读一个<code>int</code></li>
<li>确保跳转指令不会跳转到方法体以外的字节码上</li>
<li>确保方法体中的类型转换是有效的<br>…</li>
</ol>
<p>JDK1.6后为<code>Code</code>属性的属性表引入了一个<code>StackMapTable</code>属性，描述了方法体中所有基本块开始时本地变量表和操作栈应有的状态，那么验证期间只要检查<code>StackMapTable</code>属性即可，不需要重新推导这部分信息。JDK1.7后要求主版本号超过50的只能用这种形式。</p>
<p>（其实很奇怪，既然要验证就说明不信任代码提供方，那怎么能把一部分验证工作放在代码提供方呢？只能说JVM设计者认为代码提供方都是善意的，但工作做的比较糙，编译出来的东西不靠谱）</p>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>符号引用验证发生在解析之后，目的是检查对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，包括</p>
<ol>
<li>符号引用中的全限定名能否找到对应的类</li>
<li>指定类中有无描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性（<code>private、protected、public、default</code>）是否可以被当前类访问<br>…</li>
</ol>
<p>验证过程可以用<code>-XVerify:none</code>来取消</p>
<h2 id="准备（preparation）"><a href="#准备（preparation）" class="headerlink" title="准备（preparation）"></a>准备（preparation）</h2><p>准备阶段主要用来为类变量（被static修饰）分配内存（一般在方法区）并设置初始值，且初始值为0。比如<code>public static int value = 123;</code>这个变量在准备阶段过后的初始值为0，而在初始化后才被赋值为123。</p>
<p>如果类字段的属性表包含<code>ConstantValue</code>属性，那么准备阶段就会把变量定义为所指定的值。</p>
<h2 id="解析（resolution）"><a href="#解析（resolution）" class="headerlink" title="解析（resolution）"></a>解析（resolution）</h2><p>解析的目的是为了将常量池中的符号引用替换为直接引用的过程，</p>
<ul>
<li>符号引用（Symbolic References）：以一组符号来描述所引用的目标，符合可以是任何形式的字面量，只要在使用时能无歧义的定位到目标即可<ul>
<li>符号引用与JVM实现的内存布局无关</li>
<li>引用的目标不一定已被加载到内存</li>
<li>各种JVM的内存布局可以各不相同，但能接受的符号引用必须都是一致的</li>
</ul>
</li>
<li>直接引用（Direct References）：可以是直接指向目标的指针、相对偏移量或句柄<ul>
<li>与JVM内部实现相关</li>
<li>不同JVM的直接引用形式一般不同</li>
<li>如果有直接引用，那么引用目标一定在内存</li>
</ul>
</li>
</ul>
<p>JVM规范没有规定解析阶段发生的具体时间，只要求在执行<code>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic</code>这16个用于操作符号引用的字节码指令前，先对符号引用进行解析。所以JVM可以选择在加载的时候就解析还是在使用的时候才解析。JVM要求除<code>invokedynamic</code>外，在同一个实体中，如果一个符号引用被成功解析，那么之后也要能够成功解析；如果第一次解析失败，那么之后也应该收到同样的异常。而<code>invokedynamic</code>必须要等到实际执行时再解析，这条指令在JDK1.7中被引入，JDK1.8开始用来实现lambda表达式。</p>
<p>解析主要针对类或接口（CONSTANT_Class_info）、字段（CONSTANT_Fieldref_info）、类方法（CONSTANT_Methodref_info）、接口方法（CONSTANT_InterfaceMethodref_info）、方法类型（CONSTANT_MethodType_info）、方法句柄（CONSTANT_MethodHandle_info）、调用点（CONSTANT_Dynamic_info）这7类符号引用进行，后三种和动态调用相关，这里只解释前4种：</p>
<h3 id="类或接口"><a href="#类或接口" class="headerlink" title="类或接口"></a>类或接口</h3><p>假设当前代码所处的类为D，需要解析一个类或接口C的符号引用N，需要</p>
<ol>
<li>如果C不是一个数组类型，那么JVM会把N传给D的ClassLoader去加载C。</li>
<li>如果C是数组类型，且数组的组建类型是对象，那么会加载其组建类型，然后由JVM生成一个代表此数组维度和元素的数组对象。</li>
<li>在进行了1或2后，C已经在JVM中称为一个有效的类或接口了，然后验证D是否有对C的访问权限，没有则抛出异常</li>
</ol>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>解析字段的符号引用，首先要解析字段表里class_index项索引的<code>CONSTANT_Class_info</code>符号引用，解析成功后，假设这个类/接口是C，</p>
<ol>
<li>如果C本身就包含了包含简单名称和字段描述符都与目标项匹配的字段，则返回这个字段的直接引用</li>
<li>如果C中实现了接口，那么按照继承关系从下往上递归搜索各个接口和它的父接口，如果找到则返回</li>
<li>如果C不是<code>java.lang.Object</code>，那么会从下向上递归搜索其父类，如果找到则返回</li>
<li>都没找到则表示查找失败，返回<code>java.lang.NoSuchFieldError</code></li>
</ol>
<p>如果查找过程中返回了引用，但没有访问权限，也会抛出异常</p>
<p>如果一个同名字段同时出现在父类和子类，那么编译器可能会拒绝编译</p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>与字段解析类似，需要先解析所属的类/接口C，然后</p>
<ol>
<li>如果C是个接口，则报错<code>java.lang.IncompatibleClassChangeError</code></li>
<li>从下往上递归查找C和C的父类，如果找到相匹配的方法则返回</li>
<li>递归查找C的接口，如果找到相匹配的方法，说明C是个抽象类，抛出<code>java.lang.AbstractMethodError</code></li>
<li>查找失败，报错<code>java.lang.NoSuchMethodError</code></li>
</ol>
<p>最后会验证其访问权限</p>
<h3 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h3><p>与类方法解析类似，但需要保证C是个接口</p>
<ol>
<li>如果C不是接口，则报错<code>java.lang.IncompatibleClassChangeError</code></li>
<li>递归查找C和C的父接口，直到<code>java.lang.Object</code>，如果找到则返回</li>
<li>没找到报错<code>java.lang.NoSuchMethodError</code></li>
</ol>
<p>理论上接口方法都是<code>public</code>，所以应当不出现<code>java.lang.IllegalAccessError</code></p>
<h2 id="初始化（initialization）"><a href="#初始化（initialization）" class="headerlink" title="初始化（initialization）"></a>初始化（initialization）</h2><p>直到初始化阶段才开始执行自定义的java代码， 也就是<code>&lt;cinit&gt;()</code>方法</p>
<ol>
<li><code>&lt;cinit&gt;()</code>由所有类变量的赋值动作和静态语句块<code>static{}</code>中的语句合并而成，顺序由源文件顺序而定，且<code>static{}</code>只能访问到定义在之前的变量</li>
<li><code>&lt;cinit&gt;()</code>不需要显式的调用父类的<code>&lt;cinit&gt;()</code>，JVM会保证父类的肯定先执行完毕</li>
<li>如果没有相关代码，可以不生成<code>&lt;cinit&gt;()</code>语句</li>
<li>接口不能使用静态语句块，但也有变量初始化操作，故也会生成<code>&lt;cinit&gt;()</code>，但执行<code>&lt;cinit&gt;()</code>时不需要先执行父类的<code>&lt;cinit&gt;()</code>。同样的，接口的实现类初始化时也不会执行接口的<code>&lt;cinit&gt;()</code></li>
<li>JVM会保证<code>&lt;cinit&gt;()</code>能被正确加锁，这也意味着可能多个线程卡在某个类的<code>&lt;cinit&gt;()</code>上</li>
</ol>
<h2 id="类加载器（ClassLoader）"><a href="#类加载器（ClassLoader）" class="headerlink" title="类加载器（ClassLoader）"></a>类加载器（ClassLoader）</h2><p>从JVM的角度讲，只有两类加载器：一类是使用C++实现的启动类加载器<code>Bootstrap ClassLoader</code>，是JVM的一部分；另一种是其他的类加载器，由JAVA语言实现，独立于JVM，且全继承了<code>java.lang.ClassLoader</code>。</p>
<p>有三个系统提供的类加载器比较常见：</p>
<ol>
<li>启动类加载器（<code>Bootstrap ClassLoader</code>）：负责将<code>$JAVA_HOME/lib</code>中或<code>-Xbootclasspath</code>路径下，能被JVM识别的类库加载到JVM内存中，无法被java程序直接引用。用户自定义<code>ClassLoader</code>时需要需要<code>Bootstrap ClassLoader</code>加载，可以直接用<code>null</code>代替。</li>
<li>扩展类加载器（<code>Extension ClassLoader</code>）：由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>$JAVA_HOME/lib/ext</code>或<code>java.ext.dirs</code>系统变量所指定的路径下的所有类库，开发者也可以直接使用这个类加载器</li>
<li>应用程序加载器（<code>Application ClassLoader</code>）：由<code>sun.misc.Launcher$AppClassLoader</code>实现，负责加载用户类路径<code>ClassPath</code>上所指定的类库，也是<code>getSystemClassLoader()</code>方法的返回值，故一般也称为系统类加载器，开发者可以直接使用，默认的类加载器</li>
</ol>
<p>每一个类加载器都拥有一个独立的类名称空间，也就是说判断两个Class是否相等（包括<code>Class.equals(), isAssignableFrom(), isInstance()</code>的返回值）要判断两个<code>ClassLoader</code>是否相等。</p>
<p>开发人员也可以自定义类加载器，一般来说类加载器都应当有自己的父类加载器，且使用双亲委派模型（<code>Parents Delegation Model</code>）来复用父加载器代码：尽可能尝试让父类加载器去加载这个类。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/02/jvm4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/02/jvm4/" class="post-title-link" itemprop="url">JVM学习（4）类文件结构</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-02T00:00:00+08:00">2019-09-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-05 18:24:17" itemprop="dateModified" datetime="2019-09-05T18:24:17+08:00">2019-09-05</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为了实现“Write Once, Run Anywhere”，JVM支持运行.class格式的字节码文件，这样可以保证JVM的平台无关性和语言无关性：即不管什么语言，只要能编译为符合规范的.class文件，就可以在JVM上运行。</p>
<h2 id="class类文件结构"><a href="#class类文件结构" class="headerlink" title="class类文件结构"></a>class类文件结构</h2><p>任何一个class文件都对应着唯一一个类或接口的定义信息。当然一来JVM可以动态生成class，不一定每个类都对应着一个.class文件；二来一个java源代码里可以定义多个类，每个类（包括子类）实际上都会生成一个.class文件。</p>
<p>一个典型的class文件分为：MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes这十个部分：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td align="center">magic</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">minor_version</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">major</td>
<td align="center">_version</td>
</tr>
<tr>
<td>u2</td>
<td align="center">constant_pool_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>cp_info</td>
<td align="center">constant_pool</td>
<td align="center">constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">this_class</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">super_class</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">interfaces_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">interfaces</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td align="center">fields_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>field_info</td>
<td align="center">fields</td>
<td align="center">fields_count</td>
</tr>
<tr>
<td>u2</td>
<td align="center">methods_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>method_info</td>
<td align="center">methods</td>
<td align="center">methods_count</td>
</tr>
<tr>
<td>u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<p>其中u1, u2, u4,u8分别表示1、2、4、8字节长度的标量，且以big-endian的方式保存。</p>
<p>不定长的区域，比如constant_pool，method_info等，基本都是count+info[count]这种形式。</p>
<p>先写一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> hello1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHello1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hello1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Child</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3911120229867216339L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> hello2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHello2</span><span class="params">(<span class="keyword">int</span> hello2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hello2 = hello2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hello2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Child o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hello2 - o.hello2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这段代码编译后生成两个class文件，这里只分析<a href="/files/Child.class">Child.class</a>。可以先用<code>javap -v -p -s -sysinfo -constants Child</code>看一下基本框架。然后依次分析每个区域。</p>
<h2 id="Magic-Numbers和版本号"><a href="#Magic-Numbers和版本号" class="headerlink" title="Magic Numbers和版本号"></a>Magic Numbers和版本号</h2><p>魔数，.class文件必须以0xcafebabe开头，这个跟.jpeg之类的文件类似。</p>
<p>接下来4个字节是版本号，其中后两个字节是主版本号，这里是0x0031，对应JDK1.5.0_11版本。一般高版本的JVM兼容低版本的.class文件，但反过来不行。</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>接下来是常量池（constant pool）部分，2字节的数字表示一共有多少个常量，接下来一共有constant_pool_count-1个实际常量。这里一共有0x002a-1=42-1=41个常量。且常量池索引以1开始，0被用来表示“不引用任何一个常量池项目”。</p>
<p>常量池主要包含两部分：字面量（literal）和符号引用（symbolic references）。字面量比如文本字符串、声明为final的常量值等。符号引用包含三部分：</p>
<ul>
<li>类和接口的全限定名（full qualified name）</li>
<li>字段的名称和描述符（descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>每个常量以1字节的类型描述开始，然后按这个类型定义的表去填充数据，具体参考<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">The class File Format</a>。以刚才编译好的.class文件为例，跳过重复的类型，大概有以下几个部分：</p>
<ul>
<li>第1个常量是<code>0a 0006 0023</code>，对应CONSTANT_Methodref_info，两个index分别指向第6和第35个常量，表明这个方法在第6个常量表示的类（Base），具体的名称和描述符参考第35个常量（<code>&quot;&lt;init&gt;&quot;:()V</code>）</li>
<li>第2个常量是<code>09 0004 0024</code>，对应CONSTANT_Fieldref_info，与CONSTANT_Methodref_info类似，表明这个字段在第4个常量表示的类（Child），具体的名称和描述符参考第36个常量（<code>hello2:I</code>）</li>
<li>第4个常量是<code>07 0026</code>，对应CONSTANT_Class_info，这个类的名称指向第38个常量，这个常量是个字符串，值为<code>Child</code></li>
<li>第8个常量是<code>01 0010 73657269616c56657273696f6e554944</code>，对应CONSTANT_Utf8_info，是一个utf8字符串，此字符串长为16（32字节），用python3的<code>bytes.fromhex(&quot;73657269616c56657273696f6e554944&quot;)</code>解码得到字符串是<code>serialVersionUID</code></li>
<li>第11个常量是<code>05 c9b8e8df78eba22d</code>，对应CONSTANT_Long_info，是一个long型常量，对应十进制数字为<code>-3911120229867216339</code></li>
<li>第35个常量是<code>0c 000f 0010</code>，对应CONSTANT_NameAndType_info，表示它的名字为第15个常量（<code>&lt;init&gt;</code>），类型为第16个常量<code>()V</code></li>
</ul>
<p>总的来说常量池还是以字符串、数字为主。</p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池结束后是两个字节的访问标志，用以声明这个类/接口/注解…的访问类型。这个类是0x0021，为<code>ACC_PUBLIC|ACC_SUPER</code>，ACC_PUBLIC容易理解，即这个类声明为public的；而ACC_SUPER主要是为了向下兼容，因为invokespecial这个指令的语义在JDK1.0.2发生过变化（可以参考<a href="https://blog.csdn.net/xinaij/article/details/38872851" target="_blank" rel="noopener">ACC_SUPER和早期的invokespecial</a>），那么新版JDK编译出来的类都需要带上这个flag。</p>
<h2 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h2><p>还是指向常量池的信息，这里类是第4个常量（Child类），父类是第6个常量（Base类）。由于所有java class都至少有个一个基类Object，故父类索引一定不为0。</p>
<p>这个类的接口集合大小为1，之后是一系列2字节的常量索引（长度为1），可以看到Child类继承了7号常量描述的接口（java/lang/Comparable）。</p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>相比于接口，字段包含的信息比较多，除了名字和类型外，还包含诸如是否被static、final、public、volatile等修饰符修饰等信息。因此一个字段被定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">  u2 access_flags;</span><br><span class="line">  u2 name_index;</span><br><span class="line">  u2 descriptor_index;</span><br><span class="line">  u2 attributes_count;</span><br><span class="line">  attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里一共有2个字段，第一个字段为<code>001A 0008 0009 0001 000A 00000002 000B</code>，被声明为<code>0x1A=ACC_PRIVATE|ACC_STATIC|ACC_FINAL</code>，名称为第8个常量（字符串<code>serialVersionUID</code>），描述符为第9个常量（字符串<code>J</code>，表示基本类型long）。</p>
<p>所谓描述符(descriptor)是描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）和返回值。基本类型和void都用一个大写字母表示，而对象用L+对象的全限定名来表示，比如<code>Ljava/lang/Object;</code>（一般全限定名后加个分号以示区分）。数组则是加个<code>[</code>，比如<code>[[Ljava/lang/String;</code>表示<code>String[][]</code>这样的二位数组，<code>[I</code>表示<code>int[]</code>这样的int数组。描述方法时，先写参数列表，后写返回值。例如方法<code>int indexOf(char[] source, int sourceOffset, char[] target, int targetOffset, int targetCount, int from Index)</code>的描述符为<code>([CII[CIII]])I</code>。</p>
<p>最后，这个字段包含1个属性（attribute），属性用来保存一些额外信息，每个attribute_info被定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个字段有一个attribute_info，name为第10个常量<code>ConstantValue</code>，其内容长为2字节，但需要联合起来表示指向第11个常量(一个long型的数字-3911120229867216339l)。</p>
<p>第二个字段为<code>0082 000D 000E 0000</code>，被声明为<code>0x82=ACC_PRIVATE|ACC_TRANSIENT</code>，名称为第13个常量<code>hello2</code>，描述符为第14个常量<code>I</code>，没有额外属性。</p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>方法表和字段表结构很类似，不过由于字段和方法的访问标志不太一样，所以实际含义不太一样。此外方法表一般会有一个属性指向Code类型，需要参考属性集合表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">     u2 access_flags;</span><br><span class="line">     u2 name_index;</span><br><span class="line">     u2 descriptor_index;</span><br><span class="line">     u2 attributes_count;</span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Child里有6个方法，如下表所示，其中bridge表示这个方法是桥接方法，synthetic表示这个方法由编译器生成。</p>
<table>
<thead>
<tr>
<th>二进制码</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>0001 000f 0010 0001 0011 0000002f...</code></td>
<td><code>public &lt;init&gt; ()V</code></td>
</tr>
<tr>
<td><code>0001 0016 0017 0001 0011 0000003e...</code></td>
<td><code>public setHello2 (I)V</code></td>
</tr>
<tr>
<td><code>0001 0018 0019 0001 0011 0000002f...</code></td>
<td><code>public getHello2 ()I</code></td>
</tr>
<tr>
<td><code>0001 001a 001b 0001 0011 0000003e...</code></td>
<td><code>public compareTo (LChild;)I</code></td>
</tr>
<tr>
<td><code>1041 001d 0019 0001 0011 0000002f...</code></td>
<td><code>public bridge synthetic getHello1 ()I</code></td>
</tr>
<tr>
<td><code>1041 001a 001e 0001 0011 00000033...</code></td>
<td><code>public bridge synthetic compareTo (Ljava/lang/Object;)I</code></td>
</tr>
</tbody></table>
<p>JSL对<a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html" target="_blank" rel="noopener">bridge method</a>的定义为：</p>
<blockquote>
<p>When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, called a bridge method, as part of the type erasure process. You normally don’t need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.</p>
</blockquote>
<p>比较奇怪的是<code>getHello1</code>也生成了一个桥接方法，我在网上查到的说法是只有类型擦除的时候才会生成bridge method，但实际上我试下来只要Child继承了Base，无论是否继承了Comparable，都会生成一个bridge的<code>getHello1()</code>。看了下反编译后的字节码，似乎bridge方法都会invokespecial/invokevirtual另一个方法，也就是说会把具体实现代理到其他方法去。</p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>可以看出，每个方法都有一个Code类型的属性，实际上的字节码也保存在这个属性里。之前也提到过一个ConstantValue属性。JVM对属性的规定比较宽泛，也允许编译器向属性表写入自己定义的属性信息。这里只记录一些常见的属性。</p>
<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>完整的Code_attribute定义如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 max_stack;</span><br><span class="line">    u2 max_locals;</span><br><span class="line">    u4 code_length;</span><br><span class="line">    u1 code[code_length];</span><br><span class="line">    u2 exception_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上一节中的<code>compareTo (LChild;)I</code>方法为例，其完整二进制代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0011 0000003e 0002 0002 0000000a </span><br><span class="line">2a b4 00 02 2b b4 00 02 64 ac </span><br><span class="line">0000 </span><br><span class="line">0002</span><br><span class="line">0012 00000006 0001 0000 0019 </span><br><span class="line">0013 00000016 0002 0000 000a 0014 0015 0000 0000 000a 001c 0015 0001</span><br></pre></td></tr></table></figure>

<p>可以看出，这个方法允许的最大操作数栈的最大深度为2，允许最多2个局部变量（包括形参）：max_locals参数的单位是slot，对于小于双字节的类型（如byte,char…）需要1个slot，而对double和long则需要2个slot。方法参数包括this，所以这个方法实际上参数是2。代码长度为10（<code>2a b4 00 02 2b b4 00 02 64 ac</code>），分别表示：</p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>2a</td>
<td><code>aload_0</code></td>
<td>将第一个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>b4 0002</td>
<td><code>getfield</code></td>
<td>获取指定类的实例域, 并将其压入栈顶。这里操作数为0x0002，查询常量池可知要把Child.hello2压栈</td>
</tr>
<tr>
<td>2b</td>
<td><code>aload_1</code></td>
<td>将第二个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>b4 0002</td>
<td><code>getfield</code></td>
<td>获取指定类的实例域, 并将其压入栈顶</td>
</tr>
<tr>
<td>64</td>
<td><code>isub</code></td>
<td>将栈顶两int型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>ac</td>
<td><code>ireturn</code></td>
<td>从当前方法返回int</td>
</tr>
</tbody></table>
<p>之后exception_table为空，有两个额外属性，分别是<code>LineNumberTable</code>和<code>LocalVariableTable</code>。</p>
<h3 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h3><p>用于描述java源代码行号和字节码行号之间的对应关系，定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 line_number;	</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这段代码偏移量为0的代码对应源代码的第25行，且只有一行代码。</p>
<h3 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h3><p>非必须属性，用来记录每个变量的名字，方便别人调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码一共记录了两个变量名，分别是<code>this</code>和<code>o</code>，对应两个形参名。</p>
<p>此外Child类中还有SourceFile、Signature属性，这里就不多说了。</p>
<p>Child类基本就分析到这了，实际上少分析了几个比较重要的分析，比如执行过程中的异常处理流程、异常抛出列表等、引导方法（BootstrapMethods）、各种字节码指令（特别是异常指令和同步指令）等，之后再补充。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/30/jvm3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/30/jvm3/" class="post-title-link" itemprop="url">JVM学习（3）垃圾回收器和内存分配策略</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-30T00:00:00+08:00">2019-08-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-01 16:19:28" itemprop="dateModified" datetime="2019-09-01T16:19:28+08:00">2019-09-01</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>垃圾回收（Garbage Collection,GC）机制是JVM的核心之一，而GC时需要考虑几个问题：</p>
<ol>
<li>回收哪些内存</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>判断一个object是否死亡主要有两种方式：引用计数和可达性分析。引用计数相对简单，但在object互相引用时会造成内存泄漏，所以JVM使用了可达性分析：一个存活的object所引用的object也是存活的。最初的存活对象被称为GC Roots，包含以下几类：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ol>
<h3 id="引用（reference）"><a href="#引用（reference）" class="headerlink" title="引用（reference）"></a>引用（reference）</h3><p>值得一提的是“引用”，Java中的引用分为以下几类：</p>
<ol>
<li>强引用（strong reference）：正常代码中的引用，比如Object a = new Object()</li>
<li>软引用（soft reference）：SoftReference类，描述一些还有用但非必须的对象。这类引用一般不会回收，但如果GC时判断可能会OOM，则会回收这类引用，如果回收失败时还可能OOM，则报错。</li>
<li>弱引用（weak reference）：WeakReference类，和SoftReference类似，但只能存活到下一次GC前。</li>
<li>虚引用（phantom reference）：最弱的引用，不对对象生存周期有任何影响，这类引用返回的对象总是null，不过如果GC回收这个对象，那么会接收到一个消息。</li>
</ol>
<p>SoftReference主要用于缓存，比如google的LoadingCache。PhantomReference主要用来实现类似析构函数之类的功能。这里又牵扯到finalize()方法，JVM规定如果object没有覆写finalize()或者finalize()已被JVM调用过，那么GC时就不用管finalize()。而如果JVM判断需要执行finalize()方法，那么会把这个object扔到一个叫F-Queue的队列里，由一个低优先级的Finalizer线程去依次执行各个finalize()方法：最关键的地方在于这个Finalizer不保证finalize()能被执行完，毕竟如果一个finalize()死循环或者超时了会影响整个JVM的工作，所以可能执行到一半就停了。此外，如果finalize()里又和其他对象建立了引用关系，执行完finalize()，GC会判断这个object又重新可达了，会不去回收这个对象，相当于c++中一个object在执行完析构函数后还正常存活。</p>
<p>总的来说因为finalize()有各种各样的坑，所以在需要类似析构函数的地方采用PhantomReference来代替。一个最典型的例子是DIrectBuffer，这个类有一个成员是cleaner，它是PhantomReference的子类，当一个DIrectBuffer被GC时会把这个对象塞到指定的ReferenceQueue里，然后再释放引用的堆外内存。</p>
<h3 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h3><p>方法区主要有两种数据可能会被回收：废弃常量和无用的类。常量回收和普通object回收很类似，只是这些常量放在方法区而已；无用的类判断起来很严格，要求</p>
<ol>
<li>没有该类的任何实例</li>
<li>加载该类的ClassLoader已被回收</li>
<li>该类对应的java.lang.Class对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法</li>
</ol>
<p>一般来说类还是不需要被回收的，但对于大量使用反射、动态代理、cglib等ByteCode框架、动态生成JSP以及OSGi这些频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，保证永久代不会溢出。值得一提的是JDK1.8以后取消了永久代，取而代之的是元空间（metaspace），metaspace使用的是native memory，且可以动态增加（当然也有上限，通过MaxMetaspaceSize配置）。这样可以极大降低永久代溢出的风险。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除（mark-sweep）算法"><a href="#标记-清除（mark-sweep）算法" class="headerlink" title="标记-清除（mark-sweep）算法"></a>标记-清除（mark-sweep）算法</h3><p>简单来说就是标记哪些部分的内存需要回收（见前文），标记完后统一回收。问题显而易见：运行一段时间后会产生大量的内存碎片，导致内存利用率降低。此外单线程的mark-sweep必然效率低。</p>
<h3 id="复制（copy）算法"><a href="#复制（copy）算法" class="headerlink" title="复制（copy）算法"></a>复制（copy）算法</h3><p>这种算法需要将内存分成（等大的）A，B两部分，分配内存时从A开始顺序分配，GC的时候把A中判定为存活的object复制到B，然后再从B开始顺序分配。好处是简单高效，缺点也显而易见：有一半内存被闲置了。</p>
<p>一般新生代采用这种回收方法，即将内存分成一大块的eden区和两块较小的survivor区，每次使用eden区和一个survivor区。内存从eden区开始顺序分配，假设eden区能回收绝大部分内存，那么GC的时候就把eden区和survivorA区的内存copy到survivorB区即可，这样就可以在只闲置一个survivor内存的情况下保证内存分配和回收足够高效。</p>
<p>在某些情况下可能survivor区不够大，需要依赖其他部分内存（老年代）进行分配担保（handle promotion），即把一部分对象直接扔到老年代。</p>
<h3 id="标记-整理（mark-compact）算法"><a href="#标记-整理（mark-compact）算法" class="headerlink" title="标记-整理（mark-compact）算法"></a>标记-整理（mark-compact）算法</h3><p>mark-sweep的改进，在标记完后把所有存活object向一个方向移动，可以避免内存闲置。</p>
<h3 id="分代收集（generational-collection）算法"><a href="#分代收集（generational-collection）算法" class="headerlink" title="分代收集（generational collection）算法"></a>分代收集（generational collection）算法</h3><p>根据对象生存周期的不同把内存划成几块（一般是分为新生代和老年代），在各部分内存采用不同的回收算法。比如在年轻代可以用复制算法，而老年代可以用标记-清理或标记-整理算法。</p>
<h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h2><h3 id="GC-Roots和OopMap"><a href="#GC-Roots和OopMap" class="headerlink" title="GC Roots和OopMap"></a>GC Roots和OopMap</h3><p>进行可达性分析时有两个问题：</p>
<ol>
<li>GC Roots包括两部分：全局性引用（如常量和类静态属性）和执行上下文（如栈帧中的本地变量表）。但这两部分内存包含的不仅是reference，还有比如方法，int，long型变量等，逐个检查这些内存中的引用会比较费时。</li>
<li>可达性分析时需要保证分析过程中的对象引用关系不变，这点是GC需要停顿所有java执行线程（stop the world）的重要原因之一。</li>
</ol>
<p>针对第一个问题，HotSpot采用了一种称为OopMap的数据结构来记录对象内哪些地方存放着reference，在类加载完后就可以把对象内什么偏移量上是什么类型的数据计算出来。这种GC方式被称为准确式GC，准确式GC和保守式GC的区别可以参考<a href="https://blog.csdn.net/woaigaolaoshi/article/details/51439227" target="_blank" rel="noopener">我爱学Java之JVM中的OopMap</a>。HotSpot在JIT（just in time）编译过程中，会插入相关指令来标明哪些地方是对象引用，如下图中0x026eb730到0x026eb7be这段区间内，exb寄存器和栈中偏移为16的内存区域各有一个普通对象指针的引用。</p>
<p><img src="/images/jvm_oopmap_sample.png" alt="String.hashCode()方法编译后的本地代码"></p>
<h3 id="安全点（safe-point）"><a href="#安全点（safe-point）" class="headerlink" title="安全点（safe point）"></a>安全点（safe point）</h3><p>OopMap能加速GC Roots枚举，但本身也会占用一定空间，因此不是所有指令都生成对应的OopMap，只在特定位置生成OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用，这样的位置称为安全点（safe point）。一般safe point选在可能“长时间执行”的地方，包括</p>
<ol>
<li>循环的末尾 </li>
<li>方法临返回前 / 调用方法的call指令后 </li>
<li>可能抛异常的位置</li>
</ol>
<p>另一个问题在于如何在GC时让所有线程（除JNI）外都跑到最近的safe point再停下来，有两种方式：</p>
<ol>
<li>抢先式中断（Preemptive Suspension）：GC发生时，先把所有线程中断，如果发现线程部在safe point上，则恢复执行，让它跑到安全点上</li>
<li>主动式中断（Voluntary Suspension）：GC时先设一个标志，各个线程会轮询这个标志，如果这个标志为true时就自己中断</li>
</ol>
<p>现在一般都用主动式中断，比如下边这个代码，GC需要暂停线程时会把0x160100内存页设置为不可读，那么线程执行到test时会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程，从而实现等待。</p>
<p><img src="/images/jvm_safe_point_sample.png" alt="轮询指令"></p>
<p>话说回来，让线程主动自陷的前提是线程本身正在运行，但如果线程并没有执行，比如正在sleep、blocked等等，因此引入安全区域（safe region）的概念。所谓safe region，是指这段代码片段中引用关系不会发生变化。线程进入safe region后就不管GC设置的标志了，但出safe region时需要检查GC是否已经完成了根节点枚举或者整个GC过程，没有的话就等到GC结束。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>HotSpot提供了很多垃圾回收器，方便用户在特定情况下使用合适的垃圾回收方式。下图列出了适合新生代和老年代的各个垃圾回收器，注意并不是所有垃圾回收器可以配合使用。</p>
<p><img src="/images/jvm_gc_types.png" alt="HotSpot虚拟机的垃圾收集器"></p>
<h3 id="Serial-Serial-Old收集器"><a href="#Serial-Serial-Old收集器" class="headerlink" title="Serial/Serial Old收集器"></a>Serial/Serial Old收集器</h3><p>最简单的单线程垃圾回收器，新生代使用Serial，采用复制算法；老年代使用Serial Old，采用标记-整理算法。好处是simple is the best，坏处是并行度不够，且stop the world时间很长。一般用在client模式下。</p>
<p><img src="/images/jvm_serial.png" alt="Serial收集器"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>简单来说就是Serial的多线程版本。由于CMS只能和Serial和ParNew配合使用，故ParNew也是Server模式下首选的新生代收集器。</p>
<h3 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge/Parallel Old收集器"></a>Parallel Scavenge/Parallel Old收集器</h3><p>看介绍和ParNew差不多，但更关注吞吐量，即尽可能降低GC总时间。相对应的Parallel Old可以认为是Parallel Scavenge的老年代版本，两者可以配合使用，适用于吞吐量敏感的场合（比如离线任务）</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器的目标是降低GC停顿，适用于重视响应时间的服务。CMS基于mark-sweep算法，想法也很简单：很多时候stop-the-world是为了避免引用变更，但毕竟不是所有引用在GC期间都会改，所以如果能侦测到哪些引用没变且没被引用，就可以和其他用户线程同步进行回收。CMS步骤分为以下4步：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>其中1和3还是需要stop-the-world，而耗时最长的2和4可以和用户线程并发执行，显然GC停顿时间变短了。 </p>
<p><img src="/images/jvm_cms.png" alt="CMS执行流程"></p>
<p>当然CMS也有缺点，</p>
<ol>
<li>对CPU资源敏感，因为和用户线程并发执行会占用一部分CPU资源，导致用户程序执行变慢</li>
<li>无法处理浮动垃圾（floating garbage），由于和用户线程并发执行，在此期间产生的垃圾无法被检测和回收，导致CMS不能等到老年代几乎完全被填满了再进行收集，需要预留一部分。当CMS运行期间内存不足，会报“concurrent mode failure”，此时JVM会临时采用Serial Old来进行回收，触发full GC，导致响应时间变长</li>
<li>CMS基于mark-sweep，会导致大量内存碎片，对此可以选择在CMS执行几次不压缩的full GC后，执行一次带压缩的full GC。压缩的full GC过程无法和用户线程并发执行。</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage first）的基本思想是把内存预先划分成若干大小的region，在每个region独立执行GC，这样有几个好处：</p>
<ol>
<li>可以和用户线程并发执行</li>
<li>可以分代回收</li>
<li>内存碎片较少</li>
<li>停顿可预测</li>
</ol>
<p><img src="/images/jvm_g1_memory.png" alt="G1收集器的内存分布"></p>
<p>那么如何判断一个region的object是否被其他region引用？G1采用了Remembered Set来避免全堆扫描，每个region都配一个对应的remembered set，当JVM发现应用程序对reference类型进行写操作时，会产生一个write barrier暂时中断写操作，检查reference引用的对象是否在其他region，如果是的话就通过CardTable把相关引用信息记录到被引用对象所属的region的remembered set中，这样在扫region的时候可以避免全堆扫描。</p>
<p>更详细的可以参考<a href="https://blog.csdn.net/coderlius/article/details/79272773" target="_blank" rel="noopener">详解 JVM Garbage First(G1) 垃圾收集器</a></p>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="对象优先在eden分配"><a href="#对象优先在eden分配" class="headerlink" title="对象优先在eden分配"></a>对象优先在eden分配</h3><p>对象优先在eden分配，如果eden区不足，则会触发一次minor GC。</p>
<ul>
<li>Minor GC是新生代GC，指发生在新生代的垃圾收集动作，minor GC发生的比较频繁，且回收速度也比较快</li>
<li>Full GC（Major GC）指发生在老年代的GC。Full GC的速度一般比Minor GC慢10倍以上</li>
</ul>
<h3 id="大对象直接进老年代"><a href="#大对象直接进老年代" class="headerlink" title="大对象直接进老年代"></a>大对象直接进老年代</h3><p>比如byte[]数组。一般假定大对象的存活时间会比较长。分配连续的大内存可能会不成功，提前触发GC，应当尽量避免存活时间短的大对象。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>JVM中每个对象有一个age计数器，对象每经过一次minor GC，age加1，超过一定年龄后（比如15）就扔到老年代。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>不一定非要等到MaxTenuringThreshold才升级到老年代，如果survivor区相同年龄所有对象大小的总和超过survivor空间的一半，那么大于等于这个年龄的object也可以进入老年代</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>发生minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立的化minor GC就是安全的，否则会查看HandelPromotionFailure是否设置，如果设置的话会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果大于，会尝试一次有风险的minor GC；如果小于，或者HandelPromotionFailure未设置，则进行full GC。</p>
<p>所谓的风险是指survivor区可能无法容纳所有幸存object，会扔到老年代，而老年代如果也放不下，minor GC自然就失败了。</p>
<p>感觉这一章内容还没完全看懂，以后再详细了解一下。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/26/megastore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/megastore/" class="post-title-link" itemprop="url">megastore阅读笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-26T00:00:00+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-30 16:38:22" itemprop="dateModified" datetime="2019-08-30T16:38:22+08:00">2019-08-30</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前粗略浏览过一遍megastore论文，对其中数据模型有点印象，但后面没太细看，今天补上。</p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>Megastore的目标是为了服务交互式线上服务，比如gmail、picasa。当然google后来已经改用spanner&amp;F1了。基本架构如下图所示。</p>
<p><img src="/images/megastore1.png" alt="图1"></p>
<p>Megastore将数据分为一个个Entity Group（怎么分得看具体业务）。每个数据中心都保存了完整的数据副本（为了便于理解，其实按说也不一定）。在同一数据中心内部，如果在同一个EG里的事务，可以只用一阶段提交即可保证ACID语义；如果是跨EG的事务，可以用两阶段提交，也可以用消息队列，如下图所示。</p>
<p><img src="/images/megastore2.png" alt="图2"></p>
<p>而跨数据中心则基于paxos进行备份，这意味着可以直接从本地数据中心进行的读操作是有效的（且通常是最新的），但写操作非常的重。我之前读到这的时候很奇怪，毕竟大多数情况写进某个DC再慢慢传播就行了，但megastore确实是这么干的，只能认为这些DC之间的带宽和延迟都非常给力。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="物理布局"><a href="#物理布局" class="headerlink" title="物理布局"></a>物理布局</h3><p>Megasotre的数据模型介于RDBMS和NoSQL之间，spanner的论文没有详细描述数据模型，但估计和megastore差不多。一方面，megastore要求数据的每个字段是强类型的（具体格式很像protobuf，毕竟是google自家的产品），另一方面可能也和megastore依赖于BigTable有关，很难完全支持各种联表查询。考虑到megastore主要用于读远多于写的情况，故采用pre-join的方式，将读代价转移到写上（其实megastore采用paxos保持每个集群数据总是最新/较新也是为了保证高可读性），如下图所示。</p>
<p><img src="/images/megastore3.png" alt="图3"></p>
<p>Megastore的table分为root table和child table两种，child table必须要引用其root table的某个键（必须是主键？）：那么，一个entity group包含了一系列entity，每个entity有root table及其sub table中的数据。对于每个entity，具体数据被存放到Bigtable中的某一行，其所有主键按字符串顺序连接起来作为BigTable的row key，其他列则保存在column中。由于child table引用了root  table的某个键，因此child table的数据也选择这个键作为主键，而利用BigTable的row key按字典序存放可以保证这些数据紧邻，如下图所示。当然也可以声明为SCATTER，这样的entity会在rowkey前加两个字节的hash code，以避免热点。</p>
<p><img src="/images/megastore4.png" alt="图4"></p>
<p>其实我觉得还是有问题，比如root table的主键是K1,K2,K3，child table引用了K2,K3，主键是K4。假如有两个root entity A:(a1,a2,a3)和B:(b1,b2,b3)，其中a2=b2,a3=b3；一个child entity C(c4)，有属性(a2,a3)，需要在BigTable里加两行(a1-a2-a3-c4)和(b1-a2-a3-c4)？修改的时候也要对这两行同时修改？或者又建了一层索引？又或者完全不管(直接用c4当row key)？看了下tidb的实现，主键还是就这样连接起来，但tidb不支持foreign key，所以也没法参考。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`test_primary_keys`</span>(</span><br><span class="line">    <span class="string">`k1`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`k2`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`k3`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`k4`</span> <span class="built_in">INT</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`k1`</span>,  <span class="string">`k2`</span>, <span class="string">`k3`</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_primary_keys <span class="keyword">values</span>(<span class="string">"hello"</span>, <span class="string">"my"</span>, <span class="string">"tidb"</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>

<p>实际存储到tikv里的数据是</p>
<blockquote>
<p>key: zt\200\000\000\000\000\000\000\377-_r\200\000\000\000\000\377\000\000\001\000\000\000\000\000\372<br>    write cf value: MvccWrite { r_type: Put, start_ts: 410775417252216833, commit_ts: 410775417278431233, short_value: [8, 2, 2, 10, 104, 101, 108, 108, 111, 8, 4, 2, 4, 109, 121, 8, 6, 2, 8, 116, 105, 100, 98, 8, 8, 8, 144, 7], unknown_fields: UnknownFields { fields: None }, cached_size: CachedSize { size: 0 } }</p>
</blockquote>
<p>同时，在Root Table的BigTable单行中，还存储了transaction,replication元数据以及Transaction Log。下图是整个MegaTable Table在BigTable之上的布局图。</p>
<p><img src="/images/megastore6.png" alt="图6"></p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>二级索引主要分为两种：local index和global index。所谓的local和global取决于是否跨EG，如图3中的PhotosByTime和PhotosByTag。Local index实际上被放在同一个entity group里，可以保证强ACID语义。Global index可以在不知道具体哪个EG的情况下找到特定的entity，但更新可能会不及时。此外Megastore还支持一些特性：</p>
<h4 id="存储子句（storing-clause）"><a href="#存储子句（storing-clause）" class="headerlink" title="存储子句（storing clause）"></a>存储子句（storing clause）</h4><p>一般索引用法是先通过索引确定哪一行，再访问这一行得到结果。Storing clause允许把一些数据保存到索引里，比如图3中的PhotosByTag.thumbnail_url。</p>
<p>不是很确定megastore是怎么存index的。但在tidb里，索引其实也是一行数据，和普通的数据行没有本质区别，每次更新时都会影响所有索引行。那么往这些行里加点附加数据加速查询，也很是很自然的想法。</p>
<h4 id="重复索引（repeated-indexes）"><a href="#重复索引（repeated-indexes）" class="headerlink" title="重复索引（repeated indexes）"></a>重复索引（repeated indexes）</h4><p>如图3中的PhotosByTag.tag，每个tag都有个索引。很正常的想法，毕竟一张图可能有很多个tag，总不能把所有tag连接起来当索引吧。</p>
<h4 id="内联索引（inline-indexes）"><a href="#内联索引（inline-indexes）" class="headerlink" title="内联索引（inline indexes）"></a>内联索引（inline indexes）</h4><p>Local index的一种，个人理解是同一个EG里foreign key的反向映射，保存在root table里新加的几列里。如下图所示，PhotosByTime.user_id是User表的主键，因此在索引PhotosByTime(user_id, time)时，可以在user_id行，PhotosByTime.time列，找到对应的photo_id。</p>
<p><img src="/images/megastore5.png" alt="图5"></p>
<p>总的来说创建索引后要么新建一行，要么新建一列，具体怎么做还得看情况。</p>
<h2 id="事务处理和并发控制"><a href="#事务处理和并发控制" class="headerlink" title="事务处理和并发控制"></a>事务处理和并发控制</h2><p>如前所述，同一个EG内的事务处理保持严格的ACID语义，和大多数数据库一样，写数据前会写一条WAL（write-ahead  log），然后再按照这个WAL落盘。</p>
<p>又因为BigTable天然的支持MVCC（multiversion concurrency control），所以只要在写事务时加上对应的timestamp就自然可以让megastore支持MVCC，这也意味着可以不用加锁就能快照读，甚至写操作也不一定要加锁。</p>
<p>Megastore提供了三种级别读：当前读（current），快照读（snapshot），立即读（inconsistent）。Megastore的做法是对于current读，要求当前entity group内（原文是the scope of a single entity group，应理解为要读的行所涉及的事务？）所有已committed的写操作落盘，然后用最近一次提交的事务所带的timestamp去读；而对于快照读就没有要求落盘操作了，可以认为是用最后一次已成功落盘的事务的timestamp去读。立即读就是不管timestamp直接读，显然这么读最快，对一致性要求不高的时候可以这么来。</p>
<p>所有的写事务都需要先进行一次current read，以此确定下一个log的position，这点非常重要。接着生成一个足够大的timestamp，遵循paxos协议尝试追加log。如前文所属，megastore主要用于读远多余写的情况，因此采用乐观锁：如果多个写操作向同一个log position写，只有一个能成功，其他失败的写操作会推倒重来一遍。完整的事务流程如下：</p>
<ol>
<li>Current read：获得最近一次事务的timestamp和log position</li>
<li>应用逻辑：读取BigTable数据，然后把所有写操作合并到一个log entry里</li>
<li>提交：遵循paxos协议，把log追加到日志队列里</li>
<li>生效：将日志中的修改写到BigTable的对应行，并修改相关索引</li>
<li>清理：清理掉不需要的数据</li>
</ol>
<p>实际上走完第三步就可以通知客户端写成功了，毕竟理论上日志被committed后等价于写成功，当然megastore会尽可能让距离客户端最近的副本生效这个事务，确保用户能读到最新的修改。</p>
<p>之前提到megastore支持跨entity group事务，可以用消息队列或者二阶段提交实现，见图2。消息队列简单来说就是先在EG1上进行事务，然后EG1将事务打包成一个消息塞到EG2的队列里，EG2原子的消费这个消息，事务从而继续在EG2上执行。论文上没更详细的讲这部分，比如如果事务跨了三个EG该怎么发送消息？EG之间来回读、来回写呢？一个事务在这三个EG上timestamp是否要保持一致？二阶段提交应该就是先拿写锁再写。</p>
<h2 id="副本同步"><a href="#副本同步" class="headerlink" title="副本同步"></a>副本同步</h2><p>副本同步是megastore的核心，它使用了一个基于paxos的低延迟的复制策略，保证各个集群的副本是一致的：显然，写操作需要至少在一个quorum数量的数据中心上commit才算成功，这也意味着一个写操作几乎要把所有DC跑一遍。当然，严格的写操作可以保证一个current read能有以下保证：</p>
<ol>
<li>一旦一个write成功，那么这个时刻之后的current read一定能读到这个write（可见性）</li>
<li>一旦某个current read读到一个write，那么之后的读操作都可以读到这个write（持久性）</li>
</ol>
<h3 id="副本架构"><a href="#副本架构" class="headerlink" title="副本架构"></a>副本架构</h3><p>首先megastore允许每个position的log彼此独立，且log可以有空洞，这个和raft不太一样。下面这张图列出了大多数可能的日志冲突的情况。按我理解，日志冲突时具体恢复成哪个版本也说不定，和paxos运行有关，比如102，如果δ的proposal_id足够高，γ又没抢到更高的proposal_id，可能到最后会以δ为准。</p>
<p><img src="/images/megastore9.png" alt="图9"></p>
<p>一般来说副本应该包括log和具体数据，但实际上paxos要求多个acceptor只是为了达成一致，所以可以让一些副本只保留log信息（这类副本称为witness）。此外，有时候也不太需要特别新的副本，只要保留某一时刻强一致性的数据就可以支持read，这类副本称为read-only副本。总的来说，megastore的架构如下图所示，论文描述的是“Each application server has a designated local replica”，应理解为每个应用都指定了一个本地副本，然后通过megastore library来和其他副本进行同步。</p>
<p><img src="/images/megastore8.png" alt="图8"></p>
<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><p>之前提到，write操作需要先进行一次current read，从而决定write的timestamp，设这个timestamp为t0。那么，对于t&lt;t0的快照读，write<sub>t0</sub>是一定不会看到的；write<sub>t0</sub>被commit后，对于current read，它的timestamp一定&gt;t0，且要求write<sub>t0</sub>落盘后才能继续，因此current read不会读到写到一半的数据。故current read的隔离级别至少是可重复读的。类似的，由于snapshot读会选择最后一个落盘的事务的timestamp读，而一个事务落盘意味着它之前的事务也落盘了，故snapshot读也至少是可重复读的。</p>
<p>显然，如果写操作非常少的情况下，我们可以直接从任意副本读取最新数据，不需要RPC。那么问题就在于如何判断一个副本是最新的？为了解决这个问题，对于一个特定的entity集合，Megastore在每个DC都起了一个coordinator的服务，来管理这个entity集合内的副本状态。更准确的说，coordinator维持了一个最新的副本列表，如果某个写操作被某个副本拒绝，那么这个副本上的coordinator就会把对应的entity group key移除，这一过程称为invalidation。</p>
<p>完整的current read流程如下：</p>
<ol>
<li>本地查询（query local）：查询本地的coordinator确定本地副本是否最新</li>
<li>寻找log position（find position）确定最高的可能的已被commited的log position，然后选择一个已经成功应用这个log的副本，<ul>
<li>a. 如果1已确定本地副本是最新的，那么直接以最后一个已committed的事务的timestamp读本地副本即可。</li>
<li>b. 如果本地副本不是最新的，或者2a超时了，那么会发起一次majority read（paxos保证多数派副本是一致的），找到大多数副本中最大的Log Position信息以及Timestamp信息，然后选择一个通常能快速响应的Replica或者是数据最新的Replica去读。</li>
</ul>
</li>
<li>数据追赶（catch up）：当知道本地副本已经不是最新，且在2b中选择了一个副本的情况下，会尝试补全数据：<ul>
<li>a. 对于某个position，如果选定的副本能确定已经有共识值的情况下，就按共识值填，不确定的话再找个副本接着读；如果都确定不了，则用no-op或者之前某个候选值填充这个position。</li>
<li>b. 当所有log被补齐后，依次apply这些log</li>
</ul>
</li>
<li>校验（validate）：如果选择了本地副本且之前不是最新的，那么通知coordinator，(entity group, replica)已更新至最新，且通知所有相关的write操作该副本部分已更新。</li>
<li>数据查询（query data）：使用已知的最大timestamp去读已选中的副本，如果这个副本已过期，那么再找个副本执行一遍catch up</li>
</ol>
<p>其中1和2a可以并发执行，时序流程图如下。</p>
<p><img src="/images/megastore10.png" alt="图10"></p>
<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>可以看到，current read可以得到下一个可用的log position，最新的timestamp，以及下一个leader副本。因此Write操作会先进行一次current read，然后去竞争写这个position log。在write被committed并准备apply前，需要所有集群的副本，要么接受这个write，要么对应的coordinator失效相关的entity。完整的write流程如下：</p>
<ol>
<li>请求Leader（ Accept Leader）：请求leader将自己的提议的值作为0号提议，如果成功转3</li>
<li>准备（Prepare）：即basic paxos prepare阶段，找到有最大proposal_id的value，并生成一个更大的proposal_id去提交</li>
<li>接受（Accept）：即basic paxos accept阶段。如果失败则转2。</li>
<li>失效（Invalidate）：要求所有没接受这个值的副本上的coordinator对相关entity进行invalidate处理</li>
<li>落盘（Apply）：在尽可能多的副本上落实这个log，如果选中的值和初始值不同，则报一个conflict error</li>
</ol>
<p>其实整个流程就是paxos，其中第一阶段是fast write，时序流程图如下。值得注意的是，一般数据库的commit point和visibility point一样，即一旦一个write被committed，用户就可以看到相关变更。而在megastore里，commit point在3，而visibility  point则在4。至于leader的选择，一般会按照某个启发式规则来确定，比如某个地区的application写操作比较多，那么离这些地方最近的副本就可以被选为leader。显然，如果leader一直有效且各个副本响应的足够快，那么整个写操作就退化为master-slave架构；如果leader总是挂，那么整个过程就退化为basic paxos流程。</p>
<p><img src="/images/megastore11.png" alt="图11"></p>
<h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>最后一个问题是coordinator，因为几乎所有的读写请求都要过coordinator，且对整个系统的正确性有决定性的影响，所以megastore把coordinator做成一个轻量级、无状态的服务，且只有coordinator拿到过半数的chubby锁时才被认为有效。如果没拿到足够多的锁，那么coordinator就认为所有entity group都过期了。如果一个coordinator突然挂了（比如失去了锁），那么在这个副本上的current read和write都得等coordinator重新上线后才能跑，但实际上coordinator宕机恢复期间，客户端可以其他副本进行current read和write操作。</p>
<p>由于megastore允许乱序log，对于position n,m，n&gt;m，如果m处日志写入失败而n写入成功，那么coordinator会报一个crash。不过我没太看懂coordinator检测crash的机制，原文如下。</p>
<blockquote>
<p>We detect crashes using a unique epoch number for each incarnation of the coordinator: validates are only allowed to modify the coordinator state if the epoch remains unchanged since the most recent read of the coordinator.</p>
</blockquote>
<p>其实想也知道megastore的写操作异常的重，吞吐量肯定不会高，</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="/files/Megastore.pdf">原文</a></li>
<li>Google Megastore分布式存储技术全揭秘：<a href="https://www.cnblogs.com/yako/archive/2011/02/18/1957790.html" target="_blank" rel="noopener">https://www.cnblogs.com/yako/archive/2011/02/18/1957790.html</a></li>
<li>Google-MegaStore的解读：<a href="https://www.iteye.com/blog/57832638-2028003" target="_blank" rel="noopener">https://www.iteye.com/blog/57832638-2028003</a></li>
<li>Google Megastore读写的架构分析：<a href="https://www.oipapio.com/cn/article-1701115" target="_blank" rel="noopener">https://www.oipapio.com/cn/article-1701115</a></li>
<li>Megastore详解：<a href="http://www.nosqlnotes.com/tag/megastore/" target="_blank" rel="noopener">http://www.nosqlnotes.com/tag/megastore/</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/jvm2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/jvm2/" class="post-title-link" itemprop="url">JVM学习（2）JVM内存布局</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:03" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:03+08:00">2019-08-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-31 18:25:13" itemprop="dateModified" datetime="2019-08-31T18:25:13+08:00">2019-08-31</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>在学习垃圾回收前需要了解JVM内存的各个区域，如下图所示。</p>
<p><img src="/images/jvm_mem.png" alt="JVM运行时数据区"></p>
<p>还是蛮容易理解的，很多区域可以和实机的区域对应上，实现的目的也相似。</p>
<h3 id="程序技术器（Program-Counter-Register）"><a href="#程序技术器（Program-Counter-Register）" class="headerlink" title="程序技术器（Program Counter Register）"></a>程序技术器（Program Counter Register）</h3><p>JAVA的处理单元是线程，那么为了线程切换，需要为每个线程保存一个独立内存区域以便恢复，这类区域成为“线程私有”的内存区域。本区域可以看作当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。简单来说模拟了CPU（运行时保存的数据）</p>
<p>如果线程执行的是一个java方法，那么这个计数器指向正在执行的虚拟机字节码指令的地址。如果执行的是native方法，则为空(undefined)。</p>
<p>本区域在JVM规范里没有规定任何OOM情况。</p>
<h3 id="JAVA虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#JAVA虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="JAVA虚拟机栈（Java Virtual Machine Stacks）"></a>JAVA虚拟机栈（Java Virtual Machine Stacks）</h3><p>模拟的是栈区，每个方法在执行时会创建一个栈帧（stack frame），保存了局部变量表、操作数栈、动态链接、方法出口等。</p>
<p>局部变量表存放了编译期可知的各种基本类型、对象引用、返回地址，其长度在编译器可以确定，运行时不能改变变量表的大小。（这点似乎与C不同，C和JAVA都支持数量可变的参数方法，但JAVA是通过数组模拟的，而C是真的压栈传参的。）</p>
<p>有两种异常情况，</p>
<ul>
<li>StackOverflowError：请求深度超过JVM允许的最大深度。</li>
<li>OutOfMemoryError：虚拟机栈扩展时如果申请不到足够的内存就会报OOM。当然JVM规范也允许固定长度的虚拟机栈。</li>
</ul>
<h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>与JAVA虚拟机栈相似，只不过方法是本地方法。JVM规范没有强制规定本地方法栈使用的语言、方法、数据结构，所以可以自由实现，甚至可以和JAVA虚拟机栈合二为一（比如hotspot）。也会报StackOverflowError和OOM。</p>
<h3 id="JAVA堆（Java-Heap）"><a href="#JAVA堆（Java-Heap）" class="headerlink" title="JAVA堆（Java Heap）"></a>JAVA堆（Java Heap）</h3><p>专门为了存放对象实例的内存区域，被所有线程共享（但可能划分出线程私有分配缓存区，Thread Local Allocation Buffer TLAB）。理论上所有对象实例和数组都应该分配在堆上，但实现时可以优化到别的地方。</p>
<p>JAVA堆是垃圾收集器的主要区域。由于现在收集器基本都采用分代收集算法，从内存回收的角度看，还可以细分为新生代和老年代，更细致一点可以分为eden、from survivor、to survivor空间等。</p>
<p>JAVA堆在物理上可以不连续，但在逻辑上必须连续。其大小可以固定，但一般是可扩展的，通过-Xmx和-Xms控制，申请不到新内存时会报OOM。</p>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>存放已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，被所有线程共享。JVM规范把方法区描述为堆的一个逻辑部分，但有个别名non-heap以区分对待。</p>
<p>Hotspot实现时将GC分代回收机制扩展至方法区，故方法区又成为永久代（Permanent Generation），其他虚拟机不一定这么实现。JVM规范没有强制规定怎么实现，用永代区实现的话可能会更容易遇到OOM，使用native memory似乎更好。</p>
<p>此外，JVM规范可以允许不在方法区实现GC，毕竟GC也就只能回收常量池和被卸载的类型。</p>
<h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>方法区的一部分，用于存放编译期生成的各种字面量和符号引用，在类被加载后放到常量池；事实上也可以动态添加，比如String.intern()。</p>
<h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>为执行本地方法提供的内存区域，可以认为是给本地方法提供的堆区。显然，由于Direct Memory和Java Heap是两个独立的区域，而Java方法无法直接访问Direct Memory，所以某些情况下会在两个区域间来回复制数据，导致性能下降。</p>
<p>在JDK1.4以后新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）和缓存区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，从而避免数据复制。</p>
<p>另外，通过<code>-XX:MaxDirectMemorySize</code>只能阻止java代码分配DirectBuffer，对在JNI里调用malloc之类的内存分配函数无效。之前做过一个实验，给<code>MaxDirectMemorySize</code>设置了一个很小的值，然后不断在jni里malloc，结果过了一会把机器打爆了。。。</p>
<h2 id="对象机制"><a href="#对象机制" class="headerlink" title="对象机制"></a>对象机制</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>JVM遇到new指令时，</p>
<ol>
<li>检查这个类有没有被加载，没有的话执行一遍类加载过程</li>
<li>确定对象大小，JAVA的继承机制导致类型一旦确定，则大小可以完全确定</li>
<li>为对象分配内存。两种方式，具体用哪种取决于GC支不支持压缩整理<ul>
<li>指针碰撞（Bump the Pointer）：假设内存以指针P为界分为两部分，&lt;P的部分为已使用的内存，&gt;=P的部分为空闲内存，则分配时只要移动P即可。</li>
<li>空闲列表（Free List）：维护一个所有空闲内存的列表，分配时找一个足够大的内存分配过去并更新列表。</li>
</ul>
</li>
<li>另外内存分配可能是线程不安全的，要么加同步处理，要么为每个线程预留一块本地线程分配缓冲（Thread Local Allocation Buffer TLAB），用完并重新分配时进行同步处理。</li>
<li>对对象内存置零。如果用TLAB，可以把这个动作提前至TLAB分配时进行。</li>
<li>设置对象头</li>
<li>调用方法</li>
</ol>
<p>和C++相比，共同点是都要分配内存和调用init()，不同点是JAVA可以实现类动态加载、对象有对象头之类的填充内容，且内存分配方案与GC直接相关。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>简单来说是由对象头（Header）、实例数据（Instance Data）和对齐信息（Padding）组成。对齐信息就是单纯为了让object按内存对齐，没有特别用处；实例信息是这个对象保存的实际信息，值得注意的是实际的内存分布和代码顺序、继承顺序没有必然关系，子类的较小变量也可能被插在父类的变量之间，为了对齐的更整齐、更紧致一些。</p>
<p><img src="/images/Synchronization.gif" alt="JVM运行时数据区"></p>
<p>重点是对象头，分为两部分。第一部分为标记字段（Mark Word），其长度为32/64 bits，和JVM有关，所保存的数据含义根据object状态不同而不同，比如在下图unlocked non-biasale object的32位中，前25bit表示该object的hash code，4bit保存分代年龄，1bit固定为0,后两位存储锁标志位。</p>
<p>第二部分为类型指针（Klass Pointer），用以确定这个实例来自哪个类。但如果JVM实现时可以通过别的方式查找到所属类，那么也可以没有这个字段。</p>
<p>另外如果是数组，还需要一个字段记录数组长度。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>如何定位对象的address取决于我们使用的是句柄还是直接指针。句柄的话就得先访问句柄再访问内存，直接指针可以直接访问内存。不过句柄的好处是GC的时候不用改太多东西。HotSpot用第二种方式。</p>
<p><img src="/images/jvm_visit_by_handle.png" alt="通过句柄访问对象"></p>
<p><img src="/images/jvm_visit_by_pointer.png" alt="通过指针访问对象"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/arthas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/arthas/" class="post-title-link" itemprop="url">阿里Arthas学习</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:01 / Modified: 16:51:04" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:01+08:00">2019-08-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前几天同事分享了一个巨流弊的工具<a href="https://alibaba.github.io/arthas/" target="_blank" rel="noopener">Arthas</a>，可以在线上花式调试/监控JVM上的代码运行状况，excited!这里记录几个常用命令。</p>
<p>启动命令: <code>wget https://alibaba.github.io/arthas/arthas-boot.jar &amp;&amp; java -jar arthas-boot.jar</code></p>
<h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><p>就是dashboard</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>流弊！watch可以监视某个方法的运行状况，但缺点是它不能像断点一样阻塞这个线程。一般调用方法为watch $class_name $method $watch_express $cond_express $flags, 其中观察表达式（watch_express）和条件表达式（cond_express）为<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">OGNL表达式</a>，个人还不太会用，基本元素可以参考表达式核心变量。</p>
<p>class_name需要把路径写全，某个类的子类要写成parentClass$subClass，用$符号隔开</p>
<p>-b -e -s 分别表示在方法运行前、异常返回后、正常返回后监控。-f或者什么都不写表示返回后监控。</p>
<p>-x表示观察递归深度。比如某个参数p有内部变量p1，p1有内部变量p2，那么要打印出p2，需要指定-x 3</p>
<h3 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h3><p>查看JVM已加载的类信息</p>
<h3 id="redefine"><a href="#redefine" class="headerlink" title="redefine"></a>redefine</h3><p>流弊！<a href="https://alibaba.github.io/arthas/redefine.html" target="_blank" rel="noopener">redefine</a>可以加载外部某个.class文件进jvm，redefine后的原来的类不能恢复，redefine有可能失败（比如增加了新的field），参考jdk本身的文档。有两个限制：</p>
<ul>
<li>不允许新增加field/method</li>
<li>正在跑的函数，没有退出不能生效，比如下面新增加的System.out.println，只有run()函数里的会生效</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MathGame game = <span class="keyword">new</span> MathGame();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            game.run();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这个不生效，因为代码一直跑在 while里</span></span><br><span class="line">            System.out.println(<span class="string">"in loop"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 这个生效，因为run()函数每次都可以完整结束</span></span><br><span class="line">        System.out.println(<span class="string">"call run()"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> number = random.nextInt();</span><br><span class="line">            List&lt;Integer&gt; primeFactors = primeFactors(number);</span><br><span class="line">            print(number, primeFactors);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"illegalArgumentCount:%3d, "</span>, illegalArgumentCount) + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简单来说可以不用每次修改完后重新打包-上传-重启了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/cheat1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/cheat1/" class="post-title-link" itemprop="url">页游辅助思路</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:00 / Modified: 16:40:53" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:00+08:00">2019-08-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实我玩过的页游也就是舰C，这游戏最大的特点就是制作者恨不得让玩家每天996的肝游戏（如果玩家稍微有点追求），发展到现在可以说没辅助没法玩。不过这个游戏也可以很简单的进行辅助操作，因为页面之间变化不大，操作简单：玩家也就只能点点鼠标。</p>
<p>原理简单来说还是模拟人类玩家的操作方式：根据页面图像来进行下一步操作。</p>
<p>页面图像获取一般还是用GetPixel之类的API。在windows上，可能用DX系列的API更好一些，但调用实在太复杂，且兼容性比较差。话说自从舰C改版到HTML5后，基本只能用chrome或者chromium内核来玩了，而这个浏览器似乎不支持PrintWindow等可以通过窗口DC直接获取截图的方法——或者说DX窗口都不支持PrintWindow，导致我只能用全屏截图的API或者类似的API，而不能把游戏窗口隐藏到后端：毕竟挂机的时候也希望干点别的事。个人猜测可能是因为DX截图是基于显示设备的，没办法获取被隐藏的窗口。</p>
<p>图像获取后的另一个问题是”判断“，往大了说是图像识别，但通常只要判断子图是否一致，甚至某几个像素是否一致就可以了。按键精灵这种外挂似乎可以通过子图识别来确定，不过我觉得舰C不太需要这么高端的功能，毕竟几乎所有按钮出现的位置都不会变，因此不需要去”找“，而只需要在特定位置”判断“某个子图是否出现即可。</p>
<p>模拟操作相对而言很简单，获取到窗口句柄后PostMessage就可以了。</p>
<p>”输入“和”输出“手段就这样愉快的决定了，接下来是辅助器的设计思路。由于舰C这种页游的页面显示变化很小，场景间处理逻辑差别很大，关联很小，故可以用状态机模型来进行编程：维持一个context，将每一个场景视为”state“，出现某个图像/自定义函数作为”condition“，如果满足条件则进行状态切换/改变上下文/进行操作。舰C的context比较好获得，大部分可以通过游戏内部数据获取，可以通过截取解析HTTP包获得，或者干脆用现成的工具74EO解析。一般的页游也差不多，如果不想解析包，也可以直接处理图像获得（比如血条什么的），但毕竟不如直接解包来的准确。</p>
<p>举个例子，比如在舰C里刷闪，涉及到的场景大致有主页面、队伍编成页面、补给页面、地图选择页面、战斗页面，切换条件分别为：</p>
<ul>
<li>主页面：如果编成未结束进入编程场景；如果没补给完则通过补给按钮进入补给场景；否则进入地图选择场景</li>
<li>队伍编成场景：选择要刷闪的船，选完后返回主页面。没有要刷闪的船则在返回后跳出。</li>
<li>补给场景：能补给则补给，补给完则返回主页面。</li>
<li>地图选择场景：进入1-1，切换至战斗场景。</li>
<li>战斗场景：不停出击，直至返回主页面。<br>每个场景内的操作相对简单，比如在战斗场景里，如果出现阵型选择则点击单纵（实际上刷闪因为只有三艘船不会选择阵型），出现战后结算则随便点一下，出现是否前进则点击前进，出现是否入夜则点击不入夜。</li>
</ul>
<p>可以思考一下如何在刷闪的时候收发远征？</p>
<p>在构筑好状态机后，我们需要两个协程，协程A每隔一段时间（比如3秒）截图，将截图放入上下文，控制权交给协程B；协程B跑上面这个状态机，根据上下文进行一轮条件判断和操作，再交给协程A。</p>
<p>我一开始的代码逻辑是顺序的：判断图像-进行操作-判断图像-进行操作。。。。这种编程思路的坏处是，如果某个判断/操作失败了（比如窗口没收到点击消息、某个图片迟迟没弹出等），需要进行异常处理的逻辑会变得非常复杂。而页游中同一场景中的条件判断几乎不重复，即使某次判断/操作失败了也可以再一次正确处理。另外，如果游戏机制改变了，需要插入的逻辑也会比较简单。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/java-dynamic-proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/java-dynamic-proxy/" class="post-title-link" itemprop="url">Java动态代理笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:00 / Modified: 16:46:34" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:00+08:00">2019-08-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天重构代码时遇到一个可能需要动态代理的地方，感觉自己对代理模式理解还是不够，做点笔记。</p>
<p>代理模式（Proxy Pattern）是程序设计中的一种设计模式，定义为：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>在不希望直接调用方法/访问对象A时，希望变成操作A’，间接影响A，这样可以降低代码逻辑的复杂度。无论如何在调用者看来，它还是在访问A：即代理对调用者透明，至少调用者不需要关心proxy的实现细节和副作用。常见的使用代理的场合有：</p>
<ol>
<li>远程代理（Remote Proxy）：将一个远程对象包装成本地对象。WIKI的例子是ATM，ATM保存了银行信息，用户访问ATM等同于访问银行。</li>
<li>虚拟代理（Virtual Proxy）：对象可以不实际存在，只有当访问时才会真正生成（也可以实现一部分）。参考延迟加载。</li>
<li>保护代理（Protection Proxy）：在实际调用前/中/后进行资源安全性的检查。</li>
<li>Copy-on-Write代理：虚拟代理的一种。把复制（克隆）拖延到只有在客户端需要时，才真正采取行动。</li>
<li>Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙（Firewall）代理：保护目标，不让恶意用户接近。</li>
<li>同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。</li>
</ol>
<p>组合/继承都可以实现代理模式，当然静态代理在JAVA里使用继承会简单一些。即A’继承A，在每个父方法调用前后做一些操作。</p>
<p>JAVA也支持动态代理，按我理解应该是组合模式。对于真实对象object，需要实现一个InvocationHandler接口，再通过Proxy.newProxyInstance(classLoader,interfaces,handler)来创建代理对象。</p>
<ol>
<li>classLoader: 生成的代理类所在的classLoader。（下次学习一下classLoader）。</li>
<li>interfaces：想要代理的接口的集合。</li>
<li>handler：我们刚才创建的handler，使用它来实际调用object，并做一些其他操作。</li>
</ol>
<p>第二个参数interfaces很重要，JAVA动态代理会动态创建一个类似<code>com.sun.proxy.$Proxy0</code>的类，这个类实现了所有的interfaces。在继承关系比较复杂的情况下，个人建议写死会比较好，使用object.getClass().getInterfaces()会出现一些意想不到的情况。比如有接口I1,I2,I3,C1实现了I1,I2，C2继承了C1，且实现了I3，那么一个C2的实例c2.getClass().getInterfaces()返回结果只有I3，无法代理I1和I2。</p>
<p>在实现InvocationHandler接口时，我们需要实现invoke(proxy, method, args)方法，其中可能会调用method.invode(object,args)，当object因为某些原因报错时，method.invode会抛出InvocationTargetException异常：这与所预想抛出的异常不一致，从而导致上层调用者捕捉不到对应的异常。因此最好写成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> method.invoke(client, args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e)&#123;</span><br><span class="line">  <span class="keyword">throw</span> e.getCause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个实现代理的第三方库是<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">cglib</a>。暂时还没看，据说相比于java内置的动态代理，这个库可以不用非要实现某些接口，可以直接拦截。Spring的AOP就是用cglib实现的。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
