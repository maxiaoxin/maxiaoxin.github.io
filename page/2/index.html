<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="读书笔记">
<meta property="og:url" content="https://maxiaoxin.github.io/page/2/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记">
  <link rel="canonical" href="https://maxiaoxin.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/20/trans_and_ACID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/20/trans_and_ACID/" class="post-title-link" itemprop="url">事务与ACID</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-20T00:00:00+08:00">2019-09-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-23 11:12:09" itemprop="dateModified" datetime="2019-09-23T11:12:09+08:00">2019-09-23</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前没太搞懂幻读是什么意思，今天又查了下相关资料，补充一下。</p>
<p>我们可以设想数据库是一系列静态数据的集合，某一时刻这个集合的所有元素及其关系构成了数据库的当前状态，一般来说如果“状态”不变，那么对外相同的读操作返回的结果是一样的；对数据库的写操作（增、删、改）会导致数据库从一个状态转移到另一个状态，而一系列读写操作的序列成为事务。</p>
<p>一般我们会对事务拥有以下一些特性：</p>
<ul>
<li>原子性(atomicity)：这一系列操作要么都成功要么都失败，不允许将数据库状态滞留在某个中间环节</li>
<li>一致性(consistency)：事务只能将数据库从一个有效的（valid）状态迁移到另一个有效的状态</li>
<li>隔离性(isolation)：事务执行时理论上应当观测不到对方是否在执行</li>
<li>持久性(durability)：事务提交并返回成功后，数据库应当保证永远记录其操作结果</li>
</ul>
<p>我看到的说法是一致性是目的，其他三个特性是为了保证一致性的手段</p>
<h3 id="持久性-durability"><a href="#持久性-durability" class="headerlink" title="持久性(durability)"></a>持久性(durability)</h3><p>一般来说所有对数据库的操作都会有保留写日志，且会保存某个正确状态的副本/快照，这样一来一旦某个事务被提交（committed），且我们如果可以保证这个事务相关的写日志不丢，就可以保证事务的持久化。</p>
<h3 id="原子性-atomicity"><a href="#原子性-atomicity" class="headerlink" title="原子性(atomicity)"></a>原子性(atomicity)</h3><p>几乎所有事务都要求要么成功要么失败，而即使是很短的事务也可能执行到一半中途停止，又或者事务提交后觉得不合适又要取消，因此往往会要求事务能够回滚（rollback）。</p>
<p>先不考虑执行完后回滚的情况。显然，既然我们保留了写日志，那么从当前时刻的状态开始反向回放写日志，就可以恢复到事务提交前的状态；为了提高效率，可以在事务执行时设置一些检查点（check point），保存了事务执行到那一步时的数据库（部分）状态，这样回滚的时候直接跳到checkpoint即可。</p>
<p>对于支持MVCC（Multi-Version Concurrency Control，多版本并发控制）的数据库而言，每个事务有一个全局唯一递增的时间戳/版本号，那么理论上只要把有相同时间戳的数据删掉就可以回滚到该事务运行之前，但前提是这个事务的中间结果不可以被其他事务观察到，这也引出了事务的隔离性</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>理想情况是数据库执行事务的时候是顺次执行的，但实际上为了提高效率，事务之间往往是并发执行，因此就导致事务之间很可能相互干扰，常见的干扰有：</p>
<ul>
<li>脏读（dirty read）：事务中的修改，即使未提交也会被其他事务看到</li>
<li>不可重复读（nonrepeatable read）：同一事务内执行时，多次读同一数据，得到的结果不同</li>
<li>幻读（phantom read）：同一事务内执行时，同样的范围查询得到的结果不同</li>
</ul>
<p>幻读和不可重复的读区别在于前者针对的是范围，后者针对的是某条具体的数据，而这点至少可以通过只对某条记录加锁就可以保证。与这三个问题相对应的是四种隔离级别：未提交读（read uncommitted）、提交读（read committed）、可重复读（repeatable reads）、可串行化（serializable），分别解决了三个问题</p>
<p>我理解，“MVCC天然支持快照读，也就天然保证了隔离级别是可重复读”这个想法其实不完全对，假设事务都是先写WAL再落盘，那么在落盘的过程中，如果没有任何保障措施，对于大于该事务时间戳的事务而言，还是会出现不可重复读的情况。</p>
<p>最简单的保障措施就是加锁，缺点是并发量降低。MySql中，MyISAM不支持事务，事务的ACID也就无从谈起；InnoDB引擎的默认隔离级别是可重复读，而上文也提到MVCC并不能保证带时间戳的快照读就等价于可重复读。中文相关的解释可以参考<a href="https://www.zhihu.com/question/67739617/answer/257065584" target="_blank" rel="noopener">关于mysql事务隔离级别MVCC多版本控制的一个疑问？ - 聿明leslie的回答 - 知乎</a>，简单来说就是事务提交成功并落盘的时候，会标明这页的数据被修改过，那么其他事务读到这一页数据的时候需要读最新数据+undo，回退到较早版本再读。</p>
<p>而对于幻读，innodb的做法是加next-key lock，它包括一个行锁和一个区间锁，这样在事务的进行中可以避免其他事务插入/删除要关注的区间。按我理解如果区间无法确定，还是要锁表。</p>
<h3 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h3><p>老实说我还是不太理解这个性质是什么意思，目前理解是数据库不能暴露出事务运行中间的状态。那么在分布式数据库中，某一时刻各个副本内容不同的状态也可以认为是“事务运行中间的状态”？</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/19/jvm9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/19/jvm9/" class="post-title-link" itemprop="url">JVM学习（9）Java内存模型与线程</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-19 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-19T00:00:00+08:00">2019-09-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-18 18:07:23" itemprop="dateModified" datetime="2019-09-18T18:07:23+08:00">2019-09-18</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java的一个重要应用场合是服务端，这对并发处理要求很高，因此JVM需要对并发处理提供足够的支持。</p>
<p>同一台机器上的并发控制主要体现在CPU每个核与其他核数据一致性问题，现代计算机为每个计算单元提供了寄存器缓存，那么访问和修改时可能会因为缓存不一致而导致一些问题。此外，由于指令乱序执行，会导致如果一个线程依赖另一个线程的中间变量时会出现意想不到的后果。</p>
<p><img src="/images/jvm_machine_memory_model.png" alt="处理器、高速缓存、主内存之间的交互关系"></p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>JVM规范试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各种硬件和平台的内存访问差异，实现让java在各种平台下都能达到一致的内存访问效果。如下图所示，可以将JVM内存模型和上图进行一一对应</p>
<p><img src="/images/jvm_memory_model.png" alt="线程、主内存、工作内存之间的交互关系"></p>
<p>JMM的变量主要指实例字段、静态字段、数组中的对象等，而不包括局部变量和方法参数（仅指变量的引用），因为后者是线程私有的，不会被共享，所以是线程安全的。JMM规定所有变量都存储在主内存（Main Memory）中；每个线程还有自己的工作内存（Working Memory），工作内存可以有主缓存中某个部分的缓存，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程之间无法直接访问对方的工作内存，线程间的变量共享只能通过主内存完成。</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>JMM规定了以下8种操作是原子操作，用于内存交互：</p>
<ol>
<li>lock（锁定）：作用于主内存，将一个变量标识为某个线程独占</li>
<li>unlock（解锁）：作用于主内存，将一个变量状态解锁</li>
<li>read（读取）：作用于主内存，将一个变量的值从主内存传输到工作内存</li>
<li>load（载入）：作用于工作内存，把read得到的变量放入工作内存的变量副本中</li>
<li>use（使用）：作用于工作内存，将其中的一个变量的值传递给工作引擎，每当执行引擎遇到一个需要使用变量的值的字节码指令时将会执行这个操作</li>
<li>assign（赋值）：作用于工作内存，将一个从执行引擎接收到的值复制给工作内存的变量，每当执行引擎遇到一个赋值的字节码指令时执行这个操作</li>
<li>store（存储）：作用于工作内存的变量，将工作内中一个变量的值传送到主内存中，以便write操作使用</li>
<li>write（写入）：作用于主内存的变量，将store操作得到的变量放入主内存的变量中</li>
</ol>
<p>JVM还规定这8种操作必须满足以下约束：</p>
<ul>
<li>read和load、store和write要配对使用，且必须顺序执行（但不一定连续）</li>
<li>不允许一个线程丢弃它最近的assign操作，即变量一旦在工作内存中被改变，就必须将其同步到主内存</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）将数据从线程的工作内存同步回主内存</li>
<li>一个新变量只能在主内存中“诞生”，不允许工作内存中直接使用一个未被初始化的值。换言之，在对一个变量进行use、store操作前，必须先执行过assign、load</li>
<li>一个变量在同一时刻只允许一个线程对其进行lock操作，但可以被同一个线程重复执行多次，且只有执行相同次数的unlock后才能解锁该变量</li>
<li>执行lock操作后，工作内存中此变量的值会被清空，在执行引擎使用这个变量前，需要重新执行load或assign操作，初始化变量的值</li>
<li>不允许unlock未被lock的变量，或被其他线程lock的变量</li>
<li>对变量执行unlock前，必须先将此变量同步回主内存</li>
</ul>
<h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><p>对于被<code>volatile</code>修饰的变量，JVM有一些特殊的规定，保证volatile变量有两个特性：</p>
<ul>
<li>可见性：如果volatile变量被一个线程修改过，那么其他线程可以立即得知改变后的值（但不代表它是线程安全的，因为修改过程未必是原子的）</li>
<li>禁止指令重排序优化：禁止volatile变量相关的指令重排序优化</li>
</ul>
<p>可见性很容易理解，指令重排可以举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread A</span></span><br><span class="line">do_initialize();</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread B</span></span><br><span class="line"><span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">do_work();</span><br></pre></td></tr></table></figure>

<p><code>flag</code>变量表示是否初始化，指令重排序优化可能会使得线程A中的<code>flag=true;</code>执行在<code>do_initialize()</code>前，进而导致线程B未初始化的情况下就继续工作。</p>
<p>（其实我以前在c#还是C++里也遇到过这种坑，只是如果<code>flag</code>不被volatile修饰的话，线程B会认为<code>flag</code>一直是<code>false</code>，从而导致循环一直在执行）</p>
<p>一般禁止指令重排序的方式是在相关操作字节码前/后插入一个内存屏障（Memory Barrier或Memory Fence），类似<code>lock addl $0x0, (%esp)</code>之类的空操作，但由于这条指令在cpu执行时一定保证它之后的指令不会被优化到前面，因此保证了这条指令前后的代码块执行时有严格的时间顺序。JMM通过以下额外规则保证volatile变量V,W具有上述性质：</p>
<ul>
<li>对V的load和use操作指令必须连续执行，不可以单独进行load或use，这保证了使用volatile变量的值每次使用时都是从主内存获得的</li>
<li>对V的assign和store操作指令必须连续执行，不可以单独进行assign或store，这保证了volatile变量一旦被修改过立刻同步会主内存</li>
<li>将use-load-read或assign-store-write操作序列记为f1-f2-f3，如果f1(V)在f1(W)前，那么f3(V)在f3(W)前，这保证了volatile变量不会被指令重排序优化</li>
</ul>
<h3 id="long和double变量"><a href="#long和double变量" class="headerlink" title="long和double变量"></a>long和double变量</h3><p>JMM允许对64位的long和double的read、write、load、store操作可以不保证原子性，也就是说理论上存在如果多个线程共享一个非volatile的long或double变量，那么可能会读到一个“修改到一半”的值</p>
<p>几乎所有商用JVM都会保证对long和double的原子性，因此一般也不用专门将long和double声明为volatile</p>
<h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><p>所以JMM是围绕并发过程中如何处理原子性、可见性和有序性来建立的</p>
<ul>
<li>原子性（Atomicity） ：可以认为基本类型的访问读写都是原子性的，而对于更大规模的事务，需要用lock和unlock来进行处理。JVM提供<code>monitorenter</code>和<code>monitorexit</code>两个字节码来隐式使用这两个操作，反映到java代码就是<code>synchronized</code>关键字。</li>
<li>可见性（Visibility）：上文提到<code>volatile</code>可以让一个变量的修改立刻被所有线程感知到，此外<code>synchronized</code>和<code>final</code>关键字也可以提供可见性：由于<code>synchronized</code>隐式调用了unlock，JMM规定unlock前需要先将变量同步回主内存，而其他线程获取这个变量又一定在unlock后；<code>final</code>则是逻辑上保证初始化后才能被其他线程使用</li>
<li>有序性（Ordering）：天然的有序性是指本线程内的进行观察，所有的操作都是有序的（As-If-Serial Semantics），而其他线程观察这一线程则未必（由指令重排/内存同步延迟导致）。可以通过volatile和synchronized来实现有序性。</li>
</ul>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>指令重排序可以提高程序运行效率，但也导致程序执行结果不一定能够保持原意，因此JMM提出了几个先行发生原则。所谓的先行发生（happens-before），是指如果操作A happens before操作B，那么B可以观测到A产生的所有影响。</p>
<p>JMM规定以下所有操作需要保证以下规则：</p>
<ol>
<li>程序次序规则（Program Order Rule）：同一线程内按照程序代码顺序执行，书写在前面的操作要happens-before后面的操作（分支、循环之类的另说）</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作happens-before后面对同一个锁的lock操作，这里“后面”是时间上的顺序</li>
<li>volatile变量规则（Volatile Variable Rule）：对有一个volatile变量的写操作happens-before后面对这个变量的读操作，这里“后面”是时间上的顺序</li>
<li>线程启动原则（Thread Start Rule）：Thread对象的start()方法happens-before此线程的每一个动作</li>
<li>线程终止原则（Thread Termination Rule）：线程中所有操作都happens-before对此线程的终止检测，终止检测是指<code>Thread.join()</code>、<code>Thread.isAlive()</code>等终止和检测方法</li>
<li>线程中断原则（Thread Interruption Rule）：对线程的<code>interrupt()</code>方法的调用happens-before被中断线程的代码检测到中断事件发生，比如<code>Thread.interrupted()</code></li>
<li>对象终结原则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结果）happens-before它的<code>finalize()</code>方法</li>
<li>传递性（Transitivity）：如果操作A happens-before B，B happens-before C，则A happens-before C</li>
</ol>
<p>Java中无需任何同步手段，只要操作间符合以上规则，都可以保证这些操作是“顺序的”。另外A happens-before B不代表A一定在B之前执行，反之亦然，比如两个线程读写同一个非volatile变量，很可能A先对变量赋值，但因为同步延迟，B后读到的值还是原来的；同样的，同一代码块里的指令如果没有依赖性，那么后写的代码也可能被指令重排序到前面执行。</p>
<h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><p>Java提供了不同硬件和平台下对线程的统一处理，每个执行了<code>start()</code>且未结束的<code>java.lang.Thread</code>类实例就代表了一个线程，但具体怎么实现取决于平台。实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程+轻量级线程混合实现。</p>
<h3 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h3><p>内核线程（Kernal-Level Thread，KLT）就是直接由从操作系统内核（Kernal）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。</p>
<p>程序一般不会直接去使用内核线程，而使用内核线程的一种高级接口——轻量级进程（Light Weight Process, LWP），轻量级进程就是通常意义上的进程，一般来说和普通进程的区别也只是它只有一个最小的执行上下文和调度程序所需的统计信息。轻量级进程需要一个内核线程支持，因此这种方式需要内核支持内核线程，对应关系如下：</p>
<p><img src="/images/jvm_KLT.png" alt="内核线程和轻量级进程"></p>
<p>使用内核线程后，线程可以被内核感知到，那么某个线程阻塞后就可以内核自动切换、不会阻塞所有线程，缺点是需要进行系统调用，且占用一定内核资源，而系统支持的轻量级进程数量是有限的。</p>
<h3 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h3><p>广义上讲，非内核线程都是用户线程（包括轻量级进程），而狭义上的用户线程则是由纯应用程序在用户空间模拟的多线程，内核无法感知这些线程之间的切换，其建立、同步、销毁、调度不需要内核的帮助。好处是不需要内核参与，提高了效率，缺点是比如线程阻塞、处理器分配之类的问题很难处理。</p>
<p>从这个角度讲，纯由用户空间模拟的线程，可能更类似于协程？只是调度策略不太一样，毕竟很多协程之间有明显的依赖关系。</p>
<h3 id="使用用户线程-轻量级进程混合实现"><a href="#使用用户线程-轻量级进程混合实现" class="headerlink" title="使用用户线程+轻量级进程混合实现"></a>使用用户线程+轻量级进程混合实现</h3><p>简单来说就是将多个用户线程映射到多个轻量级进程上，降低阻塞概率。很多UNIX系统都提供了这种线程模型的实现。</p>
<h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>JVM未规定Java采用哪种方式实现，JDK1.7为止，在windows和linux上使用了一对一线程模型实现，而在Solaris平台下支持一对一和多对多模型，因此JVM也支持这两种模式。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>主流的线程调度有协同式调度（Cooperative Threads-Scheduling）和抢占式调度（Preemptive Threads-Scheduling），协同式调度是由线程自己来通知系统切换线程，而抢占式调度则是由系统来分配执行时间（比如时间片轮转调度算法）。</p>
<p>显然协同式调度会有线程阻塞问题，所以JVM还是用抢占式调度方式。Java可以设置线程优先级，不过只是对底层的一个建议，不一定严格保证线程优先级。</p>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了5种线程状态，任意线程在同一时间点有且只有其中一个状态：</p>
<ul>
<li>新建（New）：创建后尚未启动</li>
<li>运行（Runnable）：包括操作系统线程的running和ready状态，即可以正在执行，也可能在等待CPU分配时间</li>
<li>等待（Waiting）：不会分配CPU时间，包括无限期等待和有限期等待，都可以被其他线程唤醒，区别在于一定时间过后是否会被系统自动唤醒，进入等待状态的方式包括：<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()、LockSupport.parkNanos()、LockSupport.parkUntil()</li>
</ul>
</li>
<li>阻塞（Blocked）：不会分配CPU时间，与等待的区别是阻塞一般是在等一个排他锁，而等待则是在等一段时间或唤醒动作。</li>
<li>结束（Terminated）：终止状态</li>
</ul>
<p>几种状态的转换关系如下</p>
<p><img src="/images/jvm_thread_state_machine.png" alt="线程状态转换"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/18/jvm8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/18/jvm8/" class="post-title-link" itemprop="url">JVM学习（8）运行期优化</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-18 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-18T00:00:00+08:00">2019-09-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-17 19:32:57" itemprop="dateModified" datetime="2019-09-17T19:32:57+08:00">2019-09-17</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在HotSpot中，java程序最初通过解释器（Interpreter）进行解释执行的，当JVM发现某个方法或代码块运行特别频繁时，就会认为这段代码是热点代码（hot spot code），为提高这部分代码的执行效率，运行时会把其编译为本地平台相关代码，并进行各种层次的优化，完成这个任务的编译器被称为即时编译器（just in time compiler, JIT）。尽管JVM规范并没有要求一定要实现JIT，但一般主流JVM都会做，否则效率太低。</p>
<h2 id="编译时机"><a href="#编译时机" class="headerlink" title="编译时机"></a>编译时机</h2><p><img src="/images/jvm_interpreter_and_compiler.png" alt="解释器和编译器"></p>
<p>如上图所示，主流编译器一般都有解释器和编译器。解释器的优势是能够省去编译过程，立即执行代码；而在运行稳定后，将代码编译为本地代码能够提高执行效率，当然这样也会占用更多内存。此外，当编译器选择激进优化时，如果激进优化假设不成立，那么解释器可以作为“逃生门”，通过逆优化（deoptimization）退回到解释状态继续执行（或者不激进优化的C1编译器）。</p>
<p>HotSpot内置了两个JIT，分别是Client Compiler（C1）和Server Compiler （C2），一般默认采用一个编译器和解释器直接配合的工作方式，用哪种编译器取决于JVM运行模式，HotSpot会根据硬件性能和自身版本选择运行模式，用户也可以通过参数指定模式。解释器和编译器搭配使用的方式被称为混合模式（mix mode），只使用其中某一个分别被称为解释模式（interpreted mode）和编译模式（compiled mode），可以通过<code>-Xint</code>和<code>-Xcomp</code>来选择。</p>
<p>编译成本地代码本来就需要时间，优化程度越高时间越长，且有时候可以通过监控运行时信息来进行优化，时间就会更长。因此HotSpot会启用分层编译（tiered compilation）策略，JDK1.7的server模式将其作为默认策略。分层编译根据编译器编译、优化的规模和耗时，划分出不同的编译层次，包括</p>
<ul>
<li>第0层，解释执行，不开启性能监控功能（profiling），可触发第一层编译</li>
<li>第1层，也称C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如果有必要将加入性能监控逻辑</li>
<li>第2层（或2层以上），也称C2编译，也是将字节码编译为本地代码，但会启用一些耗时较长的优化策略，甚至会根据性能监控信息进行一些不可靠的激进优化</li>
</ul>
<p>分层编译开启后，client compiler和server compiler会同时工作，许多代码会被多次编译。</p>
<h3 id="编译对象和触发条件"><a href="#编译对象和触发条件" class="headerlink" title="编译对象和触发条件"></a>编译对象和触发条件</h3><p>热点代码包括两类：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<p>无论哪种情况，编译器都会选择将整个包含热点的方法作为编译对象，而第二种情况因为编译过程发生在方法执行中，因此被称为栈上替换（on stack replacement, OSR编译）。那么问题就在于如何探测一个方法/循环被执行多少次，以及多少次算热点。探测执行次数的方式有两种：</p>
<ul>
<li>基于采样的热点探测（Sample Based Hot Spot Detection）：周期性的检查各个线程的栈顶，如果某个方法经常出现，那么它就是热点方法。好处是简单高效，且容易获得调用结构，缺点是容易受到线程阻塞或者别的外界因素干扰。</li>
<li>基于计数器的热点探测（Counter Based Hot Spot Detection）：为每个方法/代码块建立和维护计数器，执行次数超过某个值就认为是热点方法。好处是更加准确，缺点是拿不到调用关系而且比较麻烦</li>
</ul>
<p>HotSpot采用第二种方式，且为每个方法准备了两个计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter），两个计数器都有一个确定的阈值，超过阈值后会触发JIT编译。方法调用计数器容易理解，用于记录被调用了多少次，client模式下阈值是1500，server模式下阈值是10000，也可以通过<code>-XX:CompileThreshold</code>设置：更准确的说是频次，即一定时间内的调用次数。如果超过一定时间，那么计数器会减半，这一过程被称为方法调用计数器的热度衰减（Counter Decay），相对应的时间被称为此方法统计的半衰期（Counter Half Life Time），也可以通过参数关闭热度衰减或设置半衰期时间。方法在执行时，会优先选择已被编译好的本地代码版本，如果没有优化好的版本且满足优化条件则会提交一个编译请求，等编译完成后，这个方法的入口地址就会被系统自动改写成新的。</p>
<p><img src="/images/jvm_invocation_counter_workflow.png" alt="方法调用计数器触发即时编译"></p>
<p>回边计数器用来统计一个方法中的循环体代码执行的次数，在字节码遇到控制流向后跳转的指令被称为回边（Back Edge），显然出现回边意味着存在循环。和方法调用计数器不同，回边计数器的阈值通过方法调用计数器阈值（CompileThreshold）、OSR比率（OnStackReplacePercentage）和解释器监控比率（InterpreterProfilePercentage）决定，计算方式为：</p>
<ul>
<li>Client模式下：<code>$CompileThreshold*$OnStackReplacePercentage/100</code>，全取默认值是13995</li>
<li>Server模式下：<code>$CompileThreshold*($OnStackReplacePercentage-$InterpreterProfilePercentage)/100</code>，全取默认值是10700</li>
</ul>
<p>解释器遇到回边指令时，会先查找有没有已经编译好的版本，有的话执行编译后的版本，没有则增加回边计数器，超过阈值时会提交一个OSR编译请求，并降低一些回边计数器的值，以便在循环中等待执行，如下图所示。</p>
<p><img src="/images/jvm_back_edge_counter_workflow.png" alt="回边计数器触发即时编译"></p>
<p>回边计数器没有热衰过程，记录的是绝对运行次数。但无论是哪种编译方式，JVM都默认编译过程可以和解释执行并行执行。用户也可以用<code>-XX:-BackgroundCompilation</code>禁止后台编译，这种情况下达到JIT条件时，用户线程会等待直到编译完成。</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="C1编译器"><a href="#C1编译器" class="headerlink" title="C1编译器"></a>C1编译器</h3><p>C1是一个简单快速的三段式编译器，主要关注局部性优化，放弃了许多耗时较长的全局优化手段。</p>
<ol>
<li>一个平台独立的前端会将字节码构造成一种高级中间代码表示（High-Level Intermediate Representation，HIR）。HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，使得一些在HIR的构造过程中和之后进行的优化动作更容易实现。在此之前编译器会在字节码的基础上完成一部分基础优化，如方法内联、常量传播等。</li>
<li>一个平台相关的后端会从HIR中产生低级中间代码表示方法（Low-Level Intermediate Representation，LIR），在这一步之前会完成另外一些优化，如空值检查消除、范围检查消除等，让HIR达到更高效的代码表达形式</li>
<li>一个平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔优化（Peephole optimization，一种局部的汇编指令优化手段，类似删除冗余的<code>store</code>和<code>load</code>、用左移指令代替乘2指令等，参考<a href="https://blog.csdn.net/liumf2005/article/details/8858102" target="_blank" rel="noopener">窥孔优化 peephole optimization</a>），然后产生机器代码。C1编译过程大致如下图所示。</li>
</ol>
<p><img src="/images/jvm_c1_compiler.png" alt="C1编译器架构"></p>
<h3 id="C2编译器"><a href="#C2编译器" class="headerlink" title="C2编译器"></a>C2编译器</h3><p>C2是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，以及一些和java语言特性密切相关的优化技术</p>
<p>C2编译器的寄存器分配器是一个全局图着色分配器，可以充分利用某些处理器架构（如RISC）上的大部分寄存器集合。总的来说，C2的优化效果更好，但耗时更高。</p>
<h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><p>这里介绍一些常见的优化技术</p>
<h3 id="冗余访问消除（Redundant-Loads-Elimination）"><a href="#冗余访问消除（Redundant-Loads-Elimination）" class="headerlink" title="冗余访问消除（Redundant Loads Elimination）"></a>冗余访问消除（Redundant Loads Elimination）</h3><p>将类似<code>a = foo.a; b = foo.a</code>优化为<code>a = foo.a;b=a;</code>来减少访问，类似公共子表达式消除</p>
<h3 id="常量传播（Constant-Propagation）"><a href="#常量传播（Constant-Propagation）" class="headerlink" title="常量传播（Constant Propagation）"></a>常量传播（Constant Propagation）</h3><p>在编译时将能够计算出结果的变量直接替换成常量</p>
<h3 id="复写传播（Copy-Propagation）"><a href="#复写传播（Copy-Propagation）" class="headerlink" title="复写传播（Copy Propagation）"></a>复写传播（Copy Propagation）</h3><p>如果某个局部变量完全等价于另一个变量，那么就可以用另一个变量来替换，例如将<code>a = foo.a; b = a; s = a+b</code>可以优化为<code>a = foo.a; s = a+a</code></p>
<h3 id="无用代码消除（Dead-Code-Elimination）"><a href="#无用代码消除（Dead-Code-Elimination）" class="headerlink" title="无用代码消除（Dead Code Elimination）"></a>无用代码消除（Dead Code Elimination）</h3><p>移除对程序运行结果没有任何影响的代码，包括不会运行到的代码和只会影响到无关程序运行结果的变量（Dead Variables），比如空循环</p>
<h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>如果一个表达式E已经被计算了，且从开始计算到现在E中所有变量的值都没有发生变化，那么可以复用这个表达式计算结果</p>
<p>此外还可以进行代数简化，比如将<code>d = E * 12 + a + (a + E)</code>变化为<code>d = E * 13 + a * 2</code></p>
<h3 id="循环展开（Loop-Unrolling）"><a href="#循环展开（Loop-Unrolling）" class="headerlink" title="循环展开（Loop Unrolling）"></a>循环展开（Loop Unrolling）</h3><p>增大循环步伐和循环体长度，减少总的循环次数，这样有利于指令并行执行</p>
<h3 id="循环表达式外提（Loop-Expression-Hoisting）"><a href="#循环表达式外提（Loop-Expression-Hoisting）" class="headerlink" title="循环表达式外提（Loop Expression Hoisting）"></a>循环表达式外提（Loop Expression Hoisting）</h3><p>将循环中每次计算结果不变的表达式放在循环前提前计算，从而减少每次循环的计算量</p>
<h3 id="基本块重排序（Basic-Block-Reordering）"><a href="#基本块重排序（Basic-Block-Reordering）" class="headerlink" title="基本块重排序（Basic Block Reordering）"></a>基本块重排序（Basic Block Reordering）</h3><p>通过重排指令提高cache命中率、利用cpu流水线、cpu预读等方式加快运行</p>
<h3 id="范围检查消除（Range-Check-Elimination）"><a href="#范围检查消除（Range-Check-Elimination）" class="headerlink" title="范围检查消除（Range Check Elimination）"></a>范围检查消除（Range Check Elimination）</h3><p>去掉一定不会越界的数组越界检查</p>
<p>此外java还有很多安全检查，比如空值检查、空指针检查、除零检查等，实际上有时候一段代码不见得就安全，但可以认为出错概率很低，因此可以通过增加隐式异常处理来避免安全检查，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以改写为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.value;</span><br><span class="line">&#125; <span class="keyword">catch</span> (segment_fault)&#123;</span><br><span class="line">    uncommon_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即JVM会注册一个Segment Fault信号的异常处理器（对应<code>uncommon_trap()</code>）来进行异常处理，代价是如果发生异常，需要从用户态转到内核态中处理再回到用户态，速度远比一次判空检查慢。</p>
<p>显然如果<code>foo</code>经常为空的话，这种优化会让程序更慢，所以HotSpot会收集运行期信息来选择最佳方案。</p>
<p>类似还有自动装箱消除（Autobox Elimination）、安全点消除（Safepoint Elimination）、反射消除（Dereflection）等都可以通过隐式异常处理进行优化。</p>
<h3 id="分支频率预测（Branch-Frequency-Prediction）"><a href="#分支频率预测（Branch-Frequency-Prediction）" class="headerlink" title="分支频率预测（Branch Frequency Prediction）"></a>分支频率预测（Branch Frequency Prediction）</h3><p>激进优化，预先执行极有可能被选择的分支，提高流水线效率</p>
<h3 id="内联（Method-inlining）"><a href="#内联（Method-inlining）" class="headerlink" title="内联（Method inlining）"></a>内联（Method inlining）</h3><p>方法内联很容易理解：将不会被复写的方法代码“copy”到调用点，这样减少方法调用成本（如建立栈帧等），且能够为其他优化建立良好的基础。</p>
<p>由<code>invokevirtual</code>指令调用的非<code>final</code>方法原则上无法内联，原因在于运行期间无法确定这个方法是否被复写过。但其实很多方法只有一个版本，那么可以想办法对这种方法进行内联，比如</p>
<ol>
<li>类型继承关系分析（Class Hierarchy Analysis，CHA）：分析所有已加载的类的继承关系，确定某些方法是否多余一种的实现，如果没有则可以内联</li>
<li>内联缓存（Inline Cache）：在调用时记录内联方法的版本并缓存相关代码，如果之后的访问命中缓存则可以继续执行内联，否则进行正常调用</li>
</ol>
<p>多数情况下内联是一种激进的优化策略，如果内联失败时需要有一个备用方案，需要预留一个逃生门，这种内联被称为守护内联（Guarded Inlining）。</p>
<h3 id="逃逸分析（Escape-Analysis）"><a href="#逃逸分析（Escape-Analysis）" class="headerlink" title="逃逸分析（Escape Analysis）"></a>逃逸分析（Escape Analysis）</h3><p>即分析对象动态作用域，比如一个对象在某个方法中被定义后，如果能够被其他方法引用，则称为方法逃逸；如果某个线程定义的对象被其他线程引用到，则称为线程逃逸。显然，如果能够分析出一个对象不会逃逸出某个范围，那么就可以针对这一特性进行优化，比如：</p>
<ol>
<li>栈上分配（Stack Allocation）：如果确定一个变量不会逃逸出方法之外，那么就可以在栈上分配这个对象，提高分配/回收效率，避免GC过程</li>
<li>同步消除（Synchronization Elimination）：如果确定一个变量不会逃逸出线程，那么这个变量的读写就不会有竞争，可以取消对这个变量的同步过程</li>
<li>标量替换（Scalar Replacement）：如果一个对象不会被外部访问，且可以拆分，那么不创建这个对象，而改为创建它的若干个被引用到的变量。标量替换后还可以提高分配和读写效率（栈上分配）外，还可以进一步被其他优化手段优化（比如复写传播等）</li>
</ol>
<p>JDK1.8默认开启逃逸分析，也可以通过<code>-XX:-DoEscapeAnalysis</code>关闭</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/16/jvm7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/16/jvm7/" class="post-title-link" itemprop="url">JVM学习（7）编译期优化</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-16 00:00:00 / Modified: 21:08:08" itemprop="dateCreated datePublished" datetime="2019-09-16T00:00:00+08:00">2019-09-16</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一章主要介绍关于在.java代码编译为.class文件时使用的一些优化技术。实际操作时一般用javac来实现，其编译过程大致分为3个过程：</p>
<ol>
<li>解析和填充符号表</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程</li>
</ol>
<p>这三个步骤的关系如下：</p>
<p><img src="/images/jvm_compile_process.png" alt="javac编译顺序"></p>
<p>Javac编译动作入口是<code>com.sun.tools.javac.main.JavaCompiler</code>类，基本流程如下</p>
<p><img src="/images/jvm_javac_flow.png" alt="javac"></p>
<h2 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h2><h3 id="词法和语法分析"><a href="#词法和语法分析" class="headerlink" title="词法和语法分析"></a>词法和语法分析</h3><p>词法分析是将源码的字符流转变为标记（token）集合的过程，词法分析由<code>com.sun.tools.javac.parser.Scanner</code>来实现。</p>
<p>语法分析是根据token序列构造抽象语法树（abstract syntax tree，AST），它的每个节点代表一个语法结构（construct），语法分析由<code>com.sun.tools.javac.tree.JCTree</code>来实现。之后的操作都是基于AST。</p>
<h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><p>填充符号表的过程对应上图中的<code>enterTrees()</code>，符号表（symbol table）是由一组符号地址和符号信息构成的表格，在各个编译阶段都会用到：语义分析时，需要根据符号表进行语义检查（如检查一个名字的使用是否和声明一致）和产生中间代码；在目标代码生成阶段，在对符号进行地址分配时需要用到符号表。</p>
<p>这个阶段由<code>com.sun.tools.javac.comp.Enter</code>类来实现，其出口是一个待处理列表（to do list），包含了每一个编译单元的AST顶级节点，以及package-info.java（如果有的话）的顶级节点</p>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>JDK1.5后支持了注解（annotation），可以作用于运行期；JDK1.6后提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，即允许开发者对编译器的行为做一定干涉。</p>
<p>具体可以参考<a href="https://github.com/linxiaoyang/JSR269TEST" target="_blank" rel="noopener">实践JSR269关于编译期注解的使用且搞清Lombok实现原理</a>，注意如果是自己写的话，要依赖<code>$JAVA_HOME/lib/tools.jar</code>这个包，并且由于这个步骤在编译期而非运行期，调试时需要对类似<code>javac -processor ...</code>这样的命令进行调试。</p>
<h2 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h2><p>得到AST不代表源码符合逻辑，因此需要再对其进行语义检查和分析，包括标注检查和控制流分析两个步骤，分别对应图1中<code>attribute()</code>和<code>flow()</code>方法</p>
<h3 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h3><p>主要检查类似变量使用前是否被声明、变量与赋值之间的数据类型是否匹配、常量折叠等。常量折叠是针对能在编译期计算出来的常量进行计算和简化，减少运行期负担。相关的类是<code>com.sun.tools.javac.comp.Attr</code>和<code>com.sun.tools.javac.comp.Check</code>。</p>
<h3 id="数据和控制流分析"><a href="#数据和控制流分析" class="headerlink" title="数据和控制流分析"></a>数据和控制流分析</h3><p>和类加载时控制流分析类似，可以检查出诸如程序局部变量在使用前是否赋值、方法的每条路径是否都有返回值、所有异常都被处理等。还有些只能在编译期检查出来，比如一个局部变量被声明为<code>final</code>，可能编译出来的.class文件会没有相关修饰符，而编译期可以检查这个变量是否被修改过。相关的类是<code>com.sun.tools.javac.comp.Flow</code>。</p>
<h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>语法糖（syntactic sugar）是指编程语言中增加的某些语法，它对语言功能没有影响，但更方便书写。Java的语法糖比如泛型（类型擦除）、变长参数（传个数组进去）、自动拆箱/装箱（如<code>int</code>和<code>Integer</code>转换）。这些语法糖在编译期会被还原成基础的语法结构。相关的类是<code>com.sun.tools.javac.comp.TransTypes</code>和<code>com.sun.tools.javac.comp.Lower</code>。</p>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>JDK1.5后增加了泛型，不过java是伪泛型：比如<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>在java里是同一类，而在C#里是两个不同的类，java在编译后会把具体类型替换为Object，在相关位置加入强制类型转换代码。</p>
<p>不过类型擦除只是对Code属性中的字节码进行擦除，Signature里还有泛型信息，因此可以通过反射得到参数化类型，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(List&lt;T&gt; a, Set&lt;Integer&gt; b)</span></span>&#123;</span><br><span class="line">    a.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class cls = HelloWorld.class;</span><br><span class="line">    Method method = cls.getDeclaredMethod(<span class="string">"hello"</span>, List.class, Set.class);</span><br><span class="line">    System.out.println(((ParameterizedTypeImpl)method.getGenericParameterTypes()[<span class="number">0</span>]).getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(((ParameterizedTypeImpl)method.getGenericParameterTypes()[<span class="number">1</span>]).getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T</span></span><br><span class="line"><span class="comment">// class java.lang.Integer</span></span><br></pre></td></tr></table></figure>

<h4 id="自动装箱-拆箱和遍历循环"><a href="#自动装箱-拆箱和遍历循环" class="headerlink" title="自动装箱/拆箱和遍历循环"></a>自动装箱/拆箱和遍历循环</h4><p>这些解释起来比较简单，比如这样一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : list)&#123;</span><br><span class="line">      s += i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可能会被翻译为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">        Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">4</span>)&#125;);</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator iter = list.iterator(); iter.hasNext();)&#123;</span><br><span class="line">      <span class="keyword">int</span> i = ((Integer)iter.next()).intValue();</span><br><span class="line">      s += i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当然自动拆箱/装箱里有些坑，比如各路面试里都特别喜欢考因为类似<code>IntegerCache</code>及其上下界，导致自动装箱后的引用相同等等。简单来说由于<code>Integer</code>等类型是不可变的，也就不用担心线程安全等问题，因此可以对一些经常出现的常量（比如<code>Integer.valueOf()</code>）这种的可以进行cache，比如<code>Integer</code>里默认会对<code>[-128, 127]</code>这个范围内的数字进行cache，避免每次因为<code>Integer.valueOf()</code>创建新的对象。不过<code>new Integer()</code>总会创建新的对象。</p>
<p>另一个坑是循环时对数组进行操作，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"123"</span>);</span><br><span class="line">    list.add(<span class="string">"456"</span>);</span><br><span class="line">    list.add(<span class="string">"798"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">      list.remove(s);</span><br><span class="line">      System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 报错java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>

<p>解语法糖后可以看到这种删除方式会导致迭代器不可用，因此需要改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; iter = list.iterator(); iter.hasNext();)&#123;</span><br><span class="line">  System.out.println(iter.next());</span><br><span class="line">  iter.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>Java默认如果检测到某条分支永远不会执行到，会拒绝编译，最典型的是<code>return;</code>后的语句。所以一般会用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这样的方式来避免拒绝编译。实际上控制流分析后也会把相关代码忽略掉。</p>
<p>另外比如内部类、枚举类、断言语句、<code>switch</code>枚举类和字符串、<code>try</code>的自动关闭资源等都是通过语法糖实现的。</p>
<h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>字节码生成是javac编译过程的最后一个阶段，由<code>com.sun.tools.javac.jvm.Gen</code>类完成，除了将之前生成的信息转为字节码落盘外，还进行了少量代码添加和转换工作。比如把<code>&lt;cinit&gt;()</code>涉及到的语句合并在一起、将字符串加操作用<code>StringBuilder</code>或<code>StringBuffer</code>替换等。</p>
<p>完成对语法树的遍历和调整后，会把填充了所有所需信息的符号表交给<code>com.sun.tools.javac.jvm.ClassWriter.writeClass()</code>来输出为字节码文件。至此编译结束。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/10/jvm6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/10/jvm6/" class="post-title-link" itemprop="url">JVM学习（6）JVM字节码执行引擎</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-10T00:00:00+08:00">2019-09-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-12 17:11:08" itemprop="dateModified" datetime="2019-09-12T17:11:08+08:00">2019-09-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于JVM规范本身就是个虚拟概念，因此JVM执行引擎也是个标准，具体实现时会有优化，但要保证执行语义符合规范：即从外观（facade）上看，所有JVM虚拟机的执行引擎都是一致的。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧（stack frame）是用于支持JVM进行方法调用和方法执行的数据结构，是运行时数据区中虚拟机栈（virtual machine stack）的栈数据，栈帧保存了方法的局部变量表、操作数栈、动态连接、方法返回地址等信息。之前提到方法表Code属性，里面有栈帧大小的限制，因此一个栈帧占用内存大小在编译期就决定了，具体占多大内存取决于JVM实现。</p>
<p><img src="/images/jvm_stack_frame.png" alt="栈帧结构"></p>
<p>对于某个线程而言，只有栈顶的栈帧是有效的（称为当前栈帧<code>current stack frame</code>），与其相关联的方法称为当前方法<code>current method</code>，所有字节码指令都只针对当前栈帧操作。</p>
<p>与大多数物理机使用基于寄存器的指令框架不同，JVM使用的是基于栈的架构，比如两个数相加需要先把两个数入栈，然后<code>iadd</code>指令把栈顶两个数拿出来相加再入栈，而寄存器就没这么麻烦。一般来说基于栈的指令集会慢一些，好处是可移植，比如上图中的各个区域的大小都可以随便调整（相对的，同一物理机的每个寄存器的特性都不太一样，不同物理机可能寄存器数目都不一样），所以JVM实际执行的时候会对这些指令进行优化。</p>
<h3 id="局部变量表（local-variable-table）"><a href="#局部变量表（local-variable-table）" class="headerlink" title="局部变量表（local variable table）"></a>局部变量表（local variable table）</h3><p>用于存放方法参数和方法内部定义的局部变量，方法的Code属性的<code>max_locals</code>数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表的基本单位是slot，规范没有指明一个slot有多大，只是说每个slot都可以存放一个<code>boolean, byte, char, shot, int, float, reference, returnAddress</code>类型，那么具体实现的时候，一个slot可以用32位，也可以用64位来存。其中，JVM没有指定<code>reference</code>长度一定要多少，甚至可以不是指针，但要求它能做到：</p>
<ul>
<li>从这个引用可以直接或间接地查找到对象在java堆中的数据存放的起始地址索引</li>
<li>从这个引用可以直接或间接地查找到对象所属数据类型在方法区中存储的类型信息（RTTI）</li>
</ul>
<p><code>returnAddress</code>现在用的比较少，较早的JVM使用这条指令实现异常处理，现在由异常表代替。</p>
<p><code>long</code>和<code>double</code>要求是64位，因此一般会占两个slot。对局部变量表的索引从0开始，以slot为单位，如果遇到连在一起的slot却分开用时应该抛出异常。JVM通过局部变量表来实现参数传递的，如果方法不是静态方法，那么会先把<code>this</code>传为第0号局部变量，之后的参数顺序写入。参数分配完后再根据方法体内部定义的变量顺序和作用域分配其余slot。</p>
<p>可以通过重复利用slot来节省栈帧空间，比如当前字节码PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的slot就可以交给其他变量使用。更进一步，如果之前的变量所在的slot被复写了，那么它所指的object就可以被回收，相反如果没被复写，即使超出了它的作用域也不一定会被及时回收。一个技巧是可以及时为变量赋值为<code>null</code>来加快GC。</p>
<p>最后，java不会为局部变量预设初始值，因此开发人员必须手动为局部变量设初值，否则编译不过，也通不过JVM字节码校验。</p>
<h3 id="操作数栈（operand-stack）"><a href="#操作数栈（operand-stack）" class="headerlink" title="操作数栈（operand stack）"></a>操作数栈（operand stack）</h3><p>用于进行具体运算，方法的Code属性的<code>max_stack</code>定义了操作数栈的最大深度，且单位也是slot。方法开始执行的时候操作数栈为空，随着方法运行会有各种入栈出栈操作，且操作数栈中的数据类型必须和字节码指令的序列严格匹配，不过这个是在编译期和校验期做的。</p>
<p>另外，理论上栈帧之间是完全独立的，实际上可以做一些优化，让两个栈帧部分重叠，这样就避免了额外的参数传递。</p>
<p><img src="/images/jvm_stack_share_vars.png" alt="两个栈帧之间数据共享"></p>
<h3 id="动态连接（dynamic-linking）"><a href="#动态连接（dynamic-linking）" class="headerlink" title="动态连接（dynamic linking）"></a>动态连接（dynamic linking）</h3><p>每个栈帧都包含一个指向常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态调用（dynamic linking）。C++是通过虚函数表来实现多态的，而JAVA则是通过先查找所属类、再解析符号引用/函数表来确定调用哪个方法。</p>
<h3 id="方法返回地址（Normal-Abrupt-Method-Invocation-Completion）"><a href="#方法返回地址（Normal-Abrupt-Method-Invocation-Completion）" class="headerlink" title="方法返回地址（Normal/Abrupt Method Invocation Completion）"></a>方法返回地址（Normal/Abrupt Method Invocation Completion）</h3><p>方法返回分为两种，一种是正常遇到返回指令结束方法调用，另一种是抛出异常且没有被正确处理（此时没有返回值）。无论如何退出，都需要在栈帧中保存一些信息，以便返回值上层调用位置。</p>
<p>方法退出时需要将栈帧出栈，需要恢复上层方法的局部变量表和操作数栈，将返回值（如果有）压入上层的操作数栈，调整PC计数器的值以指向方法调用指令后的一条指令等。</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>JVM允许添加一些附加信息到栈帧（比如调试信息），取决于JVM具体实现。一般把动态连接、方法返回地址和其他附加信息全部归位一类，称为栈帧信息。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用在方法执行之前，目的是找到应当调用哪个方法。由于class文件没有类似C的连接步骤，一切方法调用都是符号引用，因此需要先将符号引用解析为直接引用，而实际上可能需要在类加载期间、甚至在运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析（resolution）"><a href="#解析（resolution）" class="headerlink" title="解析（resolution）"></a>解析（resolution）</h3><p>首先，JVM提供了5中调用字节码的指令，分别是：</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用实例构造器<code>&lt;init&gt;</code>、私有方法、父类方法</li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</li>
</ul>
<p>在之前的章节提到过，类加载过程中有解析的步骤，其中会把一部分符号引用转换为直接引用，而能够转换的前提是在执行前就能确定是哪个方法，且在运行中不可变。符合这一条件的方法有：静态方法、私有方法、实例构造器、父类方法、final方法这几种。关于final方法，可以参考<a href="https://juejin.im/entry/58c4811161ff4b005d94fed2" target="_blank" rel="noopener">Final of Java，这一篇差不多了</a>，简单来说即final方法还是用<code>invokevirtual</code>调用，但可以在编译期确定，且可以被内联。</p>
<h3 id="分派（dispatch）"><a href="#分派（dispatch）" class="headerlink" title="分派（dispatch）"></a>分派（dispatch）</h3><p>解析调用可以在编译阶段唯一确定，而分派调用则可以是静态的或动态的，且根据宗量（argument，个人理解是方法签名）可以分为单分派和多分派，两两组合可以分为静态单分派、静态多分派、动态单分派、动态多分派。</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>编译期根据调用时的类型来确定使用哪个签名，值得注意的地方有两点：</p>
<ol>
<li>是编译器“看到”的参数类型，而不是实际类型。比如<code>foo((A)B)</code>和<code>foo(B)</code>可能调用了两个完全不同的方法。这个类型称为静态类型（static type）或外观类型（apparent type）</li>
<li>如果没有严格匹配的方法，那么编译器会尝试类型转换，选择一个更为“合适”的方法，比如对于<code>foo(char)</code>、<code>foo(int)</code>、<code>foo(Character)</code>、<code>foo(char...)</code>这几个方法时，如果输入参数是<code>&#39;a&#39;</code>，那么调用优先级依次降低。</li>
</ol>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派，Java的动态分派主要通过<code>invokevirtual</code>指令来实现，这个指令运行时解析过程大致分为以下几步：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C</li>
<li>从这个类开始，按照继承关系从下到上查找匹配的方法，如果找到则进行权限校验，通过则返回这个方法的直接引用，否则抛出<code>java.lang.illegalAccessError</code></li>
<li>如果一直没找到，则抛出<code>java.lang.AbstractMethodError</code></li>
</ol>
<h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><p>简单来说就是根据一个参数还是多个参数来进行分派（包括<code>this</code>）。事实上，java只支持静态多分派和动态单分派，即的动态分派只根据<code>this</code>来选择方法版本。C# 4.0后通过<code>dynamic</code>关键字可以支持动态多分配，参考<a href="https://chodounsky.net/2014/01/29/dynamic-dispatch-in-c-number/" target="_blank" rel="noopener">Dynamic Dispatch in C#</a>，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface IBar &#123;&#125;</span><br><span class="line">public class Bar : IBar &#123;&#125;</span><br><span class="line">public sealed class FooBar : Bar &#123;&#125;</span><br><span class="line"></span><br><span class="line">// Simple helper for demonstration</span><br><span class="line">public static class ConsolePrinter</span><br><span class="line">&#123;</span><br><span class="line">    public static void Print(IBar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;IBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Print(Bar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Print(FooBar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;FooBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new Bar();</span><br><span class="line">var foo = new FooBar();</span><br><span class="line">IBar ibar = new FooBar();</span><br><span class="line"></span><br><span class="line">IBar[] items = &#123; bar, foo, ibar &#125;;</span><br></pre></td></tr></table></figure>

<p>定义了三个不同的实例，放到同一个数组里，那么执行的结果应当是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach (var item in items)</span><br><span class="line">&#123;</span><br><span class="line">    ConsolePrinter.Print(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints IBar</span><br><span class="line">// prints IBar</span><br><span class="line">// prints IBar</span><br></pre></td></tr></table></figure>

<p>而如果在foreach循环中用dynamic来解释，结果就不同了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach (dynamic item in items)</span><br><span class="line">&#123;</span><br><span class="line">    ConsolePrinter.Print(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints Bar</span><br><span class="line">// prints FooBar</span><br><span class="line">// prints FooBar</span><br></pre></td></tr></table></figure>

<p>这意味着C#中会在运行时解析dynamic类型，拿到具体的对应类型后再决定方法签名，也就实现了动态多分派（虽然这个例子只有一个参数，还是单分配）</p>
<h4 id="动态分派的实现"><a href="#动态分派的实现" class="headerlink" title="动态分派的实现"></a>动态分派的实现</h4><p>理论上可以在运行时解析方法的符号链接，不过一般在实现中会用虚方法表（virtual method table, vtable，类似在<code>invokeinterface</code>时会用到interface method table, itable），如下图所示：</p>
<p><img src="/images/jvm_vtable.jpg" alt="JVM 虚方法表"></p>
<p>每个类维护了一个虚表，如果没有重写某个方法，就和父类的入口地址保持一致，这些可以在载入时实现。</p>
<h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>动态类型语言的关键特征是，它的类型检查的主体过程在运行期而非编译期。JVM中<code>invokespecial、invokevirtual、invokeinterface、invokestatic</code>的“参数”实际上都包含了“哪个类中的哪个方法”这一信息。比如<code>foo.bar()</code>这个调用，如果<code>foo</code>所声明的类型没有实现<code>bar()</code>方法，那么就无法编译通过；而在动态类型语言中，甚至可以不要求<code>bar()</code>被定义过都有可能正常执行，即使<code>foo</code>确实没定义过这个方法、也没有相关的语法糖，只要没执行到这条语句也不会报错。</p>
<p>JDK1.7后引入了<code>invokedynamic</code>指令和<code>java.lang.invoke</code>包，用以实现动态调用，而在JDK1.8里引入的lambda表达式使用了<code>invokedynamic</code>，具体可以参考<a href="https://colobu.com/2014/11/06/secrets-of-java-8-lambda/" target="_blank" rel="noopener">Java 8 Lambda 揭秘</a>和<a href="https://my.oschina.net/haogrgr/blog/367391" target="_blank" rel="noopener">JDK8中Lambda表达式底层实现浅析(一)</a>。在学习<code>invokedynamic</code>之前，需要先了解<code>MethodHandle</code>。</p>
<h4 id="MethodHandle"><a href="#MethodHandle" class="headerlink" title="MethodHandle"></a>MethodHandle</h4><p>简单来说<code>MethodHandle</code>有点像C/C++的函数指针，在此之前java为了实现函数指针需要用<code>interface</code>，而使用<code>interface</code>时需要先实例化一个类再调用这个类的某个方法，<code>MethodHandle</code>相对来说会“轻量级”一些，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"foo1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"foo2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? <span class="keyword">new</span> Foo1() : <span class="keyword">new</span> Foo2();</span><br><span class="line">    getPrintlnMH(obj).invokeExact();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">    <span class="keyword">return</span> MethodHandles.lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodHandles.lookup().findVirtual()</code>用以查找在指定类中符合给定方法签名且符合调用权限的方法句柄，并且由于这个方法不是静态方法，需要绑定<code>this</code>，所以要把<code>reveiver</code>传给<code>bindTo()</code>。</p>
<p>可以看到Foo1和Foo2之间没有继承关系，也可以通过方法签名找到并调用指定方法：这和反射有些相似，但反射（reflection）和MethodHandle实际区别很大：</p>
<ol>
<li>反射是在模拟java代码层次的方法调用，而MethodHandle是在模拟字节码层次的调用，比如<code>MethodHandles.lookup()</code>中的<code>findStatic()、findVirtual()、findSpecial()</code>分别对应字节码<code>invokestatic、invokevirtual&amp;invokeinterface、invokespecial</code>这几个字节码指令的执行权限调用行为，这在使用反射时不需要关心</li>
<li>反射中的<code>java.lang.reflect.Method</code>对象远比<code>MethodHandle</code>机制中的<code>java.lang.invoke.MethodHandle</code>对象所含的信息多，前者是方法在java一端的全面映像，包含了方法的签名、描述符、方法属性表中的各种属性的java端表示方式、执行权限等信息，而后者只包含与执行该方法相关的信息。</li>
<li>原则上由于<code>MethodHandle</code>是字节码调用的模拟，理论上可以在这方面做一些优化。</li>
<li>反射API设计目标是为java语言服务的，而<code>MethodHandle</code>则设计为可以为所有JVM支持的语言服务。</li>
</ol>
<h4 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h4><p>某种程度上<code>invokedynamic</code>和<code>MethodHandle</code>的目标类似，都是为了解决<code>invoke*</code>的分派规则由JVM决定的问题，让开发者有更高的查找目标方法的自由度。JDK1.8实现lambda表达式时使用了<code>invokedynamic</code>，下面是一段代码和它对应的反编译数据，生成的.class在<a href="/files/HelloWorld.class">这里</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    Runnable r = ()-&gt; System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">#1 = Methodref          #8.#27         // java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">   <span class="comment">#2 = InvokeDynamic      #0:#32         // #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">   <span class="comment">#3 = InterfaceMethodref #33.#34        // java/lang/Runnable.run:()V</span></span><br><span class="line">   <span class="comment">#4 = Fieldref           #35.#36        // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   <span class="comment">#5 = String             #37            // hello</span></span><br><span class="line">   <span class="comment">#6 = Methodref          #38.#39        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   <span class="comment">#7 = Class              #40            // HelloWorld</span></span><br><span class="line">   <span class="comment">#8 = Class              #41            // java/lang/Object</span></span><br><span class="line">   <span class="comment">#9 = Utf8               &lt;init&gt;</span></span><br><span class="line">  <span class="comment">#10 = Utf8               ()V</span></span><br><span class="line">  <span class="comment">#11 = Utf8               Code</span></span><br><span class="line">  <span class="comment">#12 = Utf8               LineNumberTable</span></span><br><span class="line">  <span class="comment">#13 = Utf8               LocalVariableTable</span></span><br><span class="line">  <span class="comment">#14 = Utf8               this</span></span><br><span class="line">  <span class="comment">#15 = Utf8               LHelloWorld;</span></span><br><span class="line">  <span class="comment">#16 = Utf8               main</span></span><br><span class="line">  <span class="comment">#17 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#18 = Utf8               args</span></span><br><span class="line">  <span class="comment">#19 = Utf8               [Ljava/lang/String;</span></span><br><span class="line">  <span class="comment">#20 = Utf8               r</span></span><br><span class="line">  <span class="comment">#21 = Utf8               Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#22 = Utf8               Exceptions</span></span><br><span class="line">  <span class="comment">#23 = Class              #42            // java/lang/Throwable</span></span><br><span class="line">  <span class="comment">#24 = Utf8               lambda$main$0</span></span><br><span class="line">  <span class="comment">#25 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#26 = Utf8               HelloWorld.java</span></span><br><span class="line">  <span class="comment">#27 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span></span><br><span class="line">  <span class="comment">#28 = Utf8               BootstrapMethods</span></span><br><span class="line">  <span class="comment">#29 = MethodHandle       #6:#43         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#30 = MethodType         #10            //  ()V</span></span><br><span class="line">  <span class="comment">#31 = MethodHandle       #6:#44         // invokestatic HelloWorld.lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#32 = NameAndType        #45:#46        // run:()Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#33 = Class              #47            // java/lang/Runnable</span></span><br><span class="line">  <span class="comment">#34 = NameAndType        #45:#10        // run:()V</span></span><br><span class="line">  <span class="comment">#35 = Class              #48            // java/lang/System</span></span><br><span class="line">  <span class="comment">#36 = NameAndType        #49:#50        // out:Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#37 = Utf8               hello</span></span><br><span class="line">  <span class="comment">#38 = Class              #51            // java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#39 = NameAndType        #52:#53        // println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#40 = Utf8               HelloWorld</span></span><br><span class="line">  <span class="comment">#41 = Utf8               java/lang/Object</span></span><br><span class="line">  <span class="comment">#42 = Utf8               java/lang/Throwable</span></span><br><span class="line">  <span class="comment">#43 = Methodref          #54.#55        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#44 = Methodref          #7.#56         // HelloWorld.lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#45 = Utf8               run</span></span><br><span class="line">  <span class="comment">#46 = Utf8               ()Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#47 = Utf8               java/lang/Runnable</span></span><br><span class="line">  <span class="comment">#48 = Utf8               java/lang/System</span></span><br><span class="line">  <span class="comment">#49 = Utf8               out</span></span><br><span class="line">  <span class="comment">#50 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#51 = Utf8               java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#52 = Utf8               println</span></span><br><span class="line">  <span class="comment">#53 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#54 = Class              #57            // java/lang/invoke/LambdaMetafactory</span></span><br><span class="line">  <span class="comment">#55 = NameAndType        #58:#62        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#56 = NameAndType        #24:#10        // lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#57 = Utf8               java/lang/invoke/LambdaMetafactory</span></span><br><span class="line">  <span class="comment">#58 = Utf8               metafactory</span></span><br><span class="line">  <span class="comment">#59 = Class              #64            // java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  <span class="comment">#60 = Utf8               Lookup</span></span><br><span class="line">  <span class="comment">#61 = Utf8               InnerClasses</span></span><br><span class="line">  <span class="comment">#62 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#63 = Class              #65            // java/lang/invoke/MethodHandles</span></span><br><span class="line">  <span class="comment">#64 = Utf8               java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  <span class="comment">#65 = Utf8               java/lang/invoke/MethodHandles</span></span><br><span class="line">&#123;</span><br><span class="line">  public HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LHelloWorld;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.Throwable;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: invokedynamic <span class="comment">#2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">         5: astore_1</span><br><span class="line">         6: aload_1</span><br><span class="line">         7: invokeinterface <span class="comment">#3,  1            // InterfaceMethod java/lang/Runnable.run:()V</span></span><br><span class="line">        12: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 6</span><br><span class="line">        line 5: 12</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      13     0  args   [Ljava/lang/String;</span><br><span class="line">            6       7     1     r   Ljava/lang/Runnable;</span><br><span class="line">    Exceptions:</span><br><span class="line">      throws java.lang.Throwable</span><br><span class="line"></span><br><span class="line">  private static void lambda<span class="variable">$main</span><span class="variable">$0</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line">         0: getstatic     <span class="comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         3: ldc           <span class="comment">#5                  // String hello</span></span><br><span class="line">         5: invokevirtual <span class="comment">#6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"HelloWorld.java"</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     public static final <span class="comment">#60= #59 of #63; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: <span class="comment">#29 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">    Method arguments:</span><br><span class="line">      <span class="comment">#30 ()V</span></span><br><span class="line">      <span class="comment">#31 invokestatic HelloWorld.lambda$main$0:()V</span></span><br><span class="line">      <span class="comment">#30 ()V</span></span><br></pre></td></tr></table></figure>

<p><code>invokedynamic</code>的操作形式是<code>invokedynamic indexbyte1 indexbyte2 0 0</code>，其中后两个0是写死的以便之后扩展，前两个参数联合起来<code>(indexbyte1 &lt;&lt; 8) | indexbyte2</code>指向常量池中的一项被称为动态调用点（call site）的符号引用，这里为字节码为<code>ba 0002 00 00</code>，即CallSite为第二个常量，其结构体声明为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_InvokeDynamic_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 bootstrap_method_attr_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>bootstrap_method_attr_index</code>指向了<code>bootstrap_methods</code>数组中的某个<code>bootstrap method</code>，从反编译出的信息可以看到这个<code>invokedynamic</code>的字节码指令为<code>12 0000 0020</code>，标明它的引导方法是第0个，方法类型参考第32个常量<code>run:()Ljava/lang/Runnable;</code>。引导方法<code>Bootstrap Method</code>被保存在新增的<code>BootstrapMethods</code>属性中，其完整定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 num_bootstrap_methods;</span><br><span class="line">    &#123;   u2 bootstrap_method_ref;</span><br><span class="line">        u2 num_bootstrap_arguments;</span><br><span class="line">        u2 bootstrap_arguments[num_bootstrap_arguments];</span><br><span class="line">    &#125; bootstrap_methods[num_bootstrap_methods];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里相关的二进制代码为<code>1c 00 00 00 0c 00 01 00 1d 00 03 00 1e 00 1f 00 1e</code>，表示只有一个引导方法，对应的<code>MethodHandle</code>为<code>java/lang/invoke/LambdaMetafactory.metafactory</code>这一静态方法，其完整签名为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">metafactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MethodHandles.Lookup caller, // 代表查找上下文与调用者的访问权限, 使用invokedynamic指令时, JVM会自动自动填充这个参数, 这里JVM为我们填充为Lookup(HelloWorld.class, (PUBLIC | PRIVATE | PROTECTED | PACKAGE)</span>) 意思是这个Lookup实例可以访问HelloWorld类的所有成员.</span></span><br><span class="line"><span class="function">    String invokedName,  <span class="comment">//  要实现的方法的名字, 使用invokedynamic时, JVM自动帮我们填充(填充内容来自常量池InvokeDynamic.NameAndType.Name), 这里填充为run</span></span></span><br><span class="line"><span class="function">    MethodType invokedType,  <span class="comment">// 调用点期望的方法参数的类型和返回值的类型(方法signature). 使用invokedynamic指令时, JVM会自动自动填充这个参数，填充内容来自常量池InvokeDynamic.NameAndType.Type), 在这里参数为空, 返回值类型为java/lang/Runnable, 表示这个调用点的目标方法的参数为空, 然后invokedynamic执行完后会返回一个Runnable实例</span></span></span><br><span class="line"><span class="function">    MethodType samMethodType,  <span class="comment">// 函数对象将要实现的接口方法类型, 这里运行时, 值为()V，即Runnable.run()方法的类型</span></span></span><br><span class="line"><span class="function">    MethodHandle implMethod, <span class="comment">// 一个直接方法句柄(DirectMethodHandle), 描述在调用时将被执行的具体实现方法 (包含适当的参数适配, 返回类型适配,和在调用参数前附加上捕获的参数), 在这里为 HelloWorld.lambda$main$0:()V 方法的方法句柄. </span></span></span><br><span class="line"><span class="function">    MethodType instantiatedMethodType) <span class="comment">// 函数接口方法替换泛型为具体类型后的方法类型, 通常和samMethodType一样，除非发生了类型擦除</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> LambdaConversionException</span></span><br></pre></td></tr></table></figure>

<p>在执行<code>invokedynamic</code>时会执行其关联的引导方法，前三个参数由JVM自动填充，后三个参数来自属性表中的<code>bootstrap_arguments</code>。可以看到，lambda表达式的具体实现被编译成了<code>HelloWorld.lambda$main$0:()V</code>这样一个静态方法。执行完引导方法后，会返回一个<code>CallSite</code>对象，它的<code>target</code>属性关联了所调用的方法句柄，最后执行这个方法句柄。</p>
<p>值得一提的是，lambda表达式只是在“生成”的时候调用了<code>invokedynamic</code>，比如上面那个例子，即使没有<code>r.run();</code>这句，也会产生一条<code>invokedynamic</code>指令，换句话说实际上这里<code>invokedynamic</code>产生了一个<code>Runnable</code>对象，然后把它赋值到了一个局部变量。</p>
<h2 id="基于栈的字节码解释引擎"><a href="#基于栈的字节码解释引擎" class="headerlink" title="基于栈的字节码解释引擎"></a>基于栈的字节码解释引擎</h2><p>这段内容其实没啥好说的，举个例子，比如这样一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">4</span>;</span><br><span class="line">c = (a-c)*b;</span><br></pre></td></tr></table></figure>

<p>会翻译为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_1</span><br><span class="line">1: istore_1</span><br><span class="line">2: iconst_2</span><br><span class="line">3: istore_2</span><br><span class="line">4: iconst_4</span><br><span class="line">5: istore_3</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_3</span><br><span class="line">8: isub</span><br><span class="line">9: iload_2</span><br><span class="line">10: imul</span><br><span class="line">11: istore_3</span><br></pre></td></tr></table></figure>

<p>意思是把常量1入栈，出栈后保存到局部变量1；常量2入栈，出栈后保存到局部变量2；常量4入栈，出栈后保存到局部变量3；局部变量1和3分别入栈，出栈两个int、相减后入栈，将变量2入栈，出栈两个变量、相乘后出栈，此时栈里只有一个int（-6），最后出栈并保存到变量3。</p>
<p>可以看出真的这么跑的化执行效率很低，一般JVM都会对此进行优化。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/06/jvm5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/06/jvm5/" class="post-title-link" itemprop="url">JVM学习（5）类加载机制</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-06T00:00:00+08:00">2019-09-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-09 16:11:25" itemprop="dateModified" datetime="2019-09-09T16:11:25+08:00">2019-09-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有了.class文件后，还需要一系列步骤加载进JVM才能运行。简单来说，一个类从被加载至JVM，到卸载出内存为止，整个生命周期包括加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）、卸载（unloading）7个阶段。其中验证、准备、解析三个部分称为连接（linking），顺序如下图所示。</p>
<p><img src="/images/jvm_class_lifecycle.png" alt="类的生命周期"></p>
<p>JVM没有规定什么时候开始加载，但规定了5种情况必须对类进行初始化：</p>
<ol>
<li>遇到<code>new、getstatic、putstatic、invokestatic</code>这四条指令码。比如new一个对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法的时候。</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时</li>
<li>初始化一个类时，需要先初始化其父类</li>
<li>虚拟机启动时，用户指定的主类需要先被初始化</li>
<li>使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic、REF_putStatic、REF_invokeStatic</code>的方法句柄对应的类需要初始化</li>
</ol>
<p>这五种场景中的行为称为对一个类的主动引用，除此之外的引用类的方式都不会触发初始化，称为被动引用，比如</p>
<ol>
<li>通过子类引用父类的静态字段，不会触发子类的初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化（如<code>SomeClass[] arr= new SomeClass[];</code>）</li>
<li>引用某个类的静态常量</li>
</ol>
<p>其中2虽然不会导致这个类的初始化，但会触发一个<code>[Lorg.fenixsoft.classloading.SomeClass</code>的类初始化，它由JVM自动生成、直接继承自<code>java.lang.Object</code>，由newarray触发，代表了一个元素类型为<code>org.fenixsoft.classloading.SomeClass</code>的一维数组，数组中应有的属性和方法（如<code>length、clone</code>）都实现在这个类。Java中对数组的访问会使用这个类提供的方法（底层使用了<code>xaload、xastore</code>等指令保证不会越界），所以相对<code>C/C++</code>安全。</p>
<p>此外，接口在初始化时不要求父接口全部完成初始化，只有在真正使用父接口的时候（如引用接口中定义的常量）才会初始化。并且接口也会生成<code>&lt;cinit&gt;</code>的类构造器，用于初始化接口中定义的成员变量。</p>
<h2 id="加载（loading）"><a href="#加载（loading）" class="headerlink" title="加载（loading）"></a>加载（loading）</h2><p>加载阶段JVM需要做以下事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>常见的获取二进制字节流的方式有：</p>
<ol>
<li>从.class文件直接获得</li>
<li>从zip包中获得，比如JAR,EAR,WAR</li>
<li>从网络中获得，比如Applet</li>
<li>运行时计算生成，比如动态代理，java.lang.reflect.Proxy就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为”$Proxy”的代理类的二进制字节流</li>
<li>由其他文件生成，比如JSP</li>
<li>从数据库中读取<br>…</li>
</ol>
<p>除了获得字节流的方式外，开发人员还可以自定义个一个ClassLoader去控制如何读取字节流。</p>
<p>数组类比较特殊，它是由JVM直接创建的，一个数组类（简称为C）的创建过程需要遵循以下规则：</p>
<ol>
<li>如果数组的组件类型（Component Type，指数组去掉一个维度后的类型）是引用类型，则递归的加载这个组件类型，之后数组C将在这个组件类型所属的ClassLoader的类命名空间上被标志</li>
<li>如果组件类型不是引用类型，则会标识与Bootstrap Classloader关联。</li>
<li>数组类的可见性与它的组件的可见性保持一致，如果组件类型不是引用类型，则默认为public</li>
</ol>
<p>加载完成后，JVM外部的二进制字节流就按虚拟机所需的格式存储在方法区之中，方法区中的数据格式由JVM自行定义。然后在内存中实例化一个java.lang.Class对象（HotSpot将这个对象放在了方法区），这个对象将作为程序访问方法区中这些类型数据的外部接口。</p>
<h2 id="验证（verification）"><a href="#验证（verification）" class="headerlink" title="验证（verification）"></a>验证（verification）</h2><p>简单来说就是确保这些二进制字节流格式符合JVM规范，且不会对JVM有危害。</p>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>检验其是否符合Class文件规范，且能被当前JVM兼容，包括</p>
<ol>
<li>以<code>0xcafebabe</code>开头</li>
<li>主、次版本号能否被JVM兼容</li>
<li>常量池中的常量是否有不被支持的类型（检查常量tag标志）</li>
<li>指向常量的各种索引值中是否有指向不存在或不符合类型的常量</li>
<li><code>CONSTANT_Utf8_info</code>类型的常量中是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除或附加的其他信息<br>…</li>
</ol>
<p>只有经过文件格式验证后的字节流才会保存到方法区，后面三个验证阶段全部基于方法区的数据，不会直接操作字节流</p>
<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>确保Class数据描述的语义符合java语言规范要求，包括</p>
<ol>
<li>这个类是否有父类（除了<code>java.lang.Object</code>都应该有父类）</li>
<li>这个类是否继承了一个<code>final</code>类</li>
<li>如果这个类不是<code>abstract</code>，那么是否实现了所有父类/接口中要求实现的方法</li>
<li>类中的字段、方法是否与父类矛盾（如覆盖了父类的<code>final</code>字段、不符合规则的方法重载）<br>…</li>
</ol>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>验证操作码，包括</p>
<ol>
<li>确保任意时刻操作数栈的数据类型和指令代码序列都能配合工作，例如不会出现按<code>long</code>去读一个<code>int</code></li>
<li>确保跳转指令不会跳转到方法体以外的字节码上</li>
<li>确保方法体中的类型转换是有效的<br>…</li>
</ol>
<p>JDK1.6后为<code>Code</code>属性的属性表引入了一个<code>StackMapTable</code>属性，描述了方法体中所有基本块开始时本地变量表和操作栈应有的状态，那么验证期间只要检查<code>StackMapTable</code>属性即可，不需要重新推导这部分信息。JDK1.7后要求主版本号超过50的只能用这种形式。</p>
<p>（其实很奇怪，既然要验证就说明不信任代码提供方，那怎么能把一部分验证工作放在代码提供方呢？只能说JVM设计者认为代码提供方都是善意的，但工作做的比较糙，编译出来的东西不靠谱）</p>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>符号引用验证发生在解析之后，目的是检查对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，包括</p>
<ol>
<li>符号引用中的全限定名能否找到对应的类</li>
<li>指定类中有无描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性（<code>private、protected、public、default</code>）是否可以被当前类访问<br>…</li>
</ol>
<p>验证过程可以用<code>-XVerify:none</code>来取消</p>
<h2 id="准备（preparation）"><a href="#准备（preparation）" class="headerlink" title="准备（preparation）"></a>准备（preparation）</h2><p>准备阶段主要用来为类变量（被static修饰）分配内存（一般在方法区）并设置初始值，且初始值为0。比如<code>public static int value = 123;</code>这个变量在准备阶段过后的初始值为0，而在初始化后才被赋值为123。</p>
<p>如果类字段的属性表包含<code>ConstantValue</code>属性，那么准备阶段就会把变量定义为所指定的值。</p>
<h2 id="解析（resolution）"><a href="#解析（resolution）" class="headerlink" title="解析（resolution）"></a>解析（resolution）</h2><p>解析的目的是为了将常量池中的符号引用替换为直接引用的过程，</p>
<ul>
<li>符号引用（Symbolic References）：以一组符号来描述所引用的目标，符合可以是任何形式的字面量，只要在使用时能无歧义的定位到目标即可<ul>
<li>符号引用与JVM实现的内存布局无关</li>
<li>引用的目标不一定已被加载到内存</li>
<li>各种JVM的内存布局可以各不相同，但能接受的符号引用必须都是一致的</li>
</ul>
</li>
<li>直接引用（Direct References）：可以是直接指向目标的指针、相对偏移量或句柄<ul>
<li>与JVM内部实现相关</li>
<li>不同JVM的直接引用形式一般不同</li>
<li>如果有直接引用，那么引用目标一定在内存</li>
</ul>
</li>
</ul>
<p>JVM规范没有规定解析阶段发生的具体时间，只要求在执行<code>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic</code>这16个用于操作符号引用的字节码指令前，先对符号引用进行解析。所以JVM可以选择在加载的时候就解析还是在使用的时候才解析。JVM要求除<code>invokedynamic</code>外，在同一个实体中，如果一个符号引用被成功解析，那么之后也要能够成功解析；如果第一次解析失败，那么之后也应该收到同样的异常。而<code>invokedynamic</code>必须要等到实际执行时再解析，这条指令在JDK1.7中被引入，JDK1.8开始用来实现lambda表达式。</p>
<p>解析主要针对类或接口（CONSTANT_Class_info）、字段（CONSTANT_Fieldref_info）、类方法（CONSTANT_Methodref_info）、接口方法（CONSTANT_InterfaceMethodref_info）、方法类型（CONSTANT_MethodType_info）、方法句柄（CONSTANT_MethodHandle_info）、调用点（CONSTANT_Dynamic_info）这7类符号引用进行，后三种和动态调用相关，这里只解释前4种：</p>
<h3 id="类或接口"><a href="#类或接口" class="headerlink" title="类或接口"></a>类或接口</h3><p>假设当前代码所处的类为D，需要解析一个类或接口C的符号引用N，需要</p>
<ol>
<li>如果C不是一个数组类型，那么JVM会把N传给D的ClassLoader去加载C。</li>
<li>如果C是数组类型，且数组的组建类型是对象，那么会加载其组建类型，然后由JVM生成一个代表此数组维度和元素的数组对象。</li>
<li>在进行了1或2后，C已经在JVM中称为一个有效的类或接口了，然后验证D是否有对C的访问权限，没有则抛出异常</li>
</ol>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>解析字段的符号引用，首先要解析字段表里class_index项索引的<code>CONSTANT_Class_info</code>符号引用，解析成功后，假设这个类/接口是C，</p>
<ol>
<li>如果C本身就包含了包含简单名称和字段描述符都与目标项匹配的字段，则返回这个字段的直接引用</li>
<li>如果C中实现了接口，那么按照继承关系从下往上递归搜索各个接口和它的父接口，如果找到则返回</li>
<li>如果C不是<code>java.lang.Object</code>，那么会从下向上递归搜索其父类，如果找到则返回</li>
<li>都没找到则表示查找失败，返回<code>java.lang.NoSuchFieldError</code></li>
</ol>
<p>如果查找过程中返回了引用，但没有访问权限，也会抛出异常</p>
<p>如果一个同名字段同时出现在父类和子类，那么编译器可能会拒绝编译</p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>与字段解析类似，需要先解析所属的类/接口C，然后</p>
<ol>
<li>如果C是个接口，则报错<code>java.lang.IncompatibleClassChangeError</code></li>
<li>从下往上递归查找C和C的父类，如果找到相匹配的方法则返回</li>
<li>递归查找C的接口，如果找到相匹配的方法，说明C是个抽象类，抛出<code>java.lang.AbstractMethodError</code></li>
<li>查找失败，报错<code>java.lang.NoSuchMethodError</code></li>
</ol>
<p>最后会验证其访问权限</p>
<h3 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h3><p>与类方法解析类似，但需要保证C是个接口</p>
<ol>
<li>如果C不是接口，则报错<code>java.lang.IncompatibleClassChangeError</code></li>
<li>递归查找C和C的父接口，直到<code>java.lang.Object</code>，如果找到则返回</li>
<li>没找到报错<code>java.lang.NoSuchMethodError</code></li>
</ol>
<p>理论上接口方法都是<code>public</code>，所以应当不出现<code>java.lang.IllegalAccessError</code></p>
<h2 id="初始化（initialization）"><a href="#初始化（initialization）" class="headerlink" title="初始化（initialization）"></a>初始化（initialization）</h2><p>直到初始化阶段才开始执行自定义的java代码， 也就是<code>&lt;cinit&gt;()</code>方法</p>
<ol>
<li><code>&lt;cinit&gt;()</code>由所有类变量的赋值动作和静态语句块<code>static{}</code>中的语句合并而成，顺序由源文件顺序而定，且<code>static{}</code>只能访问到定义在之前的变量</li>
<li><code>&lt;cinit&gt;()</code>不需要显式的调用父类的<code>&lt;cinit&gt;()</code>，JVM会保证父类的肯定先执行完毕</li>
<li>如果没有相关代码，可以不生成<code>&lt;cinit&gt;()</code>语句</li>
<li>接口不能使用静态语句块，但也有变量初始化操作，故也会生成<code>&lt;cinit&gt;()</code>，但执行<code>&lt;cinit&gt;()</code>时不需要先执行父类的<code>&lt;cinit&gt;()</code>。同样的，接口的实现类初始化时也不会执行接口的<code>&lt;cinit&gt;()</code></li>
<li>JVM会保证<code>&lt;cinit&gt;()</code>能被正确加锁，这也意味着可能多个线程卡在某个类的<code>&lt;cinit&gt;()</code>上</li>
</ol>
<h2 id="类加载器（ClassLoader）"><a href="#类加载器（ClassLoader）" class="headerlink" title="类加载器（ClassLoader）"></a>类加载器（ClassLoader）</h2><p>从JVM的角度讲，只有两类加载器：一类是使用C++实现的启动类加载器<code>Bootstrap ClassLoader</code>，是JVM的一部分；另一种是其他的类加载器，由JAVA语言实现，独立于JVM，且全继承了<code>java.lang.ClassLoader</code>。</p>
<p>有三个系统提供的类加载器比较常见：</p>
<ol>
<li>启动类加载器（<code>Bootstrap ClassLoader</code>）：负责将<code>$JAVA_HOME/lib</code>中或<code>-Xbootclasspath</code>路径下，能被JVM识别的类库加载到JVM内存中，无法被java程序直接引用。用户自定义<code>ClassLoader</code>时需要需要<code>Bootstrap ClassLoader</code>加载，可以直接用<code>null</code>代替。</li>
<li>扩展类加载器（<code>Extension ClassLoader</code>）：由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>$JAVA_HOME/lib/ext</code>或<code>java.ext.dirs</code>系统变量所指定的路径下的所有类库，开发者也可以直接使用这个类加载器</li>
<li>应用程序加载器（<code>Application ClassLoader</code>）：由<code>sun.misc.Launcher$AppClassLoader</code>实现，负责加载用户类路径<code>ClassPath</code>上所指定的类库，也是<code>getSystemClassLoader()</code>方法的返回值，故一般也称为系统类加载器，开发者可以直接使用，默认的类加载器</li>
</ol>
<p>每一个类加载器都拥有一个独立的类名称空间，也就是说判断两个Class是否相等（包括<code>Class.equals(), isAssignableFrom(), isInstance()</code>的返回值）要判断两个<code>ClassLoader</code>是否相等。</p>
<p>开发人员也可以自定义类加载器，一般来说类加载器都应当有自己的父类加载器，且使用双亲委派模型（<code>Parents Delegation Model</code>）来复用父加载器代码：尽可能尝试让父类加载器去加载这个类。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/02/jvm4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/02/jvm4/" class="post-title-link" itemprop="url">JVM学习（4）类文件结构</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-02T00:00:00+08:00">2019-09-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-05 18:24:17" itemprop="dateModified" datetime="2019-09-05T18:24:17+08:00">2019-09-05</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为了实现“Write Once, Run Anywhere”，JVM支持运行.class格式的字节码文件，这样可以保证JVM的平台无关性和语言无关性：即不管什么语言，只要能编译为符合规范的.class文件，就可以在JVM上运行。</p>
<h2 id="class类文件结构"><a href="#class类文件结构" class="headerlink" title="class类文件结构"></a>class类文件结构</h2><p>任何一个class文件都对应着唯一一个类或接口的定义信息。当然一来JVM可以动态生成class，不一定每个类都对应着一个.class文件；二来一个java源代码里可以定义多个类，每个类（包括子类）实际上都会生成一个.class文件。</p>
<p>一个典型的class文件分为：MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes这十个部分：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td align="center">magic</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">minor_version</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">major</td>
<td align="center">_version</td>
</tr>
<tr>
<td>u2</td>
<td align="center">constant_pool_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>cp_info</td>
<td align="center">constant_pool</td>
<td align="center">constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">this_class</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">super_class</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">interfaces_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">interfaces</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td align="center">fields_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>field_info</td>
<td align="center">fields</td>
<td align="center">fields_count</td>
</tr>
<tr>
<td>u2</td>
<td align="center">methods_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>method_info</td>
<td align="center">methods</td>
<td align="center">methods_count</td>
</tr>
<tr>
<td>u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<p>其中u1, u2, u4,u8分别表示1、2、4、8字节长度的标量，且以big-endian的方式保存。</p>
<p>不定长的区域，比如constant_pool，method_info等，基本都是count+info[count]这种形式。</p>
<p>先写一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> hello1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHello1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hello1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Child</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3911120229867216339L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> hello2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHello2</span><span class="params">(<span class="keyword">int</span> hello2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hello2 = hello2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hello2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Child o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hello2 - o.hello2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这段代码编译后生成两个class文件，这里只分析<a href="/files/Child.class">Child.class</a>。可以先用<code>javap -v -p -s -sysinfo -constants Child</code>看一下基本框架。然后依次分析每个区域。</p>
<h2 id="Magic-Numbers和版本号"><a href="#Magic-Numbers和版本号" class="headerlink" title="Magic Numbers和版本号"></a>Magic Numbers和版本号</h2><p>魔数，.class文件必须以0xcafebabe开头，这个跟.jpeg之类的文件类似。</p>
<p>接下来4个字节是版本号，其中后两个字节是主版本号，这里是0x0031，对应JDK1.5.0_11版本。一般高版本的JVM兼容低版本的.class文件，但反过来不行。</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>接下来是常量池（constant pool）部分，2字节的数字表示一共有多少个常量，接下来一共有constant_pool_count-1个实际常量。这里一共有0x002a-1=42-1=41个常量。且常量池索引以1开始，0被用来表示“不引用任何一个常量池项目”。</p>
<p>常量池主要包含两部分：字面量（literal）和符号引用（symbolic references）。字面量比如文本字符串、声明为final的常量值等。符号引用包含三部分：</p>
<ul>
<li>类和接口的全限定名（full qualified name）</li>
<li>字段的名称和描述符（descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>每个常量以1字节的类型描述开始，然后按这个类型定义的表去填充数据，具体参考<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">The class File Format</a>。以刚才编译好的.class文件为例，跳过重复的类型，大概有以下几个部分：</p>
<ul>
<li>第1个常量是<code>0a 0006 0023</code>，对应CONSTANT_Methodref_info，两个index分别指向第6和第35个常量，表明这个方法在第6个常量表示的类（Base），具体的名称和描述符参考第35个常量（<code>&quot;&lt;init&gt;&quot;:()V</code>）</li>
<li>第2个常量是<code>09 0004 0024</code>，对应CONSTANT_Fieldref_info，与CONSTANT_Methodref_info类似，表明这个字段在第4个常量表示的类（Child），具体的名称和描述符参考第36个常量（<code>hello2:I</code>）</li>
<li>第4个常量是<code>07 0026</code>，对应CONSTANT_Class_info，这个类的名称指向第38个常量，这个常量是个字符串，值为<code>Child</code></li>
<li>第8个常量是<code>01 0010 73657269616c56657273696f6e554944</code>，对应CONSTANT_Utf8_info，是一个utf8字符串，此字符串长为16（32字节），用python3的<code>bytes.fromhex(&quot;73657269616c56657273696f6e554944&quot;)</code>解码得到字符串是<code>serialVersionUID</code></li>
<li>第11个常量是<code>05 c9b8e8df78eba22d</code>，对应CONSTANT_Long_info，是一个long型常量，对应十进制数字为<code>-3911120229867216339</code></li>
<li>第35个常量是<code>0c 000f 0010</code>，对应CONSTANT_NameAndType_info，表示它的名字为第15个常量（<code>&lt;init&gt;</code>），类型为第16个常量<code>()V</code></li>
</ul>
<p>总的来说常量池还是以字符串、数字为主。</p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池结束后是两个字节的访问标志，用以声明这个类/接口/注解…的访问类型。这个类是0x0021，为<code>ACC_PUBLIC|ACC_SUPER</code>，ACC_PUBLIC容易理解，即这个类声明为public的；而ACC_SUPER主要是为了向下兼容，因为invokespecial这个指令的语义在JDK1.0.2发生过变化（可以参考<a href="https://blog.csdn.net/xinaij/article/details/38872851" target="_blank" rel="noopener">ACC_SUPER和早期的invokespecial</a>），那么新版JDK编译出来的类都需要带上这个flag。</p>
<h2 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h2><p>还是指向常量池的信息，这里类是第4个常量（Child类），父类是第6个常量（Base类）。由于所有java class都至少有个一个基类Object，故父类索引一定不为0。</p>
<p>这个类的接口集合大小为1，之后是一系列2字节的常量索引（长度为1），可以看到Child类继承了7号常量描述的接口（java/lang/Comparable）。</p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>相比于接口，字段包含的信息比较多，除了名字和类型外，还包含诸如是否被static、final、public、volatile等修饰符修饰等信息。因此一个字段被定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">  u2 access_flags;</span><br><span class="line">  u2 name_index;</span><br><span class="line">  u2 descriptor_index;</span><br><span class="line">  u2 attributes_count;</span><br><span class="line">  attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里一共有2个字段，第一个字段为<code>001A 0008 0009 0001 000A 00000002 000B</code>，被声明为<code>0x1A=ACC_PRIVATE|ACC_STATIC|ACC_FINAL</code>，名称为第8个常量（字符串<code>serialVersionUID</code>），描述符为第9个常量（字符串<code>J</code>，表示基本类型long）。</p>
<p>所谓描述符(descriptor)是描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）和返回值。基本类型和void都用一个大写字母表示，而对象用L+对象的全限定名来表示，比如<code>Ljava/lang/Object;</code>（一般全限定名后加个分号以示区分）。数组则是加个<code>[</code>，比如<code>[[Ljava/lang/String;</code>表示<code>String[][]</code>这样的二位数组，<code>[I</code>表示<code>int[]</code>这样的int数组。描述方法时，先写参数列表，后写返回值。例如方法<code>int indexOf(char[] source, int sourceOffset, char[] target, int targetOffset, int targetCount, int from Index)</code>的描述符为<code>([CII[CIII]])I</code>。</p>
<p>最后，这个字段包含1个属性（attribute），属性用来保存一些额外信息，每个attribute_info被定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个字段有一个attribute_info，name为第10个常量<code>ConstantValue</code>，其内容长为2字节，但需要联合起来表示指向第11个常量(一个long型的数字-3911120229867216339l)。</p>
<p>第二个字段为<code>0082 000D 000E 0000</code>，被声明为<code>0x82=ACC_PRIVATE|ACC_TRANSIENT</code>，名称为第13个常量<code>hello2</code>，描述符为第14个常量<code>I</code>，没有额外属性。</p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>方法表和字段表结构很类似，不过由于字段和方法的访问标志不太一样，所以实际含义不太一样。此外方法表一般会有一个属性指向Code类型，需要参考属性集合表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">     u2 access_flags;</span><br><span class="line">     u2 name_index;</span><br><span class="line">     u2 descriptor_index;</span><br><span class="line">     u2 attributes_count;</span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Child里有6个方法，如下表所示，其中bridge表示这个方法是桥接方法，synthetic表示这个方法由编译器生成。</p>
<table>
<thead>
<tr>
<th>二进制码</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>0001 000f 0010 0001 0011 0000002f...</code></td>
<td><code>public &lt;init&gt; ()V</code></td>
</tr>
<tr>
<td><code>0001 0016 0017 0001 0011 0000003e...</code></td>
<td><code>public setHello2 (I)V</code></td>
</tr>
<tr>
<td><code>0001 0018 0019 0001 0011 0000002f...</code></td>
<td><code>public getHello2 ()I</code></td>
</tr>
<tr>
<td><code>0001 001a 001b 0001 0011 0000003e...</code></td>
<td><code>public compareTo (LChild;)I</code></td>
</tr>
<tr>
<td><code>1041 001d 0019 0001 0011 0000002f...</code></td>
<td><code>public bridge synthetic getHello1 ()I</code></td>
</tr>
<tr>
<td><code>1041 001a 001e 0001 0011 00000033...</code></td>
<td><code>public bridge synthetic compareTo (Ljava/lang/Object;)I</code></td>
</tr>
</tbody></table>
<p>JSL对<a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html" target="_blank" rel="noopener">bridge method</a>的定义为：</p>
<blockquote>
<p>When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, called a bridge method, as part of the type erasure process. You normally don’t need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.</p>
</blockquote>
<p>比较奇怪的是<code>getHello1</code>也生成了一个桥接方法，我在网上查到的说法是只有类型擦除的时候才会生成bridge method，但实际上我试下来只要Child继承了Base，无论是否继承了Comparable，都会生成一个bridge的<code>getHello1()</code>。看了下反编译后的字节码，似乎bridge方法都会invokespecial/invokevirtual另一个方法，也就是说会把具体实现代理到其他方法去。</p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>可以看出，每个方法都有一个Code类型的属性，实际上的字节码也保存在这个属性里。之前也提到过一个ConstantValue属性。JVM对属性的规定比较宽泛，也允许编译器向属性表写入自己定义的属性信息。这里只记录一些常见的属性。</p>
<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>完整的Code_attribute定义如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 max_stack;</span><br><span class="line">    u2 max_locals;</span><br><span class="line">    u4 code_length;</span><br><span class="line">    u1 code[code_length];</span><br><span class="line">    u2 exception_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上一节中的<code>compareTo (LChild;)I</code>方法为例，其完整二进制代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0011 0000003e 0002 0002 0000000a </span><br><span class="line">2a b4 00 02 2b b4 00 02 64 ac </span><br><span class="line">0000 </span><br><span class="line">0002</span><br><span class="line">0012 00000006 0001 0000 0019 </span><br><span class="line">0013 00000016 0002 0000 000a 0014 0015 0000 0000 000a 001c 0015 0001</span><br></pre></td></tr></table></figure>

<p>可以看出，这个方法允许的最大操作数栈的最大深度为2，允许最多2个局部变量（包括形参）：max_locals参数的单位是slot，对于小于双字节的类型（如byte,char…）需要1个slot，而对double和long则需要2个slot。方法参数包括this，所以这个方法实际上参数是2。代码长度为10（<code>2a b4 00 02 2b b4 00 02 64 ac</code>），分别表示：</p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>2a</td>
<td><code>aload_0</code></td>
<td>将第一个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>b4 0002</td>
<td><code>getfield</code></td>
<td>获取指定类的实例域, 并将其压入栈顶。这里操作数为0x0002，查询常量池可知要把Child.hello2压栈</td>
</tr>
<tr>
<td>2b</td>
<td><code>aload_1</code></td>
<td>将第二个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>b4 0002</td>
<td><code>getfield</code></td>
<td>获取指定类的实例域, 并将其压入栈顶</td>
</tr>
<tr>
<td>64</td>
<td><code>isub</code></td>
<td>将栈顶两int型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>ac</td>
<td><code>ireturn</code></td>
<td>从当前方法返回int</td>
</tr>
</tbody></table>
<p>之后exception_table为空，有两个额外属性，分别是<code>LineNumberTable</code>和<code>LocalVariableTable</code>。</p>
<h3 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h3><p>用于描述java源代码行号和字节码行号之间的对应关系，定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 line_number;	</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这段代码偏移量为0的代码对应源代码的第25行，且只有一行代码。</p>
<h3 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h3><p>非必须属性，用来记录每个变量的名字，方便别人调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码一共记录了两个变量名，分别是<code>this</code>和<code>o</code>，对应两个形参名。</p>
<p>此外Child类中还有SourceFile、Signature属性，这里就不多说了。</p>
<p>Child类基本就分析到这了，实际上少分析了几个比较重要的分析，比如执行过程中的异常处理流程、异常抛出列表等、引导方法（BootstrapMethods）、各种字节码指令（特别是异常指令和同步指令）等，之后再补充。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/30/jvm3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/30/jvm3/" class="post-title-link" itemprop="url">JVM学习（3）垃圾回收器和内存分配策略</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-30T00:00:00+08:00">2019-08-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-01 16:19:28" itemprop="dateModified" datetime="2019-09-01T16:19:28+08:00">2019-09-01</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>垃圾回收（Garbage Collection,GC）机制是JVM的核心之一，而GC时需要考虑几个问题：</p>
<ol>
<li>回收哪些内存</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>判断一个object是否死亡主要有两种方式：引用计数和可达性分析。引用计数相对简单，但在object互相引用时会造成内存泄漏，所以JVM使用了可达性分析：一个存活的object所引用的object也是存活的。最初的存活对象被称为GC Roots，包含以下几类：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ol>
<h3 id="引用（reference）"><a href="#引用（reference）" class="headerlink" title="引用（reference）"></a>引用（reference）</h3><p>值得一提的是“引用”，Java中的引用分为以下几类：</p>
<ol>
<li>强引用（strong reference）：正常代码中的引用，比如Object a = new Object()</li>
<li>软引用（soft reference）：SoftReference类，描述一些还有用但非必须的对象。这类引用一般不会回收，但如果GC时判断可能会OOM，则会回收这类引用，如果回收失败时还可能OOM，则报错。</li>
<li>弱引用（weak reference）：WeakReference类，和SoftReference类似，但只能存活到下一次GC前。</li>
<li>虚引用（phantom reference）：最弱的引用，不对对象生存周期有任何影响，这类引用返回的对象总是null，不过如果GC回收这个对象，那么会接收到一个消息。</li>
</ol>
<p>SoftReference主要用于缓存，比如google的LoadingCache。PhantomReference主要用来实现类似析构函数之类的功能。这里又牵扯到finalize()方法，JVM规定如果object没有覆写finalize()或者finalize()已被JVM调用过，那么GC时就不用管finalize()。而如果JVM判断需要执行finalize()方法，那么会把这个object扔到一个叫F-Queue的队列里，由一个低优先级的Finalizer线程去依次执行各个finalize()方法：最关键的地方在于这个Finalizer不保证finalize()能被执行完，毕竟如果一个finalize()死循环或者超时了会影响整个JVM的工作，所以可能执行到一半就停了。此外，如果finalize()里又和其他对象建立了引用关系，执行完finalize()，GC会判断这个object又重新可达了，会不去回收这个对象，相当于c++中一个object在执行完析构函数后还正常存活。</p>
<p>总的来说因为finalize()有各种各样的坑，所以在需要类似析构函数的地方采用PhantomReference来代替。一个最典型的例子是DIrectBuffer，这个类有一个成员是cleaner，它是PhantomReference的子类，当一个DIrectBuffer被GC时会把这个对象塞到指定的ReferenceQueue里，然后再释放引用的堆外内存。</p>
<h3 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h3><p>方法区主要有两种数据可能会被回收：废弃常量和无用的类。常量回收和普通object回收很类似，只是这些常量放在方法区而已；无用的类判断起来很严格，要求</p>
<ol>
<li>没有该类的任何实例</li>
<li>加载该类的ClassLoader已被回收</li>
<li>该类对应的java.lang.Class对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法</li>
</ol>
<p>一般来说类还是不需要被回收的，但对于大量使用反射、动态代理、cglib等ByteCode框架、动态生成JSP以及OSGi这些频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，保证永久代不会溢出。值得一提的是JDK1.8以后取消了永久代，取而代之的是元空间（metaspace），metaspace使用的是native memory，且可以动态增加（当然也有上限，通过MaxMetaspaceSize配置）。这样可以极大降低永久代溢出的风险。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除（mark-sweep）算法"><a href="#标记-清除（mark-sweep）算法" class="headerlink" title="标记-清除（mark-sweep）算法"></a>标记-清除（mark-sweep）算法</h3><p>简单来说就是标记哪些部分的内存需要回收（见前文），标记完后统一回收。问题显而易见：运行一段时间后会产生大量的内存碎片，导致内存利用率降低。此外单线程的mark-sweep必然效率低。</p>
<h3 id="复制（copy）算法"><a href="#复制（copy）算法" class="headerlink" title="复制（copy）算法"></a>复制（copy）算法</h3><p>这种算法需要将内存分成（等大的）A，B两部分，分配内存时从A开始顺序分配，GC的时候把A中判定为存活的object复制到B，然后再从B开始顺序分配。好处是简单高效，缺点也显而易见：有一半内存被闲置了。</p>
<p>一般新生代采用这种回收方法，即将内存分成一大块的eden区和两块较小的survivor区，每次使用eden区和一个survivor区。内存从eden区开始顺序分配，假设eden区能回收绝大部分内存，那么GC的时候就把eden区和survivorA区的内存copy到survivorB区即可，这样就可以在只闲置一个survivor内存的情况下保证内存分配和回收足够高效。</p>
<p>在某些情况下可能survivor区不够大，需要依赖其他部分内存（老年代）进行分配担保（handle promotion），即把一部分对象直接扔到老年代。</p>
<h3 id="标记-整理（mark-compact）算法"><a href="#标记-整理（mark-compact）算法" class="headerlink" title="标记-整理（mark-compact）算法"></a>标记-整理（mark-compact）算法</h3><p>mark-sweep的改进，在标记完后把所有存活object向一个方向移动，可以避免内存闲置。</p>
<h3 id="分代收集（generational-collection）算法"><a href="#分代收集（generational-collection）算法" class="headerlink" title="分代收集（generational collection）算法"></a>分代收集（generational collection）算法</h3><p>根据对象生存周期的不同把内存划成几块（一般是分为新生代和老年代），在各部分内存采用不同的回收算法。比如在年轻代可以用复制算法，而老年代可以用标记-清理或标记-整理算法。</p>
<h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h2><h3 id="GC-Roots和OopMap"><a href="#GC-Roots和OopMap" class="headerlink" title="GC Roots和OopMap"></a>GC Roots和OopMap</h3><p>进行可达性分析时有两个问题：</p>
<ol>
<li>GC Roots包括两部分：全局性引用（如常量和类静态属性）和执行上下文（如栈帧中的本地变量表）。但这两部分内存包含的不仅是reference，还有比如方法，int，long型变量等，逐个检查这些内存中的引用会比较费时。</li>
<li>可达性分析时需要保证分析过程中的对象引用关系不变，这点是GC需要停顿所有java执行线程（stop the world）的重要原因之一。</li>
</ol>
<p>针对第一个问题，HotSpot采用了一种称为OopMap的数据结构来记录对象内哪些地方存放着reference，在类加载完后就可以把对象内什么偏移量上是什么类型的数据计算出来。这种GC方式被称为准确式GC，准确式GC和保守式GC的区别可以参考<a href="https://blog.csdn.net/woaigaolaoshi/article/details/51439227" target="_blank" rel="noopener">我爱学Java之JVM中的OopMap</a>。HotSpot在JIT（just in time）编译过程中，会插入相关指令来标明哪些地方是对象引用，如下图中0x026eb730到0x026eb7be这段区间内，exb寄存器和栈中偏移为16的内存区域各有一个普通对象指针的引用。</p>
<p><img src="/images/jvm_oopmap_sample.png" alt="String.hashCode()方法编译后的本地代码"></p>
<h3 id="安全点（safe-point）"><a href="#安全点（safe-point）" class="headerlink" title="安全点（safe point）"></a>安全点（safe point）</h3><p>OopMap能加速GC Roots枚举，但本身也会占用一定空间，因此不是所有指令都生成对应的OopMap，只在特定位置生成OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用，这样的位置称为安全点（safe point）。一般safe point选在可能“长时间执行”的地方，包括</p>
<ol>
<li>循环的末尾 </li>
<li>方法临返回前 / 调用方法的call指令后 </li>
<li>可能抛异常的位置</li>
</ol>
<p>另一个问题在于如何在GC时让所有线程（除JNI）外都跑到最近的safe point再停下来，有两种方式：</p>
<ol>
<li>抢先式中断（Preemptive Suspension）：GC发生时，先把所有线程中断，如果发现线程部在safe point上，则恢复执行，让它跑到安全点上</li>
<li>主动式中断（Voluntary Suspension）：GC时先设一个标志，各个线程会轮询这个标志，如果这个标志为true时就自己中断</li>
</ol>
<p>现在一般都用主动式中断，比如下边这个代码，GC需要暂停线程时会把0x160100内存页设置为不可读，那么线程执行到test时会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程，从而实现等待。</p>
<p><img src="/images/jvm_safe_point_sample.png" alt="轮询指令"></p>
<p>话说回来，让线程主动自陷的前提是线程本身正在运行，但如果线程并没有执行，比如正在sleep、blocked等等，因此引入安全区域（safe region）的概念。所谓safe region，是指这段代码片段中引用关系不会发生变化。线程进入safe region后就不管GC设置的标志了，但出safe region时需要检查GC是否已经完成了根节点枚举或者整个GC过程，没有的话就等到GC结束。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>HotSpot提供了很多垃圾回收器，方便用户在特定情况下使用合适的垃圾回收方式。下图列出了适合新生代和老年代的各个垃圾回收器，注意并不是所有垃圾回收器可以配合使用。</p>
<p><img src="/images/jvm_gc_types.png" alt="HotSpot虚拟机的垃圾收集器"></p>
<h3 id="Serial-Serial-Old收集器"><a href="#Serial-Serial-Old收集器" class="headerlink" title="Serial/Serial Old收集器"></a>Serial/Serial Old收集器</h3><p>最简单的单线程垃圾回收器，新生代使用Serial，采用复制算法；老年代使用Serial Old，采用标记-整理算法。好处是simple is the best，坏处是并行度不够，且stop the world时间很长。一般用在client模式下。</p>
<p><img src="/images/jvm_serial.png" alt="Serial收集器"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>简单来说就是Serial的多线程版本。由于CMS只能和Serial和ParNew配合使用，故ParNew也是Server模式下首选的新生代收集器。</p>
<h3 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge/Parallel Old收集器"></a>Parallel Scavenge/Parallel Old收集器</h3><p>看介绍和ParNew差不多，但更关注吞吐量，即尽可能降低GC总时间。相对应的Parallel Old可以认为是Parallel Scavenge的老年代版本，两者可以配合使用，适用于吞吐量敏感的场合（比如离线任务）</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器的目标是降低GC停顿，适用于重视响应时间的服务。CMS基于mark-sweep算法，想法也很简单：很多时候stop-the-world是为了避免引用变更，但毕竟不是所有引用在GC期间都会改，所以如果能侦测到哪些引用没变且没被引用，就可以和其他用户线程同步进行回收。CMS步骤分为以下4步：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>其中1和3还是需要stop-the-world，而耗时最长的2和4可以和用户线程并发执行，显然GC停顿时间变短了。 </p>
<p><img src="/images/jvm_cms.png" alt="CMS执行流程"></p>
<p>当然CMS也有缺点，</p>
<ol>
<li>对CPU资源敏感，因为和用户线程并发执行会占用一部分CPU资源，导致用户程序执行变慢</li>
<li>无法处理浮动垃圾（floating garbage），由于和用户线程并发执行，在此期间产生的垃圾无法被检测和回收，导致CMS不能等到老年代几乎完全被填满了再进行收集，需要预留一部分。当CMS运行期间内存不足，会报“concurrent mode failure”，此时JVM会临时采用Serial Old来进行回收，触发full GC，导致响应时间变长</li>
<li>CMS基于mark-sweep，会导致大量内存碎片，对此可以选择在CMS执行几次不压缩的full GC后，执行一次带压缩的full GC。压缩的full GC过程无法和用户线程并发执行。</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage first）的基本思想是把内存预先划分成若干大小的region，在每个region独立执行GC，这样有几个好处：</p>
<ol>
<li>可以和用户线程并发执行</li>
<li>可以分代回收</li>
<li>内存碎片较少</li>
<li>停顿可预测</li>
</ol>
<p><img src="/images/jvm_g1_memory.png" alt="G1收集器的内存分布"></p>
<p>那么如何判断一个region的object是否被其他region引用？G1采用了Remembered Set来避免全堆扫描，每个region都配一个对应的remembered set，当JVM发现应用程序对reference类型进行写操作时，会产生一个write barrier暂时中断写操作，检查reference引用的对象是否在其他region，如果是的话就通过CardTable把相关引用信息记录到被引用对象所属的region的remembered set中，这样在扫region的时候可以避免全堆扫描。</p>
<p>更详细的可以参考<a href="https://blog.csdn.net/coderlius/article/details/79272773" target="_blank" rel="noopener">详解 JVM Garbage First(G1) 垃圾收集器</a></p>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="对象优先在eden分配"><a href="#对象优先在eden分配" class="headerlink" title="对象优先在eden分配"></a>对象优先在eden分配</h3><p>对象优先在eden分配，如果eden区不足，则会触发一次minor GC。</p>
<ul>
<li>Minor GC是新生代GC，指发生在新生代的垃圾收集动作，minor GC发生的比较频繁，且回收速度也比较快</li>
<li>Full GC（Major GC）指发生在老年代的GC。Full GC的速度一般比Minor GC慢10倍以上</li>
</ul>
<h3 id="大对象直接进老年代"><a href="#大对象直接进老年代" class="headerlink" title="大对象直接进老年代"></a>大对象直接进老年代</h3><p>比如byte[]数组。一般假定大对象的存活时间会比较长。分配连续的大内存可能会不成功，提前触发GC，应当尽量避免存活时间短的大对象。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>JVM中每个对象有一个age计数器，对象每经过一次minor GC，age加1，超过一定年龄后（比如15）就扔到老年代。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>不一定非要等到MaxTenuringThreshold才升级到老年代，如果survivor区相同年龄所有对象大小的总和超过survivor空间的一半，那么大于等于这个年龄的object也可以进入老年代</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>发生minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立的化minor GC就是安全的，否则会查看HandelPromotionFailure是否设置，如果设置的话会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果大于，会尝试一次有风险的minor GC；如果小于，或者HandelPromotionFailure未设置，则进行full GC。</p>
<p>所谓的风险是指survivor区可能无法容纳所有幸存object，会扔到老年代，而老年代如果也放不下，minor GC自然就失败了。</p>
<p>感觉这一章内容还没完全看懂，以后再详细了解一下。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/26/megastore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/megastore/" class="post-title-link" itemprop="url">megastore阅读笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-26T00:00:00+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-30 16:38:22" itemprop="dateModified" datetime="2019-08-30T16:38:22+08:00">2019-08-30</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前粗略浏览过一遍megastore论文，对其中数据模型有点印象，但后面没太细看，今天补上。</p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>Megastore的目标是为了服务交互式线上服务，比如gmail、picasa。当然google后来已经改用spanner&amp;F1了。基本架构如下图所示。</p>
<p><img src="/images/megastore1.png" alt="图1"></p>
<p>Megastore将数据分为一个个Entity Group（怎么分得看具体业务）。每个数据中心都保存了完整的数据副本（为了便于理解，其实按说也不一定）。在同一数据中心内部，如果在同一个EG里的事务，可以只用一阶段提交即可保证ACID语义；如果是跨EG的事务，可以用两阶段提交，也可以用消息队列，如下图所示。</p>
<p><img src="/images/megastore2.png" alt="图2"></p>
<p>而跨数据中心则基于paxos进行备份，这意味着可以直接从本地数据中心进行的读操作是有效的（且通常是最新的），但写操作非常的重。我之前读到这的时候很奇怪，毕竟大多数情况写进某个DC再慢慢传播就行了，但megastore确实是这么干的，只能认为这些DC之间的带宽和延迟都非常给力。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="物理布局"><a href="#物理布局" class="headerlink" title="物理布局"></a>物理布局</h3><p>Megasotre的数据模型介于RDBMS和NoSQL之间，spanner的论文没有详细描述数据模型，但估计和megastore差不多。一方面，megastore要求数据的每个字段是强类型的（具体格式很像protobuf，毕竟是google自家的产品），另一方面可能也和megastore依赖于BigTable有关，很难完全支持各种联表查询。考虑到megastore主要用于读远多于写的情况，故采用pre-join的方式，将读代价转移到写上（其实megastore采用paxos保持每个集群数据总是最新/较新也是为了保证高可读性），如下图所示。</p>
<p><img src="/images/megastore3.png" alt="图3"></p>
<p>Megastore的table分为root table和child table两种，child table必须要引用其root table的某个键（必须是主键？）：那么，一个entity group包含了一系列entity，每个entity有root table及其sub table中的数据。对于每个entity，具体数据被存放到Bigtable中的某一行，其所有主键按字符串顺序连接起来作为BigTable的row key，其他列则保存在column中。由于child table引用了root  table的某个键，因此child table的数据也选择这个键作为主键，而利用BigTable的row key按字典序存放可以保证这些数据紧邻，如下图所示。当然也可以声明为SCATTER，这样的entity会在rowkey前加两个字节的hash code，以避免热点。</p>
<p><img src="/images/megastore4.png" alt="图4"></p>
<p>其实我觉得还是有问题，比如root table的主键是K1,K2,K3，child table引用了K2,K3，主键是K4。假如有两个root entity A:(a1,a2,a3)和B:(b1,b2,b3)，其中a2=b2,a3=b3；一个child entity C(c4)，有属性(a2,a3)，需要在BigTable里加两行(a1-a2-a3-c4)和(b1-a2-a3-c4)？修改的时候也要对这两行同时修改？或者又建了一层索引？又或者完全不管(直接用c4当row key)？看了下tidb的实现，主键还是就这样连接起来，但tidb不支持foreign key，所以也没法参考。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`test_primary_keys`</span>(</span><br><span class="line">    <span class="string">`k1`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`k2`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`k3`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`k4`</span> <span class="built_in">INT</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`k1`</span>,  <span class="string">`k2`</span>, <span class="string">`k3`</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_primary_keys <span class="keyword">values</span>(<span class="string">"hello"</span>, <span class="string">"my"</span>, <span class="string">"tidb"</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>

<p>实际存储到tikv里的数据是</p>
<blockquote>
<p>key: zt\200\000\000\000\000\000\000\377-_r\200\000\000\000\000\377\000\000\001\000\000\000\000\000\372<br>    write cf value: MvccWrite { r_type: Put, start_ts: 410775417252216833, commit_ts: 410775417278431233, short_value: [8, 2, 2, 10, 104, 101, 108, 108, 111, 8, 4, 2, 4, 109, 121, 8, 6, 2, 8, 116, 105, 100, 98, 8, 8, 8, 144, 7], unknown_fields: UnknownFields { fields: None }, cached_size: CachedSize { size: 0 } }</p>
</blockquote>
<p>同时，在Root Table的BigTable单行中，还存储了transaction,replication元数据以及Transaction Log。下图是整个MegaTable Table在BigTable之上的布局图。</p>
<p><img src="/images/megastore6.png" alt="图6"></p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>二级索引主要分为两种：local index和global index。所谓的local和global取决于是否跨EG，如图3中的PhotosByTime和PhotosByTag。Local index实际上被放在同一个entity group里，可以保证强ACID语义。Global index可以在不知道具体哪个EG的情况下找到特定的entity，但更新可能会不及时。此外Megastore还支持一些特性：</p>
<h4 id="存储子句（storing-clause）"><a href="#存储子句（storing-clause）" class="headerlink" title="存储子句（storing clause）"></a>存储子句（storing clause）</h4><p>一般索引用法是先通过索引确定哪一行，再访问这一行得到结果。Storing clause允许把一些数据保存到索引里，比如图3中的PhotosByTag.thumbnail_url。</p>
<p>不是很确定megastore是怎么存index的。但在tidb里，索引其实也是一行数据，和普通的数据行没有本质区别，每次更新时都会影响所有索引行。那么往这些行里加点附加数据加速查询，也很是很自然的想法。</p>
<h4 id="重复索引（repeated-indexes）"><a href="#重复索引（repeated-indexes）" class="headerlink" title="重复索引（repeated indexes）"></a>重复索引（repeated indexes）</h4><p>如图3中的PhotosByTag.tag，每个tag都有个索引。很正常的想法，毕竟一张图可能有很多个tag，总不能把所有tag连接起来当索引吧。</p>
<h4 id="内联索引（inline-indexes）"><a href="#内联索引（inline-indexes）" class="headerlink" title="内联索引（inline indexes）"></a>内联索引（inline indexes）</h4><p>Local index的一种，个人理解是同一个EG里foreign key的反向映射，保存在root table里新加的几列里。如下图所示，PhotosByTime.user_id是User表的主键，因此在索引PhotosByTime(user_id, time)时，可以在user_id行，PhotosByTime.time列，找到对应的photo_id。</p>
<p><img src="/images/megastore5.png" alt="图5"></p>
<p>总的来说创建索引后要么新建一行，要么新建一列，具体怎么做还得看情况。</p>
<h2 id="事务处理和并发控制"><a href="#事务处理和并发控制" class="headerlink" title="事务处理和并发控制"></a>事务处理和并发控制</h2><p>如前所述，同一个EG内的事务处理保持严格的ACID语义，和大多数数据库一样，写数据前会写一条WAL（write-ahead  log），然后再按照这个WAL落盘。</p>
<p>又因为BigTable天然的支持MVCC（multiversion concurrency control），所以只要在写事务时加上对应的timestamp就自然可以让megastore支持MVCC，这也意味着可以不用加锁就能快照读，甚至写操作也不一定要加锁。</p>
<p>Megastore提供了三种级别读：当前读（current），快照读（snapshot），立即读（inconsistent）。Megastore的做法是对于current读，要求当前entity group内（原文是the scope of a single entity group，应理解为要读的行所涉及的事务？）所有已committed的写操作落盘，然后用最近一次提交的事务所带的timestamp去读；而对于快照读就没有要求落盘操作了，可以认为是用最后一次已成功落盘的事务的timestamp去读。立即读就是不管timestamp直接读，显然这么读最快，对一致性要求不高的时候可以这么来。</p>
<p>所有的写事务都需要先进行一次current read，以此确定下一个log的position，这点非常重要。接着生成一个足够大的timestamp，遵循paxos协议尝试追加log。如前文所属，megastore主要用于读远多余写的情况，因此采用乐观锁：如果多个写操作向同一个log position写，只有一个能成功，其他失败的写操作会推倒重来一遍。完整的事务流程如下：</p>
<ol>
<li>Current read：获得最近一次事务的timestamp和log position</li>
<li>应用逻辑：读取BigTable数据，然后把所有写操作合并到一个log entry里</li>
<li>提交：遵循paxos协议，把log追加到日志队列里</li>
<li>生效：将日志中的修改写到BigTable的对应行，并修改相关索引</li>
<li>清理：清理掉不需要的数据</li>
</ol>
<p>实际上走完第三步就可以通知客户端写成功了，毕竟理论上日志被committed后等价于写成功，当然megastore会尽可能让距离客户端最近的副本生效这个事务，确保用户能读到最新的修改。</p>
<p>之前提到megastore支持跨entity group事务，可以用消息队列或者二阶段提交实现，见图2。消息队列简单来说就是先在EG1上进行事务，然后EG1将事务打包成一个消息塞到EG2的队列里，EG2原子的消费这个消息，事务从而继续在EG2上执行。论文上没更详细的讲这部分，比如如果事务跨了三个EG该怎么发送消息？EG之间来回读、来回写呢？一个事务在这三个EG上timestamp是否要保持一致？二阶段提交应该就是先拿写锁再写。</p>
<h2 id="副本同步"><a href="#副本同步" class="headerlink" title="副本同步"></a>副本同步</h2><p>副本同步是megastore的核心，它使用了一个基于paxos的低延迟的复制策略，保证各个集群的副本是一致的：显然，写操作需要至少在一个quorum数量的数据中心上commit才算成功，这也意味着一个写操作几乎要把所有DC跑一遍。当然，严格的写操作可以保证一个current read能有以下保证：</p>
<ol>
<li>一旦一个write成功，那么这个时刻之后的current read一定能读到这个write（可见性）</li>
<li>一旦某个current read读到一个write，那么之后的读操作都可以读到这个write（持久性）</li>
</ol>
<h3 id="副本架构"><a href="#副本架构" class="headerlink" title="副本架构"></a>副本架构</h3><p>首先megastore允许每个position的log彼此独立，且log可以有空洞，这个和raft不太一样。下面这张图列出了大多数可能的日志冲突的情况。按我理解，日志冲突时具体恢复成哪个版本也说不定，和paxos运行有关，比如102，如果δ的proposal_id足够高，γ又没抢到更高的proposal_id，可能到最后会以δ为准。</p>
<p><img src="/images/megastore9.png" alt="图9"></p>
<p>一般来说副本应该包括log和具体数据，但实际上paxos要求多个acceptor只是为了达成一致，所以可以让一些副本只保留log信息（这类副本称为witness）。此外，有时候也不太需要特别新的副本，只要保留某一时刻强一致性的数据就可以支持read，这类副本称为read-only副本。总的来说，megastore的架构如下图所示，论文描述的是“Each application server has a designated local replica”，应理解为每个应用都指定了一个本地副本，然后通过megastore library来和其他副本进行同步。</p>
<p><img src="/images/megastore8.png" alt="图8"></p>
<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><p>之前提到，write操作需要先进行一次current read，从而决定write的timestamp，设这个timestamp为t0。那么，对于t&lt;t0的快照读，write<sub>t0</sub>是一定不会看到的；write<sub>t0</sub>被commit后，对于current read，它的timestamp一定&gt;t0，且要求write<sub>t0</sub>落盘后才能继续，因此current read不会读到写到一半的数据。故current read的隔离级别至少是可重复读的。类似的，由于snapshot读会选择最后一个落盘的事务的timestamp读，而一个事务落盘意味着它之前的事务也落盘了，故snapshot读也至少是可重复读的。</p>
<p>显然，如果写操作非常少的情况下，我们可以直接从任意副本读取最新数据，不需要RPC。那么问题就在于如何判断一个副本是最新的？为了解决这个问题，对于一个特定的entity集合，Megastore在每个DC都起了一个coordinator的服务，来管理这个entity集合内的副本状态。更准确的说，coordinator维持了一个最新的副本列表，如果某个写操作被某个副本拒绝，那么这个副本上的coordinator就会把对应的entity group key移除，这一过程称为invalidation。</p>
<p>完整的current read流程如下：</p>
<ol>
<li>本地查询（query local）：查询本地的coordinator确定本地副本是否最新</li>
<li>寻找log position（find position）确定最高的可能的已被commited的log position，然后选择一个已经成功应用这个log的副本，<ul>
<li>a. 如果1已确定本地副本是最新的，那么直接以最后一个已committed的事务的timestamp读本地副本即可。</li>
<li>b. 如果本地副本不是最新的，或者2a超时了，那么会发起一次majority read（paxos保证多数派副本是一致的），找到大多数副本中最大的Log Position信息以及Timestamp信息，然后选择一个通常能快速响应的Replica或者是数据最新的Replica去读。</li>
</ul>
</li>
<li>数据追赶（catch up）：当知道本地副本已经不是最新，且在2b中选择了一个副本的情况下，会尝试补全数据：<ul>
<li>a. 对于某个position，如果选定的副本能确定已经有共识值的情况下，就按共识值填，不确定的话再找个副本接着读；如果都确定不了，则用no-op或者之前某个候选值填充这个position。</li>
<li>b. 当所有log被补齐后，依次apply这些log</li>
</ul>
</li>
<li>校验（validate）：如果选择了本地副本且之前不是最新的，那么通知coordinator，(entity group, replica)已更新至最新，且通知所有相关的write操作该副本部分已更新。</li>
<li>数据查询（query data）：使用已知的最大timestamp去读已选中的副本，如果这个副本已过期，那么再找个副本执行一遍catch up</li>
</ol>
<p>其中1和2a可以并发执行，时序流程图如下。</p>
<p><img src="/images/megastore10.png" alt="图10"></p>
<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>可以看到，current read可以得到下一个可用的log position，最新的timestamp，以及下一个leader副本。因此Write操作会先进行一次current read，然后去竞争写这个position log。在write被committed并准备apply前，需要所有集群的副本，要么接受这个write，要么对应的coordinator失效相关的entity。完整的write流程如下：</p>
<ol>
<li>请求Leader（ Accept Leader）：请求leader将自己的提议的值作为0号提议，如果成功转3</li>
<li>准备（Prepare）：即basic paxos prepare阶段，找到有最大proposal_id的value，并生成一个更大的proposal_id去提交</li>
<li>接受（Accept）：即basic paxos accept阶段。如果失败则转2。</li>
<li>失效（Invalidate）：要求所有没接受这个值的副本上的coordinator对相关entity进行invalidate处理</li>
<li>落盘（Apply）：在尽可能多的副本上落实这个log，如果选中的值和初始值不同，则报一个conflict error</li>
</ol>
<p>其实整个流程就是paxos，其中第一阶段是fast write，时序流程图如下。值得注意的是，一般数据库的commit point和visibility point一样，即一旦一个write被committed，用户就可以看到相关变更。而在megastore里，commit point在3，而visibility  point则在4。至于leader的选择，一般会按照某个启发式规则来确定，比如某个地区的application写操作比较多，那么离这些地方最近的副本就可以被选为leader。显然，如果leader一直有效且各个副本响应的足够快，那么整个写操作就退化为master-slave架构；如果leader总是挂，那么整个过程就退化为basic paxos流程。</p>
<p><img src="/images/megastore11.png" alt="图11"></p>
<h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>最后一个问题是coordinator，因为几乎所有的读写请求都要过coordinator，且对整个系统的正确性有决定性的影响，所以megastore把coordinator做成一个轻量级、无状态的服务，且只有coordinator拿到过半数的chubby锁时才被认为有效。如果没拿到足够多的锁，那么coordinator就认为所有entity group都过期了。如果一个coordinator突然挂了（比如失去了锁），那么在这个副本上的current read和write都得等coordinator重新上线后才能跑，但实际上coordinator宕机恢复期间，客户端可以其他副本进行current read和write操作。</p>
<p>由于megastore允许乱序log，对于position n,m，n&gt;m，如果m处日志写入失败而n写入成功，那么coordinator会报一个crash。不过我没太看懂coordinator检测crash的机制，原文如下。</p>
<blockquote>
<p>We detect crashes using a unique epoch number for each incarnation of the coordinator: validates are only allowed to modify the coordinator state if the epoch remains unchanged since the most recent read of the coordinator.</p>
</blockquote>
<p>其实想也知道megastore的写操作异常的重，吞吐量肯定不会高，</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="/files/Megastore.pdf">原文</a></li>
<li>Google Megastore分布式存储技术全揭秘：<a href="https://www.cnblogs.com/yako/archive/2011/02/18/1957790.html" target="_blank" rel="noopener">https://www.cnblogs.com/yako/archive/2011/02/18/1957790.html</a></li>
<li>Google-MegaStore的解读：<a href="https://www.iteye.com/blog/57832638-2028003" target="_blank" rel="noopener">https://www.iteye.com/blog/57832638-2028003</a></li>
<li>Google Megastore读写的架构分析：<a href="https://www.oipapio.com/cn/article-1701115" target="_blank" rel="noopener">https://www.oipapio.com/cn/article-1701115</a></li>
<li>Megastore详解：<a href="http://www.nosqlnotes.com/tag/megastore/" target="_blank" rel="noopener">http://www.nosqlnotes.com/tag/megastore/</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/jvm2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/jvm2/" class="post-title-link" itemprop="url">JVM学习（2）JVM内存布局</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:03" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:03+08:00">2019-08-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-31 18:25:13" itemprop="dateModified" datetime="2019-08-31T18:25:13+08:00">2019-08-31</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>在学习垃圾回收前需要了解JVM内存的各个区域，如下图所示。</p>
<p><img src="/images/jvm_mem.png" alt="JVM运行时数据区"></p>
<p>还是蛮容易理解的，很多区域可以和实机的区域对应上，实现的目的也相似。</p>
<h3 id="程序技术器（Program-Counter-Register）"><a href="#程序技术器（Program-Counter-Register）" class="headerlink" title="程序技术器（Program Counter Register）"></a>程序技术器（Program Counter Register）</h3><p>JAVA的处理单元是线程，那么为了线程切换，需要为每个线程保存一个独立内存区域以便恢复，这类区域成为“线程私有”的内存区域。本区域可以看作当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。简单来说模拟了CPU（运行时保存的数据）</p>
<p>如果线程执行的是一个java方法，那么这个计数器指向正在执行的虚拟机字节码指令的地址。如果执行的是native方法，则为空(undefined)。</p>
<p>本区域在JVM规范里没有规定任何OOM情况。</p>
<h3 id="JAVA虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#JAVA虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="JAVA虚拟机栈（Java Virtual Machine Stacks）"></a>JAVA虚拟机栈（Java Virtual Machine Stacks）</h3><p>模拟的是栈区，每个方法在执行时会创建一个栈帧（stack frame），保存了局部变量表、操作数栈、动态链接、方法出口等。</p>
<p>局部变量表存放了编译期可知的各种基本类型、对象引用、返回地址，其长度在编译器可以确定，运行时不能改变变量表的大小。（这点似乎与C不同，C和JAVA都支持数量可变的参数方法，但JAVA是通过数组模拟的，而C是真的压栈传参的。）</p>
<p>有两种异常情况，</p>
<ul>
<li>StackOverflowError：请求深度超过JVM允许的最大深度。</li>
<li>OutOfMemoryError：虚拟机栈扩展时如果申请不到足够的内存就会报OOM。当然JVM规范也允许固定长度的虚拟机栈。</li>
</ul>
<h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>与JAVA虚拟机栈相似，只不过方法是本地方法。JVM规范没有强制规定本地方法栈使用的语言、方法、数据结构，所以可以自由实现，甚至可以和JAVA虚拟机栈合二为一（比如hotspot）。也会报StackOverflowError和OOM。</p>
<h3 id="JAVA堆（Java-Heap）"><a href="#JAVA堆（Java-Heap）" class="headerlink" title="JAVA堆（Java Heap）"></a>JAVA堆（Java Heap）</h3><p>专门为了存放对象实例的内存区域，被所有线程共享（但可能划分出线程私有分配缓存区，Thread Local Allocation Buffer TLAB）。理论上所有对象实例和数组都应该分配在堆上，但实现时可以优化到别的地方。</p>
<p>JAVA堆是垃圾收集器的主要区域。由于现在收集器基本都采用分代收集算法，从内存回收的角度看，还可以细分为新生代和老年代，更细致一点可以分为eden、from survivor、to survivor空间等。</p>
<p>JAVA堆在物理上可以不连续，但在逻辑上必须连续。其大小可以固定，但一般是可扩展的，通过-Xmx和-Xms控制，申请不到新内存时会报OOM。</p>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>存放已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，被所有线程共享。JVM规范把方法区描述为堆的一个逻辑部分，但有个别名non-heap以区分对待。</p>
<p>Hotspot实现时将GC分代回收机制扩展至方法区，故方法区又成为永久代（Permanent Generation），其他虚拟机不一定这么实现。JVM规范没有强制规定怎么实现，用永代区实现的话可能会更容易遇到OOM，使用native memory似乎更好。</p>
<p>此外，JVM规范可以允许不在方法区实现GC，毕竟GC也就只能回收常量池和被卸载的类型。</p>
<h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>方法区的一部分，用于存放编译期生成的各种字面量和符号引用，在类被加载后放到常量池；事实上也可以动态添加，比如String.intern()。</p>
<h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>为执行本地方法提供的内存区域，可以认为是给本地方法提供的堆区。显然，由于Direct Memory和Java Heap是两个独立的区域，而Java方法无法直接访问Direct Memory，所以某些情况下会在两个区域间来回复制数据，导致性能下降。</p>
<p>在JDK1.4以后新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）和缓存区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，从而避免数据复制。</p>
<p>另外，通过<code>-XX:MaxDirectMemorySize</code>只能阻止java代码分配DirectBuffer，对在JNI里调用malloc之类的内存分配函数无效。之前做过一个实验，给<code>MaxDirectMemorySize</code>设置了一个很小的值，然后不断在jni里malloc，结果过了一会把机器打爆了。。。</p>
<h2 id="对象机制"><a href="#对象机制" class="headerlink" title="对象机制"></a>对象机制</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>JVM遇到new指令时，</p>
<ol>
<li>检查这个类有没有被加载，没有的话执行一遍类加载过程</li>
<li>确定对象大小，JAVA的继承机制导致类型一旦确定，则大小可以完全确定</li>
<li>为对象分配内存。两种方式，具体用哪种取决于GC支不支持压缩整理<ul>
<li>指针碰撞（Bump the Pointer）：假设内存以指针P为界分为两部分，&lt;P的部分为已使用的内存，&gt;=P的部分为空闲内存，则分配时只要移动P即可。</li>
<li>空闲列表（Free List）：维护一个所有空闲内存的列表，分配时找一个足够大的内存分配过去并更新列表。</li>
</ul>
</li>
<li>另外内存分配可能是线程不安全的，要么加同步处理，要么为每个线程预留一块本地线程分配缓冲（Thread Local Allocation Buffer TLAB），用完并重新分配时进行同步处理。</li>
<li>对对象内存置零。如果用TLAB，可以把这个动作提前至TLAB分配时进行。</li>
<li>设置对象头</li>
<li>调用方法</li>
</ol>
<p>和C++相比，共同点是都要分配内存和调用init()，不同点是JAVA可以实现类动态加载、对象有对象头之类的填充内容，且内存分配方案与GC直接相关。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>简单来说是由对象头（Header）、实例数据（Instance Data）和对齐信息（Padding）组成。对齐信息就是单纯为了让object按内存对齐，没有特别用处；实例信息是这个对象保存的实际信息，值得注意的是实际的内存分布和代码顺序、继承顺序没有必然关系，子类的较小变量也可能被插在父类的变量之间，为了对齐的更整齐、更紧致一些。</p>
<p><img src="/images/Synchronization.gif" alt="JVM运行时数据区"></p>
<p>重点是对象头，分为两部分。第一部分为标记字段（Mark Word），其长度为32/64 bits，和JVM有关，所保存的数据含义根据object状态不同而不同，比如在下图unlocked non-biasale object的32位中，前25bit表示该object的hash code，4bit保存分代年龄，1bit固定为0,后两位存储锁标志位。</p>
<p>第二部分为类型指针（Klass Pointer），用以确定这个实例来自哪个类。但如果JVM实现时可以通过别的方式查找到所属类，那么也可以没有这个字段。</p>
<p>另外如果是数组，还需要一个字段记录数组长度。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>如何定位对象的address取决于我们使用的是句柄还是直接指针。句柄的话就得先访问句柄再访问内存，直接指针可以直接访问内存。不过句柄的好处是GC的时候不用改太多东西。HotSpot用第二种方式。</p>
<p><img src="/images/jvm_visit_by_handle.png" alt="通过句柄访问对象"></p>
<p><img src="/images/jvm_visit_by_pointer.png" alt="通过指针访问对象"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
