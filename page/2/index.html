<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="读书笔记">
<meta property="og:url" content="https://maxiaoxin.github.io/page/2/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记">
  <link rel="canonical" href="https://maxiaoxin.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/10/08/redis-read2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/08/redis-read2/" class="post-title-link" itemprop="url">redis学习（2） 压缩列表、快速列表、整数集合、跳表</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-08T00:00:00+08:00">2019-10-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-30 19:19:31" itemprop="dateModified" datetime="2019-10-30T19:19:31+08:00">2019-10-30</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="压缩列表（ziplist）"><a href="#压缩列表（ziplist）" class="headerlink" title="压缩列表（ziplist）"></a>压缩列表（ziplist）</h2><p>当前版本的redis已经不使用ziplist作为列表的底层实现了，取而代之的是quicklist，但quicklist底层还是依赖ziplist。此外，hash表的底层实现也可以是ziplist，在键值较短且数量比较少的情况下会使用ziplist而非hashtable来实现hash表。</p>
<p>显然，使用ziplist的初衷是节约内存，主要是两方面：尽量使用较小的数据类型保存较小的整数，以及取消指针。既然取消了指针，而每个节点大小都可能不同，因此ziplist采用了变长数组作为实现。数组带来的一个好处是缓存友好，而朴素的链表容易产生大量不可控的零散碎片。Ziplist的大致结构类似<code>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</code>，相关定义如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度(byte)</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4</td>
<td>记录整个ziplist占用的字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4</td>
<td>记录尾节点距离起始地址有多少字节，可以用以直接计算得到尾节点地址</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2</td>
<td>记录了节点数。如果这个值等于UINT16_MAX时，需要遍历整个ziplist才能获得总节点数</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>具体保存数据的节点</td>
</tr>
<tr>
<td>zlent</td>
<td>uint8_t</td>
<td>1</td>
<td>固定为0xff，表示ziplist结尾</td>
</tr>
</tbody></table>
<p>Redis没有对ziplist结构体作出定义，仅将用一个<code>char*</code>指针指代对应的ziplist，相关操作的定义和实现在<code>ziplist.h</code>和<code>ziplist.c</code>，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_END 255</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上初始化就是给头尾相关字段赋值，一个初始化后的空列表为<code>0b000000 0a000000 0000 ff</code>，和上面的说明可以匹配的上。</p>
<p>所以核心还是<code>entry</code>的定义，ziplist的每个entry可以是一个字节数组或一个整数值，基本上每个entry都是类似<code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code>这样的结构，而对于某些entry，比如小整数，就没有<code>&lt;entry-data&gt;</code>这部分。</p>
<p><code>&lt;prevlen&gt;</code>表示之前那个entry的长度，但只能是1字节或5字节，取决于之前那个entry的长度：如果小于等于0xfe则采用1字节，否则需要置为0xfe，后4字节作为一个整数表明其长度（要说为啥不进一步细分，可能是因为太长的entry出现频率低吧）。显然，有<code>prevlen</code>后可以很容易的从后向前遍历节点，而从前向后遍历则需要解析<code>&lt;encoding&gt;</code>字段。</p>
<p><code>&lt;encoding&gt;</code>字段用来标明节点的类型和长度，根据类型及长度，可以分为以下几类：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度(byte)</th>
<th>content属性保存的值</th>
</tr>
</thead>
<tbody><tr>
<td>00pppppp</td>
<td>1</td>
<td>长度&lt;=0x3f的字节数组</td>
</tr>
<tr>
<td>01pppppp qqqqqqqq</td>
<td>2</td>
<td>长度&lt;=0x3fff的字节数组</td>
</tr>
<tr>
<td>10000000 qqqqqqqq rrrrrrrr ssssssss tttttttt</td>
<td>5</td>
<td>长度&gt;0x3fff的字节数组，这里的第一个字节前2位必须为10，后6位未定义；之后的4个字节作为整数保存字节数组长度</td>
</tr>
<tr>
<td>11000000</td>
<td>1</td>
<td>int16_t，2字节</td>
</tr>
<tr>
<td>11010000</td>
<td>1</td>
<td>int32_t，4字节</td>
</tr>
<tr>
<td>11100000</td>
<td>1</td>
<td>int64_t，8字节</td>
</tr>
<tr>
<td>11110000</td>
<td>1</td>
<td>24位有符号整数，3字节</td>
</tr>
<tr>
<td>11111110</td>
<td>1</td>
<td>8位有符号整数，1字节</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1</td>
<td>0-12之间的小整数，这里的xxxx介于0001和1101之间，由于不可以使用0000和1110、1111，所以只能代表0-12，且用的时候需要减一</td>
</tr>
<tr>
<td>11111111</td>
<td>1</td>
<td>特殊entry，表示结尾</td>
</tr>
</tbody></table>
<p>由于不同类型的encoding的第一个字节一定不同，因此仅根据第一个字节就可以判断enty的类型。</p>
<p>ziplist由于涉及压缩（不是值LZF之类的压缩算法），代码多且复杂，故只贴出插入节点相关的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>;</span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入时需要获得两个信息：插入位置，和前一个entry的length</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123; <span class="comment">// 检查是否在队尾</span></span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen); <span class="comment">// 如果不在，则解码前一个entry的长度和长度段的大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl); <span class="comment">// 尝试跳到队尾的entry</span></span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123; <span class="comment">// 如果队尾不为ZIP_END，说明队伍非空</span></span><br><span class="line">            prevlen = zipRawEntryLength(ptail); <span class="comment">// 尝试解码最后一个entry的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试压缩，包括两种情况：小整数，或者字符串代表了一个long long 可以表示的整数，比如"-987654321"</span></span><br><span class="line">    <span class="comment">// 从而确定压缩后entry的长度</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        reqlen = zipIntSize(encoding); <span class="comment">// 可以根据encoding确定长度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reqlen = slen; <span class="comment">// 否则就是字符串长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen); <span class="comment">// 加上存储prevlen需要的长度，传入NULL表示只计算长度而不写入</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen); <span class="comment">// 确定encoding字段的长度，传入NULL表示只计算长度而不写入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不在队尾插入，那么需要保证下一个entry的prevlen字段足够长，以保存本entry的长度</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>; <span class="comment">// 计算所需长度和下一个entry的prevlen字段的长度之差</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123; <span class="comment">// 如果本来下一个entry的prevlen字段长为5字节，而reqlen又很短的话，需要修改相关偏移量</span></span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新的ziplist长度，并realloc</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果非队尾插入，则需要移动相关内容并处理一些细节</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);  <span class="comment">// 移动相关内容</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen); <span class="comment">// 调整下一个entry的prevlen字段</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen); <span class="comment">// 修改整个列表的tail偏移量</span></span><br><span class="line"></span><br><span class="line">        zipEntry(p+reqlen, &amp;tail); <span class="comment">// 解码最后一个entry</span></span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123; <span class="comment">// 如果对不上ZIP_END，需要做一些特殊处理</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =                                           <span class="comment">// 至于为啥有可能对不上，官方说和nextdiff有关。。。反正我没想明白</span></span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则直接修改即可</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果nextdiff不为0，说明有可能调整下一个entry的长度，进而影响下下个entry的prevlen字段</span></span><br><span class="line">     <span class="comment">// 最坏情况需要把所有entry都调整并移动一遍</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要写的内容写进去</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算调整entry总量</span></span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实本质上和数组扩容类似，但由于entry之间有一定关联，需要注意的细节很多，所以代码很长</p>
<h2 id="快速列表（quicklist）"><a href="#快速列表（quicklist）" class="headerlink" title="快速列表（quicklist）"></a>快速列表（quicklist）</h2><p>当前版本的redis基本只使用quicklist作为列表的底层实现，之前采用双向链表和ziplist实现，并且在一定条件下会将ziplist转换为双向链表，而自然也可以想到将ziplist用链表的方式连接起来获得一个折中的做法，提高内存利用率和效率，其定义在quicklist.h中，如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl; <span class="comment">// 指向具体数据的指针，可以是ziplist，也可以是压缩后的数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">// ziplist的字节数，无论是否压缩，都表示未压缩前的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">// ziplist中的entry数。这里的冒号是C的一个语法，表示占16位而非字节，下同</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">// 压缩方式，1表示不压缩，2表示使用LZF算法</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">// zl指向的数据结构，目前取值只能是2，表示是ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">// 当前ziplist是否已被解压</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">// 测试用</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">// 保留字节</span></span><br><span class="line">&#125; quicklistNode; <span class="comment">// 强制对齐，共32字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">// 压缩后的字节数</span></span><br><span class="line">    <span class="keyword">char</span> compressed[]; <span class="comment">// 压缩后的数据</span></span><br><span class="line">&#125; quicklistLZF; <span class="comment">// LZF压缩节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head; <span class="comment">// 头节点</span></span><br><span class="line">    quicklistNode *tail; <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count; <span class="comment">// 总entry数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len; <span class="comment">// 一共有多少个quicklistNode</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>; <span class="comment">// 一个参数，用来某个ziplist节点能够容纳多少数据项，默认是-2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">// 压缩深度，为正时表示启用压缩，当quicklistNode总数大于等于quicklist-&gt;compress*2时开始压缩</span></span><br><span class="line">&#125; quicklist; <span class="comment">// 共40字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist; <span class="comment">// quicklist指针</span></span><br><span class="line">    quicklistNode *current; <span class="comment">// 当前的quicklistNode节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi; <span class="comment">// 指向ziplist中某个entry的指针</span></span><br><span class="line">    <span class="keyword">long</span> offset; <span class="comment">// ziplist中的偏移，如果zi为空，则使用offset</span></span><br><span class="line">    <span class="keyword">int</span> direction; <span class="comment">// 方向</span></span><br><span class="line">&#125; quicklistIter; <span class="comment">// quicklist的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist; <span class="comment">// quicklist指针</span></span><br><span class="line">    quicklistNode *node; <span class="comment">// 指向的节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi; <span class="comment">// 指向的ziplist中的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value; <span class="comment">// 具体的值，如果是字符串</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval; <span class="comment">// 具体的值，如果是整数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">// 当前ziplist的大小</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">// ziplist中的偏移</span></span><br><span class="line">&#125; quicklistEntry; <span class="comment">// quicklist中的某个entry</span></span><br></pre></td></tr></table></figure>

<p>其中比较重要的参数是quicklist中的fill和compress，前者取值为正时代表ziplist内部的节点数量，最大为0xFFFF，为负时只能取值-1～-5，分别代表每个ziplist节点的字节数不能超过4kb、8kb、16kb、32kb、64kb。后者表示压缩因子，在LZF算法中取值为0～10。由于头尾节点使用比较频繁，因此头尾节点永远不会被压缩。</p>
<p>由于涉及ziplist和压缩，quicklist的读写操作都比较麻烦，以下是头部插入的代码，话说我还是不太明白为什么插入时会解压缩途经节点。。。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x) __builtin_expect(!!(x), 1) <span class="comment">// 这是GCC提供的一个特殊指令，主要用来优化cpu的分支预测，这条语句告诉编译器x为真的可能像很大(unlikely类似)，因此如果将这部分语句放到判断语句后，可以降低cpu流水线被破坏的几率</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x) __builtin_expect(!!(x), 0) <span class="comment">// 但从外部看，可以认为if (likely(x))&#123;&#125; 等价于if(x)&#125;&#123;&#125;，</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> optimization_level[] = &#123;<span class="number">4096</span>, <span class="number">8192</span>, <span class="number">16384</span>, <span class="number">32768</span>, <span class="number">65536</span>&#125;; <span class="comment">// fill为负时的限制，4kb~64kb</span></span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span></span><br><span class="line">_quicklistNodeSizeMeetsOptimizationRequirement(<span class="keyword">const</span> <span class="keyword">size_t</span> sz, <span class="comment">// 校验fill为负时是否允许继续在当前ziplist插入</span></span><br><span class="line">                                               <span class="keyword">const</span> <span class="keyword">int</span> fill) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fill &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = (-fill) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; (<span class="keyword">sizeof</span>(optimization_level) / <span class="keyword">sizeof</span>(*optimization_level))) &#123; <span class="comment">// 数组越界检测</span></span><br><span class="line">        <span class="keyword">if</span> (sz &lt;= optimization_level[offset]) &#123; <span class="comment">// 是否超过限制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node, <span class="comment">// 判断这个节点是否能够插入</span></span><br><span class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ziplist_overhead;</span><br><span class="line">    <span class="comment">// 之前提到，ziplist中插入的节点需要保存前一个节点的size，所以这里算的时候要算上这部分大小</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)</span><br><span class="line">        ziplist_overhead = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)</span><br><span class="line">        ziplist_overhead += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>))</span><br><span class="line">        ziplist_overhead += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead; <span class="comment">// 新节点的大小</span></span><br><span class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill))) <span class="comment">// 如果fill为负且没超过ziplist单节点限制</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz)) <span class="comment">// 每一项数据最大字节数限制，redis写死是8192</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill) <span class="comment">// 如果当前节点的项目数小于fill</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123; <span class="comment">// 原始数据，未压缩</span></span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely( <span class="comment">// 如果允许插入新节点</span></span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123; <span class="comment">// 假如每一项都比较小，那么一般来说还是能成功的</span></span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD); <span class="comment">// 在这个ziplist里插入数据</span></span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head); <span class="comment">// 更新这个节点的大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode(); <span class="comment">// 否则创建一个新节点</span></span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD); <span class="comment">// 插入数据</span></span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node); <span class="comment">// 并更新quicklistNode的数据</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node); <span class="comment">// quicklistNode的插入操作，这个操作可能会导致压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">void</span> __quicklistCompress(<span class="keyword">const</span> quicklist *quicklist, <span class="comment">// 节点压缩</span></span><br><span class="line">                                      quicklistNode *node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!quicklistAllowsCompression(quicklist) || <span class="comment">// 当quicklistNode总数大于等于quicklist-&gt;compress*2时开始压缩</span></span><br><span class="line">        quicklist-&gt;len &lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(quicklist-&gt;compress * <span class="number">2</span>)) <span class="comment">// redis假设头尾节点操作频繁，如果链表数太少，会导致频繁的压缩/解压缩，因此当节点较少的时候最好不压缩</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterate until we reach compress depth for both sides of the list.a</span></span><br><span class="line"><span class="comment">     * Note: because we do length checks at the *top* of this function,</span></span><br><span class="line"><span class="comment">     *       we can skip explicit null checks below. Everything exists. */</span></span><br><span class="line">    quicklistNode *forward = quicklist-&gt;head;</span><br><span class="line">    quicklistNode *reverse = quicklist-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里同时从头指针和尾指针开始向中间走，直至相遇</span></span><br><span class="line">    <span class="comment">// 从而计算得到当前链表的深度</span></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> in_depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (depth++ &lt; quicklist-&gt;compress) &#123;</span><br><span class="line">        quicklistDecompressNode(forward); <span class="comment">// 没懂这里为什么要解压缩途经节点</span></span><br><span class="line">        quicklistDecompressNode(reverse); <span class="comment">// 至少当前函数内没有用到途经节点的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forward == node || reverse == node)</span><br><span class="line">            in_depth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forward == reverse) <span class="comment">// 如果没找到当前节点，则返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        forward = forward-&gt;next;</span><br><span class="line">        reverse = reverse-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_depth) <span class="comment">// 如果足够深，则尝试压缩当前节点</span></span><br><span class="line">        quicklistCompressNode(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        quicklistCompressNode(forward); <span class="comment">// 重新压缩</span></span><br><span class="line">        quicklistCompressNode(reverse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数集合（intset）"><a href="#整数集合（intset）" class="headerlink" title="整数集合（intset）"></a>整数集合（intset）</h2><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，且数量不多时，会采用整数集合作为集合键的底层实现。intset被定义在<code>intset.h</code>中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 编码方式，取值为INTSET_ENC_INT64、INTSET_ENC_INT32和INTSET_ENC_INT16</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;    <span class="comment">// contents的长度</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];  <span class="comment">// 实际内容，从小到大排列的整数，且不重复</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code>类型被声明为<code>int8_t</code>，但如何解读取决于<code>encoding</code>属性，简单来说根据<code>encoding</code>来将<code>contents</code>作为<code>int16_t[]</code>、<code>int32[]</code>、<code>int64[]</code>来处理。</p>
<p>一个比较麻烦的地方在于如果新插入的元素比当前所有的元素占用的空间大（比如把int8_t替换为int16_t），那么redis的做法是将原数组所有元素类型升级为和新元素一样大，这个操作被称为升级（upgrade），估计是因为这么搞比较简单，大概也是图省事，intset不支持降级。其他基本上增、删、改、（二分）查等一系列操作和普通的有序数组没什么区别，这里就略过了。</p>
<h2 id="有序集合-跳表（skiplist）"><a href="#有序集合-跳表（skiplist）" class="headerlink" title="有序集合/跳表（skiplist）"></a>有序集合/跳表（skiplist）</h2><p>redis采用跳表作为底层数据结构来实现有序集合，基本原理如下图，简单来说最底层是一串有序链表，然后按层数加索引。每个索引节点类似B+树，将所辖区间分成若干份，查找的时候根据要查找的值选择下层节点。</p>
<p>值得注意的是有序集合<code>zset</code>元素的唯一性由<code>dict</code>保证，<code>zskiplist</code>只保证按score有序排列</p>
<p><img src="/images/Skip_list_add_element-en.gif" alt="跳表原理"></p>
<p>redis中相关结构体定义在<code>server.h</code>中，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;              <span class="comment">// 具体的对象，默认字节流</span></span><br><span class="line">    <span class="keyword">double</span> score; <span class="comment">// 节点根据score排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>  <span class="comment">// 上一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span>                        <span class="comment">// 层级</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 同层级下一个的指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;                     <span class="comment">// 跨度</span></span><br><span class="line">    &#125; level[];                                                  <span class="comment">// 可变层级</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>  <span class="comment">// 头节点和尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;                           <span class="comment">// 总大小</span></span><br><span class="line">    <span class="keyword">int</span> level;                                                      <span class="comment">// 最高层高</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span> <span class="comment">// 有序集合，包含一个字典和一个跳表</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> min, max; <span class="comment">// 范围</span></span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">// 是否包含最大最小值</span></span><br><span class="line">&#125; zrangespec;</span><br></pre></td></tr></table></figure>

<p>可以看到，有序集合中，集合（不重复）是由<code>dict</code>实现的，而有序是由<code>zskiplist</code>实现的。一个比较奇葩的地方在于redis使用double来作为排序依据，而至少我没看到redis对score做了哪些特殊处理，甚至直接用<code>==</code>来比较两个double类型的参数。所以个人感觉以单score而非range的操作可能都会出问题，相同score的排序可能也有问题，但这里暂且不谈。其初始化流程如下，核心在于header节点的层级需要设为<code>ZSKIPLIST_MAXLEVEL</code>，以便可以直接从header节点开始能查找到任意节点。其实按说应该将header的score设置为<code>-MAX_DOUBLE</code>之类的值，但redis后面比较的时候并没有用到header的score，所以其实无所谓。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找流程很容易理解，按level从高向低查，然后从左向右查。假设要查找的score为s<sub>target</sub>，当前节点为A，正在查找第k level，下一个节点是B，那么</p>
<ol>
<li>如果当前节点已经查到目标score，则直接返回</li>
<li>如果s<sub>B</sub>&lt;s<sub>target</sub>，则移动到B，转1</li>
<li>如果level已经是0（走到最下层）则表明查找失败</li>
<li>令level-=1，转2</li>
</ol>
<p>严格来说redis排序是先按score排序，如果score相同，则按元素的值<code>ele</code>排序。由于元素是唯一的，所以skiplist一定是单调递增的。</p>
<p>可能是因为double精度的问题，或者同一个score可以有多个元素，redis不能直接根据score获得某个值，只能按查找range，其实流程也差不多。不过跳表的一个好处是可以在查找时计算出目标score的rank（在skiplist中的顺位），因为每个节点保存了<code>span</code>（区间内元素数量），那么向右走的时候累计<code>span</code>就可以获得rank</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 向下走</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; <span class="comment">// 如果能向右走</span></span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score || <span class="comment">// 右边的节点比当前节点score小</span></span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp; <span class="comment">// 或者相等，但ele值比当前目标值小或相等</span></span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span; <span class="comment">// 累计当前节点当前层的span</span></span><br><span class="line">            x = x-&gt;level[i].forward; <span class="comment">// 向右走</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点可能已经找到了，那么就直接返回</span></span><br><span class="line">        <span class="comment">// 但由于header的ele可以为Null，且header实际是无效的，所以还是要检查一下是否是x-&gt;ele是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是插入节点，首先查找到目标位置，然后增加一个节点，此节点的level是随机出来的，创建出来后和前后节点连接起来，并更新相关的span值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// 随机层级</span></span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>)) <span class="comment">// 取一个0~0xFFFF之间的随机数，和一个常数（这里是0.25*0xFFFF）比，如果测试通过就+1</span></span><br><span class="line">        level += <span class="number">1</span>; <span class="comment">// 合理性且不论，但基本上层级越高概率越低</span></span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL; <span class="comment">// 然后取不大于最高level的返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;  <span class="comment">// 要更新的所有节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];  <span class="comment">// rank排行，表示这个节点在有序集合中的顺序</span></span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;  <span class="comment">// 第i层的rank</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x; <span class="comment">// 意味着我们的新节点在i层的后继节点是update[i]，并且一定会更新update[i].span</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    level = zslRandomLevel(); <span class="comment">// 随机拿到一个层级</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123; <span class="comment">// 如果刚好比已知的层级都高，那么需要更新header节点</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length; <span class="comment">// 注意，这个时候还没有插入新节点，所以这些层的span是所有节点数</span></span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    x = zslCreateNode(level,score,ele); <span class="comment">// 创建一个新节点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward; <span class="comment">// 连接相同层级上的链表</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x; <span class="comment">// 其实就是链表插入操作</span></span><br><span class="line"></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]); <span class="comment">// 调整span信息</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>; <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123; <span class="comment">// 加上新节点带来的span</span></span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 设置其他信息</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/29/redis-read1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/29/redis-read1/" class="post-title-link" itemprop="url">redis学习（1） 简单动态字符串、链表和字典</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-29 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-29T00:00:00+08:00">2019-09-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-28 20:57:30" itemprop="dateModified" datetime="2019-10-28T20:57:30+08:00">2019-10-28</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>还是对着《Redis设计与实现》看，不过由于redis源码比较短，可以对比着看源代码。</p>
<p>Redis源码可以在<a href="https://redis.io/download" target="_blank" rel="noopener">官网</a>找，目前最新的stable版是5.0.5。不过如果是在Clion里看的话最好还是搞成cmake工程比较方便，可以参考<a href="https://github.com/Nov11/redis-4.0.2-with-cmakelist-for-reading-code-in-clion" target="_blank" rel="noopener">redis-4.0.2-with-cmakelist-for-reading-code-in-clion</a>，把<a href="/files/CMakeLists.txt">CMakeLists.txt</a>扔到工程目录下，然后针对5.0.5修改一下。</p>
<p>首先，redis并没有直接暴露很多底层的数据结构给用户，而是为用户暴露了以下五种类型的对象，可以通过<code>TYPE KEY_NAME</code>获得</p>
<ul>
<li>OBJ_STRING：字符串</li>
<li>OBJ_LIST：列表</li>
<li>OBJ_SET：集合</li>
<li>OBJ_ZSET：有序集合</li>
<li>OBJ_HASH：哈希表</li>
</ul>
<p>每种类型的实现则不一定、可能动态变化，理论上对用户是透明的，可以通过<code>OBJECT ENCODING KEY_NAME</code>获得，包括，</p>
<ul>
<li>OBJ_ENCODING_RAW：简单动态字符串（Simple Dynamic String, sds）</li>
<li>OBJ_ENCODING_INT：long类型整数</li>
<li>OBJ_ENCODING_HT 2：hash表</li>
<li>OBJ_ENCODING_ZIPMAP：压缩字典</li>
<li>OBJ_ENCODING_LINKEDLIST：双向链表，已弃用，采用quicklist代替</li>
<li>OBJ_ENCODING_ZIPLIST：压缩列表</li>
<li>OBJ_ENCODING_INTSET：整数集合</li>
<li>OBJ_ENCODING_SKIPLIST：跳表</li>
<li>OBJ_ENCODING_EMBSTR：embstr编码的SDS</li>
<li>OBJ_ENCODING_QUICKLIST：快列表？不知道怎么翻译</li>
<li>OBJ_ENCODING_STREAM 10：listpack，主要用来实现redix tree</li>
</ul>
<h2 id="简单动态字符串（Simple-Dynamic-String-sds）"><a href="#简单动态字符串（Simple-Dynamic-String-sds）" class="headerlink" title="简单动态字符串（Simple Dynamic String, sds）"></a>简单动态字符串（Simple Dynamic String, sds）</h2><p>在<code>sds.h</code>中定义，类似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">// 字符串长度，可以用O(1)时间获得字符串长度</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">// 一共申请了多少字节的内存</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">// 用来区分sdshdr版本</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">// 指向字符串的数组，简单来说redis的字符串和正常c字符串类似，也是以`\0`结尾，故兼容c标准库字符串函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先要说一下c的变长数组（flexible array），定义为变长数组后，这个结构体的长度实际上就可以是不定长且连续的。显然这种struct成员只能放在最后定义，用来处理流之类的不定长数据非常方便。</p>
<p>严格来说<code>sdshdr</code>不是字符串而是字节流，因为字节流是可以在中间包含<code>\0</code>的，而c风格字符串不可以。</p>
<p>redis字符串正常用起来和普通c字符串类似。但是当长度发生变化时，如果<code>len &lt; alloc</code>，则可以先尝试从buf里分配，从而避免频繁申请/释放内存；<code>flags</code>则是用来区分字符串版本，因为<code>len</code>和<code>alloc</code>本身的长度可以为8、16、32、64bit四个版本，且可以在使用中动态调整。以下是重新申请空间的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis对<code>sdshdr</code>结构体的操作总是传入<code>buf</code>指针，通过<code>buf[-1]</code>来判断类型，再进行下一步操作。如果<code>avail</code>足够用，则直接增加<code>len</code>即可。否则，先确定新字符串的长度，然后尽可能多的尝试分配内存，再检查一下<code>type</code>是否发生了变化（比如需要用16位的length来代替8位的length），如果没发生变化，则返回<code>realloc</code>后的指针即可，否则需要重新申请一块内存，把字符串内的数据copy过去后，再修改header信息。</p>
<h2 id="链表（list）"><a href="#链表（list）" class="headerlink" title="链表（list）"></a>链表（list）</h2><p>相对来说链表比较简单，redis实现了双向链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><code>listNode</code>定义了前驱、后继节点和指向实际数据的指针； <code>list</code>包含了头、尾指针、链表长度，以及节点复制、释放、比较的函数指针；<code>listIter</code>是迭代器。其他的基本链表操作函数就忽略了。</p>
<p>另外redis已弃用双向链表，采用quicklist实现列表</p>
<h2 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h2><p>Redis的字典使用了hash表作为底层实现，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key; </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;  <span class="comment">// value，如果是基本类型则可以不需要额外空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个entry</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);   <span class="comment">// 计算key的hash值</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);  <span class="comment">// 复制key</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);   <span class="comment">// 复制value</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2); <span class="comment">// 比较key</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);  <span class="comment">// 释放key</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);    <span class="comment">// 释放value</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;  <span class="comment">// dictEntry[N]代表了hash值为N的桶（数组）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// table数组的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 方便获取hash值对应到哪个桶</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  <span class="comment">// 一共保存了多少个节点</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;  <span class="comment">// 节点操作函数指针集合</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据，方便操作hash表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];        <span class="comment">// 维护了两个hash表，ht[1]主要用来进行rehash，一般使用ht[0]</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">// rehash索引，-1表示没有在rehash</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">// 一共有多少个相关的iterator</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;  <span class="comment">// 指向dict的指针</span></span><br><span class="line">    <span class="keyword">long</span> index;  <span class="comment">// 索引值</span></span><br><span class="line">    <span class="keyword">int</span> table;  <span class="comment">// 应该访问dict.ht[0]还是dict.ht[1]</span></span><br><span class="line">    <span class="keyword">int</span>  safe;  <span class="comment">// 是否为安全模式，如果为1表示可以在迭代期间进行add、find等操作，否则只能执行dictNext()</span></span><br><span class="line">    dictEntry *entry, *nextEntry; <span class="comment">// 当前的entry和下一个entry</span></span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;  <span class="comment">// 迭代器指纹，表示字典是否在迭代期间是否变化</span></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<p>Hash表的桶长度必须为2的倍数（计为N），这样对N求模的时候，可以改为对N-1求与。如果hash冲突，则用<code>dictEntry-&gt;next</code>来串起来形成单链表。</p>
<p>这样做另一个好处是，在扩表rehash的时候，某个桶里的key只能被重新rehash到特定的两个桶里。比如桶大小为0b1000，那么对于任意的key，会落在hash(key)&amp;0b111的桶内，计为b0。如果桶增长为0b10000，那么会落在hash(key)&amp;0b1111=(hash(key)&amp;0b1000) | (hash(key)&amp;0b111)，即取决于hash(key)写为二进制后的第4位是否为1。当然更重要的是缩表时，由于某些桶也只能映射到同一个桶里，那么把两个链表连在一起就可以了。不管扩表还是缩表，新的hash表桶数量还是取决于节点数。</p>
<p>Redis的rehash过程是渐进式的，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis每次只处理10*n个桶，那么如果刚巧这些桶都没有数据，那么可能这一趟下来一个节点也不处理。rehashidx代表了正在rehash哪个桶，每次rehash的时候都是从ht[0]迁移到ht[1]，对于每个节点，会从ht[0]删除，再加到ht[1]里。最后检查ht[0]-&gt;used是否为0，以判断rehash是否结束。如果结束，则释放ht[0]，将ht[0]指向ht[1]，清空ht[1]，并重置rehashidx。</p>
<p>渐进式rehash的好处是不会长时间阻塞（除非某个桶里的节点数非常多，当然也可以改成按节点个数来决定一趟rehash持续多长时间，但暂且不论），但对其他操作会有一定影响。不过redis单线程的特性会减少非常多的锁和同步带来的问题（比如多线程环境下对rehashidx的操作必须加锁，移动节点也必须加锁来保证原子性），因此这些处理会变得比较简单，比如添加操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently. */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出每次添加的时候都会尝试推进rehash过程（如果存在的话），然后根据rehashidx向对应的ht里插入数据；类似的，查询时两个表都会查。不过扩表和缩表的时机暂时没查到，据说和负载因子（<code>used/size</code>）有关，过大会扩表，过小会缩表。</p>
<p>还有一个问题在于rehash时迭代器的行为，迭代器分为safe和unsafe两种，safe的话则会增加dict的迭代器计数（这个计数器大于0时会禁止rehash），unsafe则会记下当前字典的指纹（hash值，取决于两个hash表的指针值、size、used），在释放的时候如果指纹不匹配则报错。遍历就是挨个桶遍历，每个桶顺着链表去查，遍历完一个ht后再遍历下一个，相关代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">long</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the 'next' here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个问题在于<code>dictScan</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction* bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></span><br><span class="line"><span class="comment">         * operates on the masked bits */</span></span><br><span class="line">        v |= ~m0;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">        v = rev(v);</span><br><span class="line">        v++;</span><br><span class="line">        v = rev(v);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment">         * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);</span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                next = de-&gt;next;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment the reverse cursor not covered by the smaller mask.*/</span></span><br><span class="line">            v |= ~m1;</span><br><span class="line">            v = rev(v);</span><br><span class="line">            v++;</span><br><span class="line">            v = rev(v);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fn</code>和<code>bucketfn</code>分别代表扫到一个节点和扫到一个桶时要调用的自定义函数。这里<code>v</code>是一个游标（cursor），初始可以设置为0，某种意义上代表了要扫哪个bucket，也是这个扫表算法的核心：从二进制的高位开始递增，比如当mask为0b111时，0b000会自增为0b100。核心算法为<code>v |= ~m0; v = rev(v); v++; v = rev(v);</code>，由于高位被置为1（<code>v |= ~m0</code>），那么反转后自增再反转，就一定会让有效的最高位自增1。</p>
<p>而对于正在rehash的表，则会先去扫<code>ht[0]-&gt;mask&amp;v</code>和<code>ht[1]-&gt;mask&amp;v</code>这两个桶，依次扫size较大的那个hash table有而size较小的hash table没有的桶（自增算法同上），最后v会自增到以较小的mask为掩码、按高位自增的下一个数字，并返回。下次调用时，会以这个数字先开始扫两个表对应的桶，再作为低位、从高位开始自增并扫桶，直到它自增到以较小的mask为掩码、按高位自增的下一个数字。举个例子，当较大的mask为0b11111，较小的mask为0b111，v为0时，会：</p>
<ul>
<li>扫ht[0][0]和ht[1][0]，然后依次扫ht[1]的0b10000、0b01000、0b11000，然后返回0b100</li>
<li>扫ht[0][0b100]和ht[1][0b100]，然后依次扫ht[1]的0b10100、0b01100、0b11100，然后返回0b010</li>
<li>扫ht[0][0b10]和ht[1][0b10]，然后依次扫ht[1]的0b10010、0b01010、0b11010，然后返回0b110</li>
<li>扫ht[0][0b110]和ht[1][0b110]，然后依次扫ht[1]的0b10110、0b01110、0b11110，然后返回0b001</li>
<li>…</li>
<li>扫ht[0][0b111]和ht[1][0b111]，然后依次扫ht[1]的0b10111、0b01111、0b11111，然后返回0</li>
</ul>
<p>顺序为0、16 、8、24、4、20、12、28、2、18、10、26、6、22、14、30、1、17、9、25、5、21、13、29、3、19、11、27、7、23、15、31</p>
<p>其中按位反转算法如下，原理我也不懂，但这个算法可以把比如0b00000010反转为0b01000000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Function to reverse bits. Algorithm from:</span></span><br><span class="line"><span class="comment"> * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">rev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s = <span class="number">8</span> * <span class="keyword">sizeof</span>(v); <span class="comment">// bit size; must be power of 2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask = ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((s &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mask ^= (mask &lt;&lt; s);</span><br><span class="line">        v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粗看起来，这种扫表方式和正常的逐次扫表相比，并没有什么特别的优势。但如前文所述，扩表的时候，一个key只可能被rehash到低位和原桶一样的桶里；缩表的时候，也一定会被rehash到hash(key)低位对应的桶里。因此，比如一个桶从0b111扩展到0b11111，如果0b100被扫过、v变成了0b010，那么0b??100再也不会被扫到，因为按翻转后的顺序，0b??100&lt;0b00010，而之后是从0b00010开始自增的，且不会漏扫（不考虑新增的节点）。类似的，如果从0b11111缩表到0b111，如果0b00000被扫过、v变成了0b10000，那么接下来会按0b000开始扫缩表后的桶，这样的话可能会重复扫这一个桶，但不会漏扫。而正常的按顺序扫表，缩表的时候很可能漏扫一片，扩表的时候则很可能会重复扫一片。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/24/jvm-exception/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/24/jvm-exception/" class="post-title-link" itemprop="url">JVM和异常处理</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-24 00:00:00 / Modified: 21:00:45" itemprop="dateCreated datePublished" datetime="2019-09-24T00:00:00+08:00">2019-09-24</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前读《深入理解JVM》的时候，把异常处理那段跳过去了，现在补上</p>
<p>Java代码里的<code>try{}catch(){}finally{}</code>很容易理解，而编译为.class文件后结构也是类似的，只是多了一个Exception table，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">foo</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      JSONArray array = <span class="keyword">new</span> JSONArray(args);</span><br><span class="line">      <span class="keyword">return</span> array.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JSONException e)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace(System.out);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">      t.printStackTrace(System.err);</span><br><span class="line">    &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>会被编译为</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private static java.lang.String foo(java.lang.String[]) throws java.io.IOException;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=4, args_size=1</span><br><span class="line">         0: new           <span class="comment">#2                  // class org/json/JSONArray</span></span><br><span class="line">         3: dup</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: invokespecial <span class="comment">#3                  // Method org/json/JSONArray."&lt;init&gt;":(Ljava/lang/Object;)V</span></span><br><span class="line">         8: astore_1</span><br><span class="line">         9: aload_1</span><br><span class="line">        10: invokevirtual <span class="comment">#4                  // Method org/json/JSONArray.toString:()Ljava/lang/String;</span></span><br><span class="line">        13: astore_2</span><br><span class="line">        14: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        17: ldc           <span class="comment">#6                  // String finally</span></span><br><span class="line">        19: invokevirtual <span class="comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        22: aload_2</span><br><span class="line">        23: areturn</span><br><span class="line">        24: astore_1</span><br><span class="line">        25: new           <span class="comment">#9                  // class java/io/IOException</span></span><br><span class="line">        28: dup</span><br><span class="line">        29: aload_1</span><br><span class="line">        30: invokespecial <span class="comment">#10                 // Method java/io/IOException."&lt;init&gt;":(Ljava/lang/Throwable;)V</span></span><br><span class="line">        33: athrow</span><br><span class="line">        34: astore_1</span><br><span class="line">        35: aload_1</span><br><span class="line">        36: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        39: invokevirtual <span class="comment">#12                 // Method java/lang/Exception.printStackTrace:(Ljava/io/PrintStream;)V</span></span><br><span class="line">        42: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        45: ldc           <span class="comment">#6                  // String finally</span></span><br><span class="line">        47: invokevirtual <span class="comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        50: goto          83</span><br><span class="line">        53: astore_1</span><br><span class="line">        54: aload_1</span><br><span class="line">        55: getstatic     <span class="comment">#14                 // Field java/lang/System.err:Ljava/io/PrintStream;</span></span><br><span class="line">        58: invokevirtual <span class="comment">#15                 // Method java/lang/Throwable.printStackTrace:(Ljava/io/PrintStream;)V</span></span><br><span class="line">        61: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        64: ldc           <span class="comment">#6                  // String finally</span></span><br><span class="line">        66: invokevirtual <span class="comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        69: goto          83</span><br><span class="line">        72: astore_3</span><br><span class="line">        73: getstatic     <span class="comment">#5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        76: ldc           <span class="comment">#6                  // String finally</span></span><br><span class="line">        78: invokevirtual <span class="comment">#7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        81: aload_3</span><br><span class="line">        82: athrow</span><br><span class="line">        83: aconst_null</span><br><span class="line">        84: areturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target <span class="built_in">type</span></span><br><span class="line">             0    14    24   Class org/json/JSONException</span><br><span class="line">             0    14    34   Class java/lang/Exception</span><br><span class="line">             0    14    53   Class java/lang/Throwable</span><br><span class="line">             0    14    72   any</span><br><span class="line">            24    42    72   any</span><br><span class="line">            53    61    72   any</span><br></pre></td></tr></table></figure>

<p>异常表对应了<code>try-catch</code>语句中的异常处理部分，比如<code>0    14    24   Class org/json/JSONException</code>表示如果在第0到第14行字节码运行过程中，如果出现<code>JSONException</code>异常，则跳转至34行；而对于<code>finally</code>语句，则是简单的将相关代码复制了3份，放到各个catch语句块后面，最后加一个<code>goto</code>指令跳转到<code>try-catch-finally</code>语句块后。（这种<code>goto</code>的用法和C对异常结果的处理方法非常类似）</p>
<p>异常一般有以下几种产生方式：</p>
<ol>
<li><code>athrow</code>指令抛出异常</li>
<li>执行/调用过程中同步产生的异常，比如OOM、除0错</li>
<li>由执行环境（比如JVM）产生的异常，和代码执行本身没有关系，比如一个线程对另一个线程执行<code>Thread.stop()</code>操作</li>
</ol>
<p>关于JVM如何捕获和处理异常，可以参考<a href="https://www.zhihu.com/question/53054894/answer/133229470" target="_blank" rel="noopener">读完CSAPP异常控制流之后，对Java异常机制的疑惑? - RednaxelaFX的回答 - 知乎</a>，简单来说，<code>athrow</code>出来的异常JVM总是能想办法捕获的，而对于系统报错，可以先向OS注册一个signal handler，并转换为Java层面异常抛出。</p>
<p>在捕获到异常后，JVM会去顺序查找异常表，如果from、to、type都满足，就使用那个handler处理；如果始终无法正确处理，则弹出栈帧，重复这一过程；如果到最后都没有正确处理，则本线程终止。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/23/jvm10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/23/jvm10/" class="post-title-link" itemprop="url">JVM学习（10）线程安全与锁优化</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-23 00:00:00 / Modified: 18:53:27" itemprop="dateCreated datePublished" datetime="2019-09-23T00:00:00+08:00">2019-09-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多线程带来的一个问题在于如何保证线程安全。所谓线程安全是指：当多个线程访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</p>
<p>书中举的例子是对<code>Vector</code>用下标遍历时，如果期间有其他线程对其修改，那么下标有可能会越界：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread A:</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); ++i)&#123;</span><br><span class="line">    vector.remove(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread B:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); ++i)&#123;</span><br><span class="line">    System.out.println(vector.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话这个例子感觉有点微妙，因为下标越界的原因是<code>i &lt; vector.size()</code>和<code>vector.get(i)</code>执行之间有延迟，而无论哪种集合类、无论内部是否有同步操作，都有可能下标越界。</p>
<h2 id="java中的线程安全"><a href="#java中的线程安全" class="headerlink" title="java中的线程安全"></a>java中的线程安全</h2><p>按照线程安全程度，可以将Java中对共享变量操作的线程安全度从强到弱分为以下5类：</p>
<ol>
<li>不可变：比如<code>Integer</code>、<code>String</code>这种，一旦创建后内部数据就不可以变化的对象，不需要任何同步操作就可以保证线程安全</li>
<li>绝对线程安全：任何情况下的操作都是正确结果，比如<code>java.util.concurrent.atomic.AtomicInteger</code></li>
<li>相对线程安全：任何单次调用操作都是正常结果，比如<code>java.util.concurrent</code>下的集合类。一般语境下的线程安全指的是这种级别的线程安全</li>
<li>线程兼容：本身不是线程安全，但可以通过同步手段可以保证线程安全，绝大多数java类都是线程兼容的</li>
<li>线程对立：无论采取任何同步手段，都无法在多线程环境中运行，比如<code>Thread.suspend()</code>和<code>Thread.resume()</code>、<code>System.setIn()</code>、<code>System.setOut()</code>和<code>System.runFinalizersOnExit()</code></li>
</ol>
<h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><p>基本上除了对于不可变对象、可重入代码以及线程本地存储（Thread local Storage）外，保证其线程安全的措施一般都需要上“锁”，而根据不同目标/特性，可以将锁按下图方式分类：</p>
<p><img src="/images/jvm_lock_types.png" alt="锁的分类"></p>
<p>（关于java中的锁，<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a>讲的很好，可以参考。就我感觉《JVM详解》这本书其实把几个概念混在一起讲了）</p>
<h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>通过互斥方式进行同步，保证共享数据在同一时刻只能被一个或几个线程使用。常见的互斥手段有临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore），且都是阻塞访问：未取得锁的线程会被挂起等待唤醒。</p>
<p>一般这种东西都依赖操作系统支持，需要在用户态和内核态来回切换，因此也是一种比较重的操作。由于使用这种锁的场景是认为使用共享变量期间总会被其他线程修改，因此每次访问时都需要拿到锁，这种并发策略又叫悲观并发策略，这一策略下的锁机制被称为悲观锁</p>
<p>Java中常见的互斥锁有<code>synchronized</code>关键字和<code>ReentrantLock</code>，两者都是可重入锁（即同一个线程可以多次申请同一个锁），<code>ReentrantLock</code>能够实现的功能多一点，比如支持等待可中断、公平调度、绑定多个<code>Condition</code>对象。JDK1.5以前<code>synchronized</code>的性能不如<code>ReentrantLock</code>，1.6以后经过优化后性能已比较接近，一般来说如果没有特殊原因还是尽量使用<code>synchronized</code>关键字，毕竟是内置关键字，可以做的优化多一些，使用也更简单一些。</p>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p>与悲观锁相对的就是乐观锁，即认为使用共享变量期间基本不会被其他线程修改。乐观并发策略通常是先去尝试修改，如果修改时发现变量被修改过，则进行补偿措施（比如不断重试）。由于这种锁一般都不需要阻塞线程，因此也被称为非阻塞同步（Non-Blocking Synchronization）。</p>
<p>这种锁的核心在于“比较并修改”需要成为原子操作，而这需要底层支持。常见的指令有：</p>
<ul>
<li>测试并设置（Test-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-swap, CAS）</li>
<li>加载链接/条件存储（Load-Linked/Store-Conditional, LL/SC）</li>
</ul>
<p>其中CAS用的比较多，比如我们要让一个int值加1，就可以不断读取其当前值<code>current</code>，然后调用<code>compareAndSwap(current, current+1)</code>，如果返回成功则说明修改成功，反之则等待一段时间继续。</p>
<p>CAS的一个漏洞是变量的值相同，不代表要同步的对象没被修改过。解决方式也很简单，要么让变量的值不会重复设置，要么让变量的值和要同步的对象的状态一一对应。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的优化应该都是对<code>synchronized</code>关键字，或者<code>monitorenter</code>和<code>monitorexit</code>指令的优化。</p>
<h3 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h3><p>之前提到，进入阻塞状态会产生用户态和内核态的切换，而频繁的切换可能会造成性能下降。因此在有可能很快拿到锁的时候，可以让CPU空转并尝试等待一段时间，这种不断空转CPU的锁被称为自旋锁。</p>
<p>当然，CPU消耗也是个问题，如果等待时间过长就可能就不如进入阻塞状态了，因此需要设定一个阈值，保证超过阈值的情况下会进入阻塞。那么非固定阈值的自旋锁被称为自适应自选，比如可以认为刚刚拿到过锁的线程很可能再次拿到锁。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>如果开启逃逸分析，且分析出某个变量不会逃逸出线程空间，那么就可以取消对这个变量的同步操作。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果一个代码段内频繁对一个锁进行反复加锁和解锁，甚至在一个循环里，那么可以将锁的申请和释放放在代码段的前和后，避免频繁切换</p>
<h3 id="偏向锁、轻量级锁和重量级锁"><a href="#偏向锁、轻量级锁和重量级锁" class="headerlink" title="偏向锁、轻量级锁和重量级锁"></a>偏向锁、轻量级锁和重量级锁</h3><p>之前的章节提到，JVM每个对象都有一个<code>mark word</code>，来维护这个对象的一些运行状态，包括hashcode、GC分代信息、锁状态等，且根据不同状态，其含义也不同，如下图所示：</p>
<p><img src="/images/jvm_mark_word.png" alt="mark word"></p>
<p>可以看到，从锁状态的角度分析，object的状态可以分为可偏向状态、已偏向状态、不可偏向状态、轻量级锁状态、重量级锁状态，其转换关系如下图所示</p>
<p><img src="/images/jvm_object_lock_states.png" alt="lock states"></p>
<p>在获取object的锁时，如果object此时是可偏向的，那么JVM会先尝试获得偏向锁，即通过CAS将mark word前面的部分置为本线程ID，如果成功，且之后没有线程竞争这个object，那么就可以正常使用这个对象。偏向锁适合有同步但没有竞争的情况。解锁过程和加锁过程类似。</p>
<p>但如果存在竞争，那么偏向锁就不太合适了，这时会使用轻量级锁。轻量级锁还是CAS思想，JVM会先在当前栈帧中建立一块锁记录（lock record）空间，用于存储当前object的mark word，然后尝试通过CAS操作将对象的mark word更新为指向lock record的指针，如果成功则说明拿到了这个锁，否则自旋一段时间后进入重量级锁。解锁过程和加锁过程类似。</p>
<p><img src="/images/jvm_lightweight_lock.png" alt="轻量级锁"></p>
<p>进入重量级锁后，mark word中存储的就是指向重量级锁（互斥量）的指针，后面等待的线程也要进入阻塞状态。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/20/trans_and_ACID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/20/trans_and_ACID/" class="post-title-link" itemprop="url">事务与ACID</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-20T00:00:00+08:00">2019-09-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-23 11:12:09" itemprop="dateModified" datetime="2019-09-23T11:12:09+08:00">2019-09-23</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前没太搞懂幻读是什么意思，今天又查了下相关资料，补充一下。</p>
<p>我们可以设想数据库是一系列静态数据的集合，某一时刻这个集合的所有元素及其关系构成了数据库的当前状态，一般来说如果“状态”不变，那么对外相同的读操作返回的结果是一样的；对数据库的写操作（增、删、改）会导致数据库从一个状态转移到另一个状态，而一系列读写操作的序列成为事务。</p>
<p>一般我们会对事务拥有以下一些特性：</p>
<ul>
<li>原子性(atomicity)：这一系列操作要么都成功要么都失败，不允许将数据库状态滞留在某个中间环节</li>
<li>一致性(consistency)：事务只能将数据库从一个有效的（valid）状态迁移到另一个有效的状态</li>
<li>隔离性(isolation)：事务执行时理论上应当观测不到对方是否在执行</li>
<li>持久性(durability)：事务提交并返回成功后，数据库应当保证永远记录其操作结果</li>
</ul>
<p>我看到的说法是一致性是目的，其他三个特性是为了保证一致性的手段</p>
<h3 id="持久性-durability"><a href="#持久性-durability" class="headerlink" title="持久性(durability)"></a>持久性(durability)</h3><p>一般来说所有对数据库的操作都会有保留写日志，且会保存某个正确状态的副本/快照，这样一来一旦某个事务被提交（committed），且我们如果可以保证这个事务相关的写日志不丢，就可以保证事务的持久化。</p>
<h3 id="原子性-atomicity"><a href="#原子性-atomicity" class="headerlink" title="原子性(atomicity)"></a>原子性(atomicity)</h3><p>几乎所有事务都要求要么成功要么失败，而即使是很短的事务也可能执行到一半中途停止，又或者事务提交后觉得不合适又要取消，因此往往会要求事务能够回滚（rollback）。</p>
<p>先不考虑执行完后回滚的情况。显然，既然我们保留了写日志，那么从当前时刻的状态开始反向回放写日志，就可以恢复到事务提交前的状态；为了提高效率，可以在事务执行时设置一些检查点（check point），保存了事务执行到那一步时的数据库（部分）状态，这样回滚的时候直接跳到checkpoint即可。</p>
<p>对于支持MVCC（Multi-Version Concurrency Control，多版本并发控制）的数据库而言，每个事务有一个全局唯一递增的时间戳/版本号，那么理论上只要把有相同时间戳的数据删掉就可以回滚到该事务运行之前，但前提是这个事务的中间结果不可以被其他事务观察到，这也引出了事务的隔离性</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>理想情况是数据库执行事务的时候是顺次执行的，但实际上为了提高效率，事务之间往往是并发执行，因此就导致事务之间很可能相互干扰，常见的干扰有：</p>
<ul>
<li>脏读（dirty read）：事务中的修改，即使未提交也会被其他事务看到</li>
<li>不可重复读（nonrepeatable read）：同一事务内执行时，多次读同一数据，得到的结果不同</li>
<li>幻读（phantom read）：同一事务内执行时，同样的范围查询得到的结果不同</li>
</ul>
<p>幻读和不可重复的读区别在于前者针对的是范围，后者针对的是某条具体的数据，而这点至少可以通过只对某条记录加锁就可以保证。与这三个问题相对应的是四种隔离级别：未提交读（read uncommitted）、提交读（read committed）、可重复读（repeatable reads）、可串行化（serializable），分别解决了三个问题</p>
<p>我理解，“MVCC天然支持快照读，也就天然保证了隔离级别是可重复读”这个想法其实不完全对，假设事务都是先写WAL再落盘，那么在落盘的过程中，如果没有任何保障措施，对于大于该事务时间戳的事务而言，还是会出现不可重复读的情况。</p>
<p>最简单的保障措施就是加锁，缺点是并发量降低。MySql中，MyISAM不支持事务，事务的ACID也就无从谈起；InnoDB引擎的默认隔离级别是可重复读，而上文也提到MVCC并不能保证带时间戳的快照读就等价于可重复读。中文相关的解释可以参考<a href="https://www.zhihu.com/question/67739617/answer/257065584" target="_blank" rel="noopener">关于mysql事务隔离级别MVCC多版本控制的一个疑问？ - 聿明leslie的回答 - 知乎</a>，简单来说就是事务提交成功并落盘的时候，会标明这页的数据被修改过，那么其他事务读到这一页数据的时候需要读最新数据+undo，回退到较早版本再读。</p>
<p>而对于幻读，innodb的做法是加next-key lock，它包括一个行锁和一个区间锁，这样在事务的进行中可以避免其他事务插入/删除要关注的区间。按我理解如果区间无法确定，还是要锁表。</p>
<h3 id="一致性（consistency）"><a href="#一致性（consistency）" class="headerlink" title="一致性（consistency）"></a>一致性（consistency）</h3><p>老实说我还是不太理解这个性质是什么意思，目前理解是数据库不能暴露出事务运行中间的状态。那么在分布式数据库中，某一时刻各个副本内容不同的状态也可以认为是“事务运行中间的状态”？</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/19/jvm9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/19/jvm9/" class="post-title-link" itemprop="url">JVM学习（9）Java内存模型与线程</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-19 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-19T00:00:00+08:00">2019-09-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-18 18:07:23" itemprop="dateModified" datetime="2019-09-18T18:07:23+08:00">2019-09-18</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java的一个重要应用场合是服务端，这对并发处理要求很高，因此JVM需要对并发处理提供足够的支持。</p>
<p>同一台机器上的并发控制主要体现在CPU每个核与其他核数据一致性问题，现代计算机为每个计算单元提供了寄存器缓存，那么访问和修改时可能会因为缓存不一致而导致一些问题。此外，由于指令乱序执行，会导致如果一个线程依赖另一个线程的中间变量时会出现意想不到的后果。</p>
<p><img src="/images/jvm_machine_memory_model.png" alt="处理器、高速缓存、主内存之间的交互关系"></p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>JVM规范试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各种硬件和平台的内存访问差异，实现让java在各种平台下都能达到一致的内存访问效果。如下图所示，可以将JVM内存模型和上图进行一一对应</p>
<p><img src="/images/jvm_memory_model.png" alt="线程、主内存、工作内存之间的交互关系"></p>
<p>JMM的变量主要指实例字段、静态字段、数组中的对象等，而不包括局部变量和方法参数（仅指变量的引用），因为后者是线程私有的，不会被共享，所以是线程安全的。JMM规定所有变量都存储在主内存（Main Memory）中；每个线程还有自己的工作内存（Working Memory），工作内存可以有主缓存中某个部分的缓存，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程之间无法直接访问对方的工作内存，线程间的变量共享只能通过主内存完成。</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>JMM规定了以下8种操作是原子操作，用于内存交互：</p>
<ol>
<li>lock（锁定）：作用于主内存，将一个变量标识为某个线程独占</li>
<li>unlock（解锁）：作用于主内存，将一个变量状态解锁</li>
<li>read（读取）：作用于主内存，将一个变量的值从主内存传输到工作内存</li>
<li>load（载入）：作用于工作内存，把read得到的变量放入工作内存的变量副本中</li>
<li>use（使用）：作用于工作内存，将其中的一个变量的值传递给工作引擎，每当执行引擎遇到一个需要使用变量的值的字节码指令时将会执行这个操作</li>
<li>assign（赋值）：作用于工作内存，将一个从执行引擎接收到的值复制给工作内存的变量，每当执行引擎遇到一个赋值的字节码指令时执行这个操作</li>
<li>store（存储）：作用于工作内存的变量，将工作内中一个变量的值传送到主内存中，以便write操作使用</li>
<li>write（写入）：作用于主内存的变量，将store操作得到的变量放入主内存的变量中</li>
</ol>
<p>JVM还规定这8种操作必须满足以下约束：</p>
<ul>
<li>read和load、store和write要配对使用，且必须顺序执行（但不一定连续）</li>
<li>不允许一个线程丢弃它最近的assign操作，即变量一旦在工作内存中被改变，就必须将其同步到主内存</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）将数据从线程的工作内存同步回主内存</li>
<li>一个新变量只能在主内存中“诞生”，不允许工作内存中直接使用一个未被初始化的值。换言之，在对一个变量进行use、store操作前，必须先执行过assign、load</li>
<li>一个变量在同一时刻只允许一个线程对其进行lock操作，但可以被同一个线程重复执行多次，且只有执行相同次数的unlock后才能解锁该变量</li>
<li>执行lock操作后，工作内存中此变量的值会被清空，在执行引擎使用这个变量前，需要重新执行load或assign操作，初始化变量的值</li>
<li>不允许unlock未被lock的变量，或被其他线程lock的变量</li>
<li>对变量执行unlock前，必须先将此变量同步回主内存</li>
</ul>
<h3 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h3><p>对于被<code>volatile</code>修饰的变量，JVM有一些特殊的规定，保证volatile变量有两个特性：</p>
<ul>
<li>可见性：如果volatile变量被一个线程修改过，那么其他线程可以立即得知改变后的值（但不代表它是线程安全的，因为修改过程未必是原子的）</li>
<li>禁止指令重排序优化：禁止volatile变量相关的指令重排序优化</li>
</ul>
<p>可见性很容易理解，指令重排可以举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread A</span></span><br><span class="line">do_initialize();</span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread B</span></span><br><span class="line"><span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">do_work();</span><br></pre></td></tr></table></figure>

<p><code>flag</code>变量表示是否初始化，指令重排序优化可能会使得线程A中的<code>flag=true;</code>执行在<code>do_initialize()</code>前，进而导致线程B未初始化的情况下就继续工作。</p>
<p>（其实我以前在c#还是C++里也遇到过这种坑，只是如果<code>flag</code>不被volatile修饰的话，线程B会认为<code>flag</code>一直是<code>false</code>，从而导致循环一直在执行）</p>
<p>一般禁止指令重排序的方式是在相关操作字节码前/后插入一个内存屏障（Memory Barrier或Memory Fence），类似<code>lock addl $0x0, (%esp)</code>之类的空操作，但由于这条指令在cpu执行时一定保证它之后的指令不会被优化到前面，因此保证了这条指令前后的代码块执行时有严格的时间顺序。JMM通过以下额外规则保证volatile变量V,W具有上述性质：</p>
<ul>
<li>对V的load和use操作指令必须连续执行，不可以单独进行load或use，这保证了使用volatile变量的值每次使用时都是从主内存获得的</li>
<li>对V的assign和store操作指令必须连续执行，不可以单独进行assign或store，这保证了volatile变量一旦被修改过立刻同步会主内存</li>
<li>将use-load-read或assign-store-write操作序列记为f1-f2-f3，如果f1(V)在f1(W)前，那么f3(V)在f3(W)前，这保证了volatile变量不会被指令重排序优化</li>
</ul>
<h3 id="long和double变量"><a href="#long和double变量" class="headerlink" title="long和double变量"></a>long和double变量</h3><p>JMM允许对64位的long和double的read、write、load、store操作可以不保证原子性，也就是说理论上存在如果多个线程共享一个非volatile的long或double变量，那么可能会读到一个“修改到一半”的值</p>
<p>几乎所有商用JVM都会保证对long和double的原子性，因此一般也不用专门将long和double声明为volatile</p>
<h3 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h3><p>所以JMM是围绕并发过程中如何处理原子性、可见性和有序性来建立的</p>
<ul>
<li>原子性（Atomicity） ：可以认为基本类型的访问读写都是原子性的，而对于更大规模的事务，需要用lock和unlock来进行处理。JVM提供<code>monitorenter</code>和<code>monitorexit</code>两个字节码来隐式使用这两个操作，反映到java代码就是<code>synchronized</code>关键字。</li>
<li>可见性（Visibility）：上文提到<code>volatile</code>可以让一个变量的修改立刻被所有线程感知到，此外<code>synchronized</code>和<code>final</code>关键字也可以提供可见性：由于<code>synchronized</code>隐式调用了unlock，JMM规定unlock前需要先将变量同步回主内存，而其他线程获取这个变量又一定在unlock后；<code>final</code>则是逻辑上保证初始化后才能被其他线程使用</li>
<li>有序性（Ordering）：天然的有序性是指本线程内的进行观察，所有的操作都是有序的（As-If-Serial Semantics），而其他线程观察这一线程则未必（由指令重排/内存同步延迟导致）。可以通过volatile和synchronized来实现有序性。</li>
</ul>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>指令重排序可以提高程序运行效率，但也导致程序执行结果不一定能够保持原意，因此JMM提出了几个先行发生原则。所谓的先行发生（happens-before），是指如果操作A happens before操作B，那么B可以观测到A产生的所有影响。</p>
<p>JMM规定以下所有操作需要保证以下规则：</p>
<ol>
<li>程序次序规则（Program Order Rule）：同一线程内按照程序代码顺序执行，书写在前面的操作要happens-before后面的操作（分支、循环之类的另说）</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作happens-before后面对同一个锁的lock操作，这里“后面”是时间上的顺序</li>
<li>volatile变量规则（Volatile Variable Rule）：对有一个volatile变量的写操作happens-before后面对这个变量的读操作，这里“后面”是时间上的顺序</li>
<li>线程启动原则（Thread Start Rule）：Thread对象的start()方法happens-before此线程的每一个动作</li>
<li>线程终止原则（Thread Termination Rule）：线程中所有操作都happens-before对此线程的终止检测，终止检测是指<code>Thread.join()</code>、<code>Thread.isAlive()</code>等终止和检测方法</li>
<li>线程中断原则（Thread Interruption Rule）：对线程的<code>interrupt()</code>方法的调用happens-before被中断线程的代码检测到中断事件发生，比如<code>Thread.interrupted()</code></li>
<li>对象终结原则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结果）happens-before它的<code>finalize()</code>方法</li>
<li>传递性（Transitivity）：如果操作A happens-before B，B happens-before C，则A happens-before C</li>
</ol>
<p>Java中无需任何同步手段，只要操作间符合以上规则，都可以保证这些操作是“顺序的”。另外A happens-before B不代表A一定在B之前执行，反之亦然，比如两个线程读写同一个非volatile变量，很可能A先对变量赋值，但因为同步延迟，B后读到的值还是原来的；同样的，同一代码块里的指令如果没有依赖性，那么后写的代码也可能被指令重排序到前面执行。</p>
<h2 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h2><p>Java提供了不同硬件和平台下对线程的统一处理，每个执行了<code>start()</code>且未结束的<code>java.lang.Thread</code>类实例就代表了一个线程，但具体怎么实现取决于平台。实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程+轻量级线程混合实现。</p>
<h3 id="使用内核线程实现"><a href="#使用内核线程实现" class="headerlink" title="使用内核线程实现"></a>使用内核线程实现</h3><p>内核线程（Kernal-Level Thread，KLT）就是直接由从操作系统内核（Kernal）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。</p>
<p>程序一般不会直接去使用内核线程，而使用内核线程的一种高级接口——轻量级进程（Light Weight Process, LWP），轻量级进程就是通常意义上的进程，一般来说和普通进程的区别也只是它只有一个最小的执行上下文和调度程序所需的统计信息。轻量级进程需要一个内核线程支持，因此这种方式需要内核支持内核线程，对应关系如下：</p>
<p><img src="/images/jvm_KLT.png" alt="内核线程和轻量级进程"></p>
<p>使用内核线程后，线程可以被内核感知到，那么某个线程阻塞后就可以内核自动切换、不会阻塞所有线程，缺点是需要进行系统调用，且占用一定内核资源，而系统支持的轻量级进程数量是有限的。</p>
<h3 id="使用用户线程实现"><a href="#使用用户线程实现" class="headerlink" title="使用用户线程实现"></a>使用用户线程实现</h3><p>广义上讲，非内核线程都是用户线程（包括轻量级进程），而狭义上的用户线程则是由纯应用程序在用户空间模拟的多线程，内核无法感知这些线程之间的切换，其建立、同步、销毁、调度不需要内核的帮助。好处是不需要内核参与，提高了效率，缺点是比如线程阻塞、处理器分配之类的问题很难处理。</p>
<p>从这个角度讲，纯由用户空间模拟的线程，可能更类似于协程？只是调度策略不太一样，毕竟很多协程之间有明显的依赖关系。</p>
<h3 id="使用用户线程-轻量级进程混合实现"><a href="#使用用户线程-轻量级进程混合实现" class="headerlink" title="使用用户线程+轻量级进程混合实现"></a>使用用户线程+轻量级进程混合实现</h3><p>简单来说就是将多个用户线程映射到多个轻量级进程上，降低阻塞概率。很多UNIX系统都提供了这种线程模型的实现。</p>
<h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>JVM未规定Java采用哪种方式实现，JDK1.7为止，在windows和linux上使用了一对一线程模型实现，而在Solaris平台下支持一对一和多对多模型，因此JVM也支持这两种模式。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>主流的线程调度有协同式调度（Cooperative Threads-Scheduling）和抢占式调度（Preemptive Threads-Scheduling），协同式调度是由线程自己来通知系统切换线程，而抢占式调度则是由系统来分配执行时间（比如时间片轮转调度算法）。</p>
<p>显然协同式调度会有线程阻塞问题，所以JVM还是用抢占式调度方式。Java可以设置线程优先级，不过只是对底层的一个建议，不一定严格保证线程优先级。</p>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了5种线程状态，任意线程在同一时间点有且只有其中一个状态：</p>
<ul>
<li>新建（New）：创建后尚未启动</li>
<li>运行（Runnable）：包括操作系统线程的running和ready状态，即可以正在执行，也可能在等待CPU分配时间</li>
<li>等待（Waiting）：不会分配CPU时间，包括无限期等待和有限期等待，都可以被其他线程唤醒，区别在于一定时间过后是否会被系统自动唤醒，进入等待状态的方式包括：<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()、LockSupport.parkNanos()、LockSupport.parkUntil()</li>
</ul>
</li>
<li>阻塞（Blocked）：不会分配CPU时间，与等待的区别是阻塞一般是在等一个排他锁，而等待则是在等一段时间或唤醒动作。</li>
<li>结束（Terminated）：终止状态</li>
</ul>
<p>几种状态的转换关系如下</p>
<p><img src="/images/jvm_thread_state_machine.png" alt="线程状态转换"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/18/jvm8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/18/jvm8/" class="post-title-link" itemprop="url">JVM学习（8）运行期优化</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-18 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-18T00:00:00+08:00">2019-09-18</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-17 19:32:57" itemprop="dateModified" datetime="2019-09-17T19:32:57+08:00">2019-09-17</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在HotSpot中，java程序最初通过解释器（Interpreter）进行解释执行的，当JVM发现某个方法或代码块运行特别频繁时，就会认为这段代码是热点代码（hot spot code），为提高这部分代码的执行效率，运行时会把其编译为本地平台相关代码，并进行各种层次的优化，完成这个任务的编译器被称为即时编译器（just in time compiler, JIT）。尽管JVM规范并没有要求一定要实现JIT，但一般主流JVM都会做，否则效率太低。</p>
<h2 id="编译时机"><a href="#编译时机" class="headerlink" title="编译时机"></a>编译时机</h2><p><img src="/images/jvm_interpreter_and_compiler.png" alt="解释器和编译器"></p>
<p>如上图所示，主流编译器一般都有解释器和编译器。解释器的优势是能够省去编译过程，立即执行代码；而在运行稳定后，将代码编译为本地代码能够提高执行效率，当然这样也会占用更多内存。此外，当编译器选择激进优化时，如果激进优化假设不成立，那么解释器可以作为“逃生门”，通过逆优化（deoptimization）退回到解释状态继续执行（或者不激进优化的C1编译器）。</p>
<p>HotSpot内置了两个JIT，分别是Client Compiler（C1）和Server Compiler （C2），一般默认采用一个编译器和解释器直接配合的工作方式，用哪种编译器取决于JVM运行模式，HotSpot会根据硬件性能和自身版本选择运行模式，用户也可以通过参数指定模式。解释器和编译器搭配使用的方式被称为混合模式（mix mode），只使用其中某一个分别被称为解释模式（interpreted mode）和编译模式（compiled mode），可以通过<code>-Xint</code>和<code>-Xcomp</code>来选择。</p>
<p>编译成本地代码本来就需要时间，优化程度越高时间越长，且有时候可以通过监控运行时信息来进行优化，时间就会更长。因此HotSpot会启用分层编译（tiered compilation）策略，JDK1.7的server模式将其作为默认策略。分层编译根据编译器编译、优化的规模和耗时，划分出不同的编译层次，包括</p>
<ul>
<li>第0层，解释执行，不开启性能监控功能（profiling），可触发第一层编译</li>
<li>第1层，也称C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如果有必要将加入性能监控逻辑</li>
<li>第2层（或2层以上），也称C2编译，也是将字节码编译为本地代码，但会启用一些耗时较长的优化策略，甚至会根据性能监控信息进行一些不可靠的激进优化</li>
</ul>
<p>分层编译开启后，client compiler和server compiler会同时工作，许多代码会被多次编译。</p>
<h3 id="编译对象和触发条件"><a href="#编译对象和触发条件" class="headerlink" title="编译对象和触发条件"></a>编译对象和触发条件</h3><p>热点代码包括两类：</p>
<ul>
<li>被多次调用的方法</li>
<li>被多次执行的循环体</li>
</ul>
<p>无论哪种情况，编译器都会选择将整个包含热点的方法作为编译对象，而第二种情况因为编译过程发生在方法执行中，因此被称为栈上替换（on stack replacement, OSR编译）。那么问题就在于如何探测一个方法/循环被执行多少次，以及多少次算热点。探测执行次数的方式有两种：</p>
<ul>
<li>基于采样的热点探测（Sample Based Hot Spot Detection）：周期性的检查各个线程的栈顶，如果某个方法经常出现，那么它就是热点方法。好处是简单高效，且容易获得调用结构，缺点是容易受到线程阻塞或者别的外界因素干扰。</li>
<li>基于计数器的热点探测（Counter Based Hot Spot Detection）：为每个方法/代码块建立和维护计数器，执行次数超过某个值就认为是热点方法。好处是更加准确，缺点是拿不到调用关系而且比较麻烦</li>
</ul>
<p>HotSpot采用第二种方式，且为每个方法准备了两个计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter），两个计数器都有一个确定的阈值，超过阈值后会触发JIT编译。方法调用计数器容易理解，用于记录被调用了多少次，client模式下阈值是1500，server模式下阈值是10000，也可以通过<code>-XX:CompileThreshold</code>设置：更准确的说是频次，即一定时间内的调用次数。如果超过一定时间，那么计数器会减半，这一过程被称为方法调用计数器的热度衰减（Counter Decay），相对应的时间被称为此方法统计的半衰期（Counter Half Life Time），也可以通过参数关闭热度衰减或设置半衰期时间。方法在执行时，会优先选择已被编译好的本地代码版本，如果没有优化好的版本且满足优化条件则会提交一个编译请求，等编译完成后，这个方法的入口地址就会被系统自动改写成新的。</p>
<p><img src="/images/jvm_invocation_counter_workflow.png" alt="方法调用计数器触发即时编译"></p>
<p>回边计数器用来统计一个方法中的循环体代码执行的次数，在字节码遇到控制流向后跳转的指令被称为回边（Back Edge），显然出现回边意味着存在循环。和方法调用计数器不同，回边计数器的阈值通过方法调用计数器阈值（CompileThreshold）、OSR比率（OnStackReplacePercentage）和解释器监控比率（InterpreterProfilePercentage）决定，计算方式为：</p>
<ul>
<li>Client模式下：<code>$CompileThreshold*$OnStackReplacePercentage/100</code>，全取默认值是13995</li>
<li>Server模式下：<code>$CompileThreshold*($OnStackReplacePercentage-$InterpreterProfilePercentage)/100</code>，全取默认值是10700</li>
</ul>
<p>解释器遇到回边指令时，会先查找有没有已经编译好的版本，有的话执行编译后的版本，没有则增加回边计数器，超过阈值时会提交一个OSR编译请求，并降低一些回边计数器的值，以便在循环中等待执行，如下图所示。</p>
<p><img src="/images/jvm_back_edge_counter_workflow.png" alt="回边计数器触发即时编译"></p>
<p>回边计数器没有热衰过程，记录的是绝对运行次数。但无论是哪种编译方式，JVM都默认编译过程可以和解释执行并行执行。用户也可以用<code>-XX:-BackgroundCompilation</code>禁止后台编译，这种情况下达到JIT条件时，用户线程会等待直到编译完成。</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="C1编译器"><a href="#C1编译器" class="headerlink" title="C1编译器"></a>C1编译器</h3><p>C1是一个简单快速的三段式编译器，主要关注局部性优化，放弃了许多耗时较长的全局优化手段。</p>
<ol>
<li>一个平台独立的前端会将字节码构造成一种高级中间代码表示（High-Level Intermediate Representation，HIR）。HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，使得一些在HIR的构造过程中和之后进行的优化动作更容易实现。在此之前编译器会在字节码的基础上完成一部分基础优化，如方法内联、常量传播等。</li>
<li>一个平台相关的后端会从HIR中产生低级中间代码表示方法（Low-Level Intermediate Representation，LIR），在这一步之前会完成另外一些优化，如空值检查消除、范围检查消除等，让HIR达到更高效的代码表达形式</li>
<li>一个平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔优化（Peephole optimization，一种局部的汇编指令优化手段，类似删除冗余的<code>store</code>和<code>load</code>、用左移指令代替乘2指令等，参考<a href="https://blog.csdn.net/liumf2005/article/details/8858102" target="_blank" rel="noopener">窥孔优化 peephole optimization</a>），然后产生机器代码。C1编译过程大致如下图所示。</li>
</ol>
<p><img src="/images/jvm_c1_compiler.png" alt="C1编译器架构"></p>
<h3 id="C2编译器"><a href="#C2编译器" class="headerlink" title="C2编译器"></a>C2编译器</h3><p>C2是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，以及一些和java语言特性密切相关的优化技术</p>
<p>C2编译器的寄存器分配器是一个全局图着色分配器，可以充分利用某些处理器架构（如RISC）上的大部分寄存器集合。总的来说，C2的优化效果更好，但耗时更高。</p>
<h2 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h2><p>这里介绍一些常见的优化技术</p>
<h3 id="冗余访问消除（Redundant-Loads-Elimination）"><a href="#冗余访问消除（Redundant-Loads-Elimination）" class="headerlink" title="冗余访问消除（Redundant Loads Elimination）"></a>冗余访问消除（Redundant Loads Elimination）</h3><p>将类似<code>a = foo.a; b = foo.a</code>优化为<code>a = foo.a;b=a;</code>来减少访问，类似公共子表达式消除</p>
<h3 id="常量传播（Constant-Propagation）"><a href="#常量传播（Constant-Propagation）" class="headerlink" title="常量传播（Constant Propagation）"></a>常量传播（Constant Propagation）</h3><p>在编译时将能够计算出结果的变量直接替换成常量</p>
<h3 id="复写传播（Copy-Propagation）"><a href="#复写传播（Copy-Propagation）" class="headerlink" title="复写传播（Copy Propagation）"></a>复写传播（Copy Propagation）</h3><p>如果某个局部变量完全等价于另一个变量，那么就可以用另一个变量来替换，例如将<code>a = foo.a; b = a; s = a+b</code>可以优化为<code>a = foo.a; s = a+a</code></p>
<h3 id="无用代码消除（Dead-Code-Elimination）"><a href="#无用代码消除（Dead-Code-Elimination）" class="headerlink" title="无用代码消除（Dead Code Elimination）"></a>无用代码消除（Dead Code Elimination）</h3><p>移除对程序运行结果没有任何影响的代码，包括不会运行到的代码和只会影响到无关程序运行结果的变量（Dead Variables），比如空循环</p>
<h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>如果一个表达式E已经被计算了，且从开始计算到现在E中所有变量的值都没有发生变化，那么可以复用这个表达式计算结果</p>
<p>此外还可以进行代数简化，比如将<code>d = E * 12 + a + (a + E)</code>变化为<code>d = E * 13 + a * 2</code></p>
<h3 id="循环展开（Loop-Unrolling）"><a href="#循环展开（Loop-Unrolling）" class="headerlink" title="循环展开（Loop Unrolling）"></a>循环展开（Loop Unrolling）</h3><p>增大循环步伐和循环体长度，减少总的循环次数，这样有利于指令并行执行</p>
<h3 id="循环表达式外提（Loop-Expression-Hoisting）"><a href="#循环表达式外提（Loop-Expression-Hoisting）" class="headerlink" title="循环表达式外提（Loop Expression Hoisting）"></a>循环表达式外提（Loop Expression Hoisting）</h3><p>将循环中每次计算结果不变的表达式放在循环前提前计算，从而减少每次循环的计算量</p>
<h3 id="基本块重排序（Basic-Block-Reordering）"><a href="#基本块重排序（Basic-Block-Reordering）" class="headerlink" title="基本块重排序（Basic Block Reordering）"></a>基本块重排序（Basic Block Reordering）</h3><p>通过重排指令提高cache命中率、利用cpu流水线、cpu预读等方式加快运行</p>
<h3 id="范围检查消除（Range-Check-Elimination）"><a href="#范围检查消除（Range-Check-Elimination）" class="headerlink" title="范围检查消除（Range Check Elimination）"></a>范围检查消除（Range Check Elimination）</h3><p>去掉一定不会越界的数组越界检查</p>
<p>此外java还有很多安全检查，比如空值检查、空指针检查、除零检查等，实际上有时候一段代码不见得就安全，但可以认为出错概率很低，因此可以通过增加隐式异常处理来避免安全检查，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo != <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以改写为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> foo.value;</span><br><span class="line">&#125; <span class="keyword">catch</span> (segment_fault)&#123;</span><br><span class="line">    uncommon_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即JVM会注册一个Segment Fault信号的异常处理器（对应<code>uncommon_trap()</code>）来进行异常处理，代价是如果发生异常，需要从用户态转到内核态中处理再回到用户态，速度远比一次判空检查慢。</p>
<p>显然如果<code>foo</code>经常为空的话，这种优化会让程序更慢，所以HotSpot会收集运行期信息来选择最佳方案。</p>
<p>类似还有自动装箱消除（Autobox Elimination）、安全点消除（Safepoint Elimination）、反射消除（Dereflection）等都可以通过隐式异常处理进行优化。</p>
<h3 id="分支频率预测（Branch-Frequency-Prediction）"><a href="#分支频率预测（Branch-Frequency-Prediction）" class="headerlink" title="分支频率预测（Branch Frequency Prediction）"></a>分支频率预测（Branch Frequency Prediction）</h3><p>激进优化，预先执行极有可能被选择的分支，提高流水线效率</p>
<h3 id="内联（Method-inlining）"><a href="#内联（Method-inlining）" class="headerlink" title="内联（Method inlining）"></a>内联（Method inlining）</h3><p>方法内联很容易理解：将不会被复写的方法代码“copy”到调用点，这样减少方法调用成本（如建立栈帧等），且能够为其他优化建立良好的基础。</p>
<p>由<code>invokevirtual</code>指令调用的非<code>final</code>方法原则上无法内联，原因在于运行期间无法确定这个方法是否被复写过。但其实很多方法只有一个版本，那么可以想办法对这种方法进行内联，比如</p>
<ol>
<li>类型继承关系分析（Class Hierarchy Analysis，CHA）：分析所有已加载的类的继承关系，确定某些方法是否多余一种的实现，如果没有则可以内联</li>
<li>内联缓存（Inline Cache）：在调用时记录内联方法的版本并缓存相关代码，如果之后的访问命中缓存则可以继续执行内联，否则进行正常调用</li>
</ol>
<p>多数情况下内联是一种激进的优化策略，如果内联失败时需要有一个备用方案，需要预留一个逃生门，这种内联被称为守护内联（Guarded Inlining）。</p>
<h3 id="逃逸分析（Escape-Analysis）"><a href="#逃逸分析（Escape-Analysis）" class="headerlink" title="逃逸分析（Escape Analysis）"></a>逃逸分析（Escape Analysis）</h3><p>即分析对象动态作用域，比如一个对象在某个方法中被定义后，如果能够被其他方法引用，则称为方法逃逸；如果某个线程定义的对象被其他线程引用到，则称为线程逃逸。显然，如果能够分析出一个对象不会逃逸出某个范围，那么就可以针对这一特性进行优化，比如：</p>
<ol>
<li>栈上分配（Stack Allocation）：如果确定一个变量不会逃逸出方法之外，那么就可以在栈上分配这个对象，提高分配/回收效率，避免GC过程</li>
<li>同步消除（Synchronization Elimination）：如果确定一个变量不会逃逸出线程，那么这个变量的读写就不会有竞争，可以取消对这个变量的同步过程</li>
<li>标量替换（Scalar Replacement）：如果一个对象不会被外部访问，且可以拆分，那么不创建这个对象，而改为创建它的若干个被引用到的变量。标量替换后还可以提高分配和读写效率（栈上分配）外，还可以进一步被其他优化手段优化（比如复写传播等）</li>
</ol>
<p>JDK1.8默认开启逃逸分析，也可以通过<code>-XX:-DoEscapeAnalysis</code>关闭</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/16/jvm7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/16/jvm7/" class="post-title-link" itemprop="url">JVM学习（7）编译期优化</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-16 00:00:00 / Modified: 21:08:08" itemprop="dateCreated datePublished" datetime="2019-09-16T00:00:00+08:00">2019-09-16</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一章主要介绍关于在.java代码编译为.class文件时使用的一些优化技术。实际操作时一般用javac来实现，其编译过程大致分为3个过程：</p>
<ol>
<li>解析和填充符号表</li>
<li>插入式注解处理器的注解处理过程</li>
<li>分析与字节码生成过程</li>
</ol>
<p>这三个步骤的关系如下：</p>
<p><img src="/images/jvm_compile_process.png" alt="javac编译顺序"></p>
<p>Javac编译动作入口是<code>com.sun.tools.javac.main.JavaCompiler</code>类，基本流程如下</p>
<p><img src="/images/jvm_javac_flow.png" alt="javac"></p>
<h2 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h2><h3 id="词法和语法分析"><a href="#词法和语法分析" class="headerlink" title="词法和语法分析"></a>词法和语法分析</h3><p>词法分析是将源码的字符流转变为标记（token）集合的过程，词法分析由<code>com.sun.tools.javac.parser.Scanner</code>来实现。</p>
<p>语法分析是根据token序列构造抽象语法树（abstract syntax tree，AST），它的每个节点代表一个语法结构（construct），语法分析由<code>com.sun.tools.javac.tree.JCTree</code>来实现。之后的操作都是基于AST。</p>
<h3 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h3><p>填充符号表的过程对应上图中的<code>enterTrees()</code>，符号表（symbol table）是由一组符号地址和符号信息构成的表格，在各个编译阶段都会用到：语义分析时，需要根据符号表进行语义检查（如检查一个名字的使用是否和声明一致）和产生中间代码；在目标代码生成阶段，在对符号进行地址分配时需要用到符号表。</p>
<p>这个阶段由<code>com.sun.tools.javac.comp.Enter</code>类来实现，其出口是一个待处理列表（to do list），包含了每一个编译单元的AST顶级节点，以及package-info.java（如果有的话）的顶级节点</p>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>JDK1.5后支持了注解（annotation），可以作用于运行期；JDK1.6后提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，即允许开发者对编译器的行为做一定干涉。</p>
<p>具体可以参考<a href="https://github.com/linxiaoyang/JSR269TEST" target="_blank" rel="noopener">实践JSR269关于编译期注解的使用且搞清Lombok实现原理</a>，注意如果是自己写的话，要依赖<code>$JAVA_HOME/lib/tools.jar</code>这个包，并且由于这个步骤在编译期而非运行期，调试时需要对类似<code>javac -processor ...</code>这样的命令进行调试。</p>
<h2 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h2><p>得到AST不代表源码符合逻辑，因此需要再对其进行语义检查和分析，包括标注检查和控制流分析两个步骤，分别对应图1中<code>attribute()</code>和<code>flow()</code>方法</p>
<h3 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h3><p>主要检查类似变量使用前是否被声明、变量与赋值之间的数据类型是否匹配、常量折叠等。常量折叠是针对能在编译期计算出来的常量进行计算和简化，减少运行期负担。相关的类是<code>com.sun.tools.javac.comp.Attr</code>和<code>com.sun.tools.javac.comp.Check</code>。</p>
<h3 id="数据和控制流分析"><a href="#数据和控制流分析" class="headerlink" title="数据和控制流分析"></a>数据和控制流分析</h3><p>和类加载时控制流分析类似，可以检查出诸如程序局部变量在使用前是否赋值、方法的每条路径是否都有返回值、所有异常都被处理等。还有些只能在编译期检查出来，比如一个局部变量被声明为<code>final</code>，可能编译出来的.class文件会没有相关修饰符，而编译期可以检查这个变量是否被修改过。相关的类是<code>com.sun.tools.javac.comp.Flow</code>。</p>
<h3 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h3><p>语法糖（syntactic sugar）是指编程语言中增加的某些语法，它对语言功能没有影响，但更方便书写。Java的语法糖比如泛型（类型擦除）、变长参数（传个数组进去）、自动拆箱/装箱（如<code>int</code>和<code>Integer</code>转换）。这些语法糖在编译期会被还原成基础的语法结构。相关的类是<code>com.sun.tools.javac.comp.TransTypes</code>和<code>com.sun.tools.javac.comp.Lower</code>。</p>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>JDK1.5后增加了泛型，不过java是伪泛型：比如<code>ArrayList&lt;Integer&gt;</code>和<code>ArrayList&lt;String&gt;</code>在java里是同一类，而在C#里是两个不同的类，java在编译后会把具体类型替换为Object，在相关位置加入强制类型转换代码。</p>
<p>不过类型擦除只是对Code属性中的字节码进行擦除，Signature里还有泛型信息，因此可以通过反射得到参数化类型，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(List&lt;T&gt; a, Set&lt;Integer&gt; b)</span></span>&#123;</span><br><span class="line">    a.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class cls = HelloWorld.class;</span><br><span class="line">    Method method = cls.getDeclaredMethod(<span class="string">"hello"</span>, List.class, Set.class);</span><br><span class="line">    System.out.println(((ParameterizedTypeImpl)method.getGenericParameterTypes()[<span class="number">0</span>]).getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(((ParameterizedTypeImpl)method.getGenericParameterTypes()[<span class="number">1</span>]).getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T</span></span><br><span class="line"><span class="comment">// class java.lang.Integer</span></span><br></pre></td></tr></table></figure>

<h4 id="自动装箱-拆箱和遍历循环"><a href="#自动装箱-拆箱和遍历循环" class="headerlink" title="自动装箱/拆箱和遍历循环"></a>自动装箱/拆箱和遍历循环</h4><p>这些解释起来比较简单，比如这样一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : list)&#123;</span><br><span class="line">      s += i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可能会被翻译为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">        Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">        Integer.valueOf(<span class="number">4</span>)&#125;);</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator iter = list.iterator(); iter.hasNext();)&#123;</span><br><span class="line">      <span class="keyword">int</span> i = ((Integer)iter.next()).intValue();</span><br><span class="line">      s += i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当然自动拆箱/装箱里有些坑，比如各路面试里都特别喜欢考因为类似<code>IntegerCache</code>及其上下界，导致自动装箱后的引用相同等等。简单来说由于<code>Integer</code>等类型是不可变的，也就不用担心线程安全等问题，因此可以对一些经常出现的常量（比如<code>Integer.valueOf()</code>）这种的可以进行cache，比如<code>Integer</code>里默认会对<code>[-128, 127]</code>这个范围内的数字进行cache，避免每次因为<code>Integer.valueOf()</code>创建新的对象。不过<code>new Integer()</code>总会创建新的对象。</p>
<p>另一个坑是循环时对数组进行操作，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"123"</span>);</span><br><span class="line">    list.add(<span class="string">"456"</span>);</span><br><span class="line">    list.add(<span class="string">"798"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String s : list)&#123;</span><br><span class="line">      list.remove(s);</span><br><span class="line">      System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 报错java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>

<p>解语法糖后可以看到这种删除方式会导致迭代器不可用，因此需要改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; iter = list.iterator(); iter.hasNext();)&#123;</span><br><span class="line">  System.out.println(iter.next());</span><br><span class="line">  iter.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>Java默认如果检测到某条分支永远不会执行到，会拒绝编译，最典型的是<code>return;</code>后的语句。所以一般会用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>这样的方式来避免拒绝编译。实际上控制流分析后也会把相关代码忽略掉。</p>
<p>另外比如内部类、枚举类、断言语句、<code>switch</code>枚举类和字符串、<code>try</code>的自动关闭资源等都是通过语法糖实现的。</p>
<h3 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h3><p>字节码生成是javac编译过程的最后一个阶段，由<code>com.sun.tools.javac.jvm.Gen</code>类完成，除了将之前生成的信息转为字节码落盘外，还进行了少量代码添加和转换工作。比如把<code>&lt;cinit&gt;()</code>涉及到的语句合并在一起、将字符串加操作用<code>StringBuilder</code>或<code>StringBuffer</code>替换等。</p>
<p>完成对语法树的遍历和调整后，会把填充了所有所需信息的符号表交给<code>com.sun.tools.javac.jvm.ClassWriter.writeClass()</code>来输出为字节码文件。至此编译结束。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/10/jvm6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/10/jvm6/" class="post-title-link" itemprop="url">JVM学习（6）JVM字节码执行引擎</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-10T00:00:00+08:00">2019-09-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-12 17:11:08" itemprop="dateModified" datetime="2019-09-12T17:11:08+08:00">2019-09-12</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于JVM规范本身就是个虚拟概念，因此JVM执行引擎也是个标准，具体实现时会有优化，但要保证执行语义符合规范：即从外观（facade）上看，所有JVM虚拟机的执行引擎都是一致的。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧（stack frame）是用于支持JVM进行方法调用和方法执行的数据结构，是运行时数据区中虚拟机栈（virtual machine stack）的栈数据，栈帧保存了方法的局部变量表、操作数栈、动态连接、方法返回地址等信息。之前提到方法表Code属性，里面有栈帧大小的限制，因此一个栈帧占用内存大小在编译期就决定了，具体占多大内存取决于JVM实现。</p>
<p><img src="/images/jvm_stack_frame.png" alt="栈帧结构"></p>
<p>对于某个线程而言，只有栈顶的栈帧是有效的（称为当前栈帧<code>current stack frame</code>），与其相关联的方法称为当前方法<code>current method</code>，所有字节码指令都只针对当前栈帧操作。</p>
<p>与大多数物理机使用基于寄存器的指令框架不同，JVM使用的是基于栈的架构，比如两个数相加需要先把两个数入栈，然后<code>iadd</code>指令把栈顶两个数拿出来相加再入栈，而寄存器就没这么麻烦。一般来说基于栈的指令集会慢一些，好处是可移植，比如上图中的各个区域的大小都可以随便调整（相对的，同一物理机的每个寄存器的特性都不太一样，不同物理机可能寄存器数目都不一样），所以JVM实际执行的时候会对这些指令进行优化。</p>
<h3 id="局部变量表（local-variable-table）"><a href="#局部变量表（local-variable-table）" class="headerlink" title="局部变量表（local variable table）"></a>局部变量表（local variable table）</h3><p>用于存放方法参数和方法内部定义的局部变量，方法的Code属性的<code>max_locals</code>数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表的基本单位是slot，规范没有指明一个slot有多大，只是说每个slot都可以存放一个<code>boolean, byte, char, shot, int, float, reference, returnAddress</code>类型，那么具体实现的时候，一个slot可以用32位，也可以用64位来存。其中，JVM没有指定<code>reference</code>长度一定要多少，甚至可以不是指针，但要求它能做到：</p>
<ul>
<li>从这个引用可以直接或间接地查找到对象在java堆中的数据存放的起始地址索引</li>
<li>从这个引用可以直接或间接地查找到对象所属数据类型在方法区中存储的类型信息（RTTI）</li>
</ul>
<p><code>returnAddress</code>现在用的比较少，较早的JVM使用这条指令实现异常处理，现在由异常表代替。</p>
<p><code>long</code>和<code>double</code>要求是64位，因此一般会占两个slot。对局部变量表的索引从0开始，以slot为单位，如果遇到连在一起的slot却分开用时应该抛出异常。JVM通过局部变量表来实现参数传递的，如果方法不是静态方法，那么会先把<code>this</code>传为第0号局部变量，之后的参数顺序写入。参数分配完后再根据方法体内部定义的变量顺序和作用域分配其余slot。</p>
<p>可以通过重复利用slot来节省栈帧空间，比如当前字节码PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的slot就可以交给其他变量使用。更进一步，如果之前的变量所在的slot被复写了，那么它所指的object就可以被回收，相反如果没被复写，即使超出了它的作用域也不一定会被及时回收。一个技巧是可以及时为变量赋值为<code>null</code>来加快GC。</p>
<p>最后，java不会为局部变量预设初始值，因此开发人员必须手动为局部变量设初值，否则编译不过，也通不过JVM字节码校验。</p>
<h3 id="操作数栈（operand-stack）"><a href="#操作数栈（operand-stack）" class="headerlink" title="操作数栈（operand stack）"></a>操作数栈（operand stack）</h3><p>用于进行具体运算，方法的Code属性的<code>max_stack</code>定义了操作数栈的最大深度，且单位也是slot。方法开始执行的时候操作数栈为空，随着方法运行会有各种入栈出栈操作，且操作数栈中的数据类型必须和字节码指令的序列严格匹配，不过这个是在编译期和校验期做的。</p>
<p>另外，理论上栈帧之间是完全独立的，实际上可以做一些优化，让两个栈帧部分重叠，这样就避免了额外的参数传递。</p>
<p><img src="/images/jvm_stack_share_vars.png" alt="两个栈帧之间数据共享"></p>
<h3 id="动态连接（dynamic-linking）"><a href="#动态连接（dynamic-linking）" class="headerlink" title="动态连接（dynamic linking）"></a>动态连接（dynamic linking）</h3><p>每个栈帧都包含一个指向常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态调用（dynamic linking）。C++是通过虚函数表来实现多态的，而JAVA则是通过先查找所属类、再解析符号引用/函数表来确定调用哪个方法。</p>
<h3 id="方法返回地址（Normal-Abrupt-Method-Invocation-Completion）"><a href="#方法返回地址（Normal-Abrupt-Method-Invocation-Completion）" class="headerlink" title="方法返回地址（Normal/Abrupt Method Invocation Completion）"></a>方法返回地址（Normal/Abrupt Method Invocation Completion）</h3><p>方法返回分为两种，一种是正常遇到返回指令结束方法调用，另一种是抛出异常且没有被正确处理（此时没有返回值）。无论如何退出，都需要在栈帧中保存一些信息，以便返回值上层调用位置。</p>
<p>方法退出时需要将栈帧出栈，需要恢复上层方法的局部变量表和操作数栈，将返回值（如果有）压入上层的操作数栈，调整PC计数器的值以指向方法调用指令后的一条指令等。</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>JVM允许添加一些附加信息到栈帧（比如调试信息），取决于JVM具体实现。一般把动态连接、方法返回地址和其他附加信息全部归位一类，称为栈帧信息。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用在方法执行之前，目的是找到应当调用哪个方法。由于class文件没有类似C的连接步骤，一切方法调用都是符号引用，因此需要先将符号引用解析为直接引用，而实际上可能需要在类加载期间、甚至在运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析（resolution）"><a href="#解析（resolution）" class="headerlink" title="解析（resolution）"></a>解析（resolution）</h3><p>首先，JVM提供了5中调用字节码的指令，分别是：</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用实例构造器<code>&lt;init&gt;</code>、私有方法、父类方法</li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法</li>
</ul>
<p>在之前的章节提到过，类加载过程中有解析的步骤，其中会把一部分符号引用转换为直接引用，而能够转换的前提是在执行前就能确定是哪个方法，且在运行中不可变。符合这一条件的方法有：静态方法、私有方法、实例构造器、父类方法、final方法这几种。关于final方法，可以参考<a href="https://juejin.im/entry/58c4811161ff4b005d94fed2" target="_blank" rel="noopener">Final of Java，这一篇差不多了</a>，简单来说即final方法还是用<code>invokevirtual</code>调用，但可以在编译期确定，且可以被内联。</p>
<h3 id="分派（dispatch）"><a href="#分派（dispatch）" class="headerlink" title="分派（dispatch）"></a>分派（dispatch）</h3><p>解析调用可以在编译阶段唯一确定，而分派调用则可以是静态的或动态的，且根据宗量（argument，个人理解是方法签名）可以分为单分派和多分派，两两组合可以分为静态单分派、静态多分派、动态单分派、动态多分派。</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>编译期根据调用时的类型来确定使用哪个签名，值得注意的地方有两点：</p>
<ol>
<li>是编译器“看到”的参数类型，而不是实际类型。比如<code>foo((A)B)</code>和<code>foo(B)</code>可能调用了两个完全不同的方法。这个类型称为静态类型（static type）或外观类型（apparent type）</li>
<li>如果没有严格匹配的方法，那么编译器会尝试类型转换，选择一个更为“合适”的方法，比如对于<code>foo(char)</code>、<code>foo(int)</code>、<code>foo(Character)</code>、<code>foo(char...)</code>这几个方法时，如果输入参数是<code>&#39;a&#39;</code>，那么调用优先级依次降低。</li>
</ol>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>在运行期根据实际类型确定方法执行版本的分派过程称为动态分派，Java的动态分派主要通过<code>invokevirtual</code>指令来实现，这个指令运行时解析过程大致分为以下几步：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C</li>
<li>从这个类开始，按照继承关系从下到上查找匹配的方法，如果找到则进行权限校验，通过则返回这个方法的直接引用，否则抛出<code>java.lang.illegalAccessError</code></li>
<li>如果一直没找到，则抛出<code>java.lang.AbstractMethodError</code></li>
</ol>
<h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><p>简单来说就是根据一个参数还是多个参数来进行分派（包括<code>this</code>）。事实上，java只支持静态多分派和动态单分派，即的动态分派只根据<code>this</code>来选择方法版本。C# 4.0后通过<code>dynamic</code>关键字可以支持动态多分配，参考<a href="https://chodounsky.net/2014/01/29/dynamic-dispatch-in-c-number/" target="_blank" rel="noopener">Dynamic Dispatch in C#</a>，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface IBar &#123;&#125;</span><br><span class="line">public class Bar : IBar &#123;&#125;</span><br><span class="line">public sealed class FooBar : Bar &#123;&#125;</span><br><span class="line"></span><br><span class="line">// Simple helper for demonstration</span><br><span class="line">public static class ConsolePrinter</span><br><span class="line">&#123;</span><br><span class="line">    public static void Print(IBar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;IBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Print(Bar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;Bar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Print(FooBar item)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;FooBar&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new Bar();</span><br><span class="line">var foo = new FooBar();</span><br><span class="line">IBar ibar = new FooBar();</span><br><span class="line"></span><br><span class="line">IBar[] items = &#123; bar, foo, ibar &#125;;</span><br></pre></td></tr></table></figure>

<p>定义了三个不同的实例，放到同一个数组里，那么执行的结果应当是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach (var item in items)</span><br><span class="line">&#123;</span><br><span class="line">    ConsolePrinter.Print(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints IBar</span><br><span class="line">// prints IBar</span><br><span class="line">// prints IBar</span><br></pre></td></tr></table></figure>

<p>而如果在foreach循环中用dynamic来解释，结果就不同了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach (dynamic item in items)</span><br><span class="line">&#123;</span><br><span class="line">    ConsolePrinter.Print(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// prints Bar</span><br><span class="line">// prints FooBar</span><br><span class="line">// prints FooBar</span><br></pre></td></tr></table></figure>

<p>这意味着C#中会在运行时解析dynamic类型，拿到具体的对应类型后再决定方法签名，也就实现了动态多分派（虽然这个例子只有一个参数，还是单分配）</p>
<h4 id="动态分派的实现"><a href="#动态分派的实现" class="headerlink" title="动态分派的实现"></a>动态分派的实现</h4><p>理论上可以在运行时解析方法的符号链接，不过一般在实现中会用虚方法表（virtual method table, vtable，类似在<code>invokeinterface</code>时会用到interface method table, itable），如下图所示：</p>
<p><img src="/images/jvm_vtable.jpg" alt="JVM 虚方法表"></p>
<p>每个类维护了一个虚表，如果没有重写某个方法，就和父类的入口地址保持一致，这些可以在载入时实现。</p>
<h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>动态类型语言的关键特征是，它的类型检查的主体过程在运行期而非编译期。JVM中<code>invokespecial、invokevirtual、invokeinterface、invokestatic</code>的“参数”实际上都包含了“哪个类中的哪个方法”这一信息。比如<code>foo.bar()</code>这个调用，如果<code>foo</code>所声明的类型没有实现<code>bar()</code>方法，那么就无法编译通过；而在动态类型语言中，甚至可以不要求<code>bar()</code>被定义过都有可能正常执行，即使<code>foo</code>确实没定义过这个方法、也没有相关的语法糖，只要没执行到这条语句也不会报错。</p>
<p>JDK1.7后引入了<code>invokedynamic</code>指令和<code>java.lang.invoke</code>包，用以实现动态调用，而在JDK1.8里引入的lambda表达式使用了<code>invokedynamic</code>，具体可以参考<a href="https://colobu.com/2014/11/06/secrets-of-java-8-lambda/" target="_blank" rel="noopener">Java 8 Lambda 揭秘</a>和<a href="https://my.oschina.net/haogrgr/blog/367391" target="_blank" rel="noopener">JDK8中Lambda表达式底层实现浅析(一)</a>。在学习<code>invokedynamic</code>之前，需要先了解<code>MethodHandle</code>。</p>
<h4 id="MethodHandle"><a href="#MethodHandle" class="headerlink" title="MethodHandle"></a>MethodHandle</h4><p>简单来说<code>MethodHandle</code>有点像C/C++的函数指针，在此之前java为了实现函数指针需要用<code>interface</code>，而使用<code>interface</code>时需要先实例化一个类再调用这个类的某个方法，<code>MethodHandle</code>相对来说会“轻量级”一些，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"foo1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"foo2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? <span class="keyword">new</span> Foo1() : <span class="keyword">new</span> Foo2();</span><br><span class="line">    getPrintlnMH(obj).invokeExact();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">    <span class="keyword">return</span> MethodHandles.lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodHandles.lookup().findVirtual()</code>用以查找在指定类中符合给定方法签名且符合调用权限的方法句柄，并且由于这个方法不是静态方法，需要绑定<code>this</code>，所以要把<code>reveiver</code>传给<code>bindTo()</code>。</p>
<p>可以看到Foo1和Foo2之间没有继承关系，也可以通过方法签名找到并调用指定方法：这和反射有些相似，但反射（reflection）和MethodHandle实际区别很大：</p>
<ol>
<li>反射是在模拟java代码层次的方法调用，而MethodHandle是在模拟字节码层次的调用，比如<code>MethodHandles.lookup()</code>中的<code>findStatic()、findVirtual()、findSpecial()</code>分别对应字节码<code>invokestatic、invokevirtual&amp;invokeinterface、invokespecial</code>这几个字节码指令的执行权限调用行为，这在使用反射时不需要关心</li>
<li>反射中的<code>java.lang.reflect.Method</code>对象远比<code>MethodHandle</code>机制中的<code>java.lang.invoke.MethodHandle</code>对象所含的信息多，前者是方法在java一端的全面映像，包含了方法的签名、描述符、方法属性表中的各种属性的java端表示方式、执行权限等信息，而后者只包含与执行该方法相关的信息。</li>
<li>原则上由于<code>MethodHandle</code>是字节码调用的模拟，理论上可以在这方面做一些优化。</li>
<li>反射API设计目标是为java语言服务的，而<code>MethodHandle</code>则设计为可以为所有JVM支持的语言服务。</li>
</ol>
<h4 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h4><p>某种程度上<code>invokedynamic</code>和<code>MethodHandle</code>的目标类似，都是为了解决<code>invoke*</code>的分派规则由JVM决定的问题，让开发者有更高的查找目标方法的自由度。JDK1.8实现lambda表达式时使用了<code>invokedynamic</code>，下面是一段代码和它对应的反编译数据，生成的.class在<a href="/files/HelloWorld.class">这里</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">    Runnable r = ()-&gt; System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   <span class="comment">#1 = Methodref          #8.#27         // java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">   <span class="comment">#2 = InvokeDynamic      #0:#32         // #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">   <span class="comment">#3 = InterfaceMethodref #33.#34        // java/lang/Runnable.run:()V</span></span><br><span class="line">   <span class="comment">#4 = Fieldref           #35.#36        // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   <span class="comment">#5 = String             #37            // hello</span></span><br><span class="line">   <span class="comment">#6 = Methodref          #38.#39        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   <span class="comment">#7 = Class              #40            // HelloWorld</span></span><br><span class="line">   <span class="comment">#8 = Class              #41            // java/lang/Object</span></span><br><span class="line">   <span class="comment">#9 = Utf8               &lt;init&gt;</span></span><br><span class="line">  <span class="comment">#10 = Utf8               ()V</span></span><br><span class="line">  <span class="comment">#11 = Utf8               Code</span></span><br><span class="line">  <span class="comment">#12 = Utf8               LineNumberTable</span></span><br><span class="line">  <span class="comment">#13 = Utf8               LocalVariableTable</span></span><br><span class="line">  <span class="comment">#14 = Utf8               this</span></span><br><span class="line">  <span class="comment">#15 = Utf8               LHelloWorld;</span></span><br><span class="line">  <span class="comment">#16 = Utf8               main</span></span><br><span class="line">  <span class="comment">#17 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#18 = Utf8               args</span></span><br><span class="line">  <span class="comment">#19 = Utf8               [Ljava/lang/String;</span></span><br><span class="line">  <span class="comment">#20 = Utf8               r</span></span><br><span class="line">  <span class="comment">#21 = Utf8               Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#22 = Utf8               Exceptions</span></span><br><span class="line">  <span class="comment">#23 = Class              #42            // java/lang/Throwable</span></span><br><span class="line">  <span class="comment">#24 = Utf8               lambda$main$0</span></span><br><span class="line">  <span class="comment">#25 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#26 = Utf8               HelloWorld.java</span></span><br><span class="line">  <span class="comment">#27 = NameAndType        #9:#10         // "&lt;init&gt;":()V</span></span><br><span class="line">  <span class="comment">#28 = Utf8               BootstrapMethods</span></span><br><span class="line">  <span class="comment">#29 = MethodHandle       #6:#43         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#30 = MethodType         #10            //  ()V</span></span><br><span class="line">  <span class="comment">#31 = MethodHandle       #6:#44         // invokestatic HelloWorld.lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#32 = NameAndType        #45:#46        // run:()Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#33 = Class              #47            // java/lang/Runnable</span></span><br><span class="line">  <span class="comment">#34 = NameAndType        #45:#10        // run:()V</span></span><br><span class="line">  <span class="comment">#35 = Class              #48            // java/lang/System</span></span><br><span class="line">  <span class="comment">#36 = NameAndType        #49:#50        // out:Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#37 = Utf8               hello</span></span><br><span class="line">  <span class="comment">#38 = Class              #51            // java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#39 = NameAndType        #52:#53        // println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#40 = Utf8               HelloWorld</span></span><br><span class="line">  <span class="comment">#41 = Utf8               java/lang/Object</span></span><br><span class="line">  <span class="comment">#42 = Utf8               java/lang/Throwable</span></span><br><span class="line">  <span class="comment">#43 = Methodref          #54.#55        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#44 = Methodref          #7.#56         // HelloWorld.lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#45 = Utf8               run</span></span><br><span class="line">  <span class="comment">#46 = Utf8               ()Ljava/lang/Runnable;</span></span><br><span class="line">  <span class="comment">#47 = Utf8               java/lang/Runnable</span></span><br><span class="line">  <span class="comment">#48 = Utf8               java/lang/System</span></span><br><span class="line">  <span class="comment">#49 = Utf8               out</span></span><br><span class="line">  <span class="comment">#50 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#51 = Utf8               java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#52 = Utf8               println</span></span><br><span class="line">  <span class="comment">#53 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#54 = Class              #57            // java/lang/invoke/LambdaMetafactory</span></span><br><span class="line">  <span class="comment">#55 = NameAndType        #58:#62        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#56 = NameAndType        #24:#10        // lambda$main$0:()V</span></span><br><span class="line">  <span class="comment">#57 = Utf8               java/lang/invoke/LambdaMetafactory</span></span><br><span class="line">  <span class="comment">#58 = Utf8               metafactory</span></span><br><span class="line">  <span class="comment">#59 = Class              #64            // java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  <span class="comment">#60 = Utf8               Lookup</span></span><br><span class="line">  <span class="comment">#61 = Utf8               InnerClasses</span></span><br><span class="line">  <span class="comment">#62 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">  <span class="comment">#63 = Class              #65            // java/lang/invoke/MethodHandles</span></span><br><span class="line">  <span class="comment">#64 = Utf8               java/lang/invoke/MethodHandles$Lookup</span></span><br><span class="line">  <span class="comment">#65 = Utf8               java/lang/invoke/MethodHandles</span></span><br><span class="line">&#123;</span><br><span class="line">  public HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LHelloWorld;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]) throws java.lang.Throwable;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: invokedynamic <span class="comment">#2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">         5: astore_1</span><br><span class="line">         6: aload_1</span><br><span class="line">         7: invokeinterface <span class="comment">#3,  1            // InterfaceMethod java/lang/Runnable.run:()V</span></span><br><span class="line">        12: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 6</span><br><span class="line">        line 5: 12</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      13     0  args   [Ljava/lang/String;</span><br><span class="line">            6       7     1     r   Ljava/lang/Runnable;</span><br><span class="line">    Exceptions:</span><br><span class="line">      throws java.lang.Throwable</span><br><span class="line"></span><br><span class="line">  private static void lambda<span class="variable">$main</span><span class="variable">$0</span>();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line">         0: getstatic     <span class="comment">#4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         3: ldc           <span class="comment">#5                  // String hello</span></span><br><span class="line">         5: invokevirtual <span class="comment">#6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"HelloWorld.java"</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     public static final <span class="comment">#60= #59 of #63; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span></span><br><span class="line">BootstrapMethods:</span><br><span class="line">  0: <span class="comment">#29 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span></span><br><span class="line">    Method arguments:</span><br><span class="line">      <span class="comment">#30 ()V</span></span><br><span class="line">      <span class="comment">#31 invokestatic HelloWorld.lambda$main$0:()V</span></span><br><span class="line">      <span class="comment">#30 ()V</span></span><br></pre></td></tr></table></figure>

<p><code>invokedynamic</code>的操作形式是<code>invokedynamic indexbyte1 indexbyte2 0 0</code>，其中后两个0是写死的以便之后扩展，前两个参数联合起来<code>(indexbyte1 &lt;&lt; 8) | indexbyte2</code>指向常量池中的一项被称为动态调用点（call site）的符号引用，这里为字节码为<code>ba 0002 00 00</code>，即CallSite为第二个常量，其结构体声明为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_InvokeDynamic_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 bootstrap_method_attr_index;</span><br><span class="line">    u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>bootstrap_method_attr_index</code>指向了<code>bootstrap_methods</code>数组中的某个<code>bootstrap method</code>，从反编译出的信息可以看到这个<code>invokedynamic</code>的字节码指令为<code>12 0000 0020</code>，标明它的引导方法是第0个，方法类型参考第32个常量<code>run:()Ljava/lang/Runnable;</code>。引导方法<code>Bootstrap Method</code>被保存在新增的<code>BootstrapMethods</code>属性中，其完整定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BootstrapMethods_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 num_bootstrap_methods;</span><br><span class="line">    &#123;   u2 bootstrap_method_ref;</span><br><span class="line">        u2 num_bootstrap_arguments;</span><br><span class="line">        u2 bootstrap_arguments[num_bootstrap_arguments];</span><br><span class="line">    &#125; bootstrap_methods[num_bootstrap_methods];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里相关的二进制代码为<code>1c 00 00 00 0c 00 01 00 1d 00 03 00 1e 00 1f 00 1e</code>，表示只有一个引导方法，对应的<code>MethodHandle</code>为<code>java/lang/invoke/LambdaMetafactory.metafactory</code>这一静态方法，其完整签名为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">metafactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MethodHandles.Lookup caller, // 代表查找上下文与调用者的访问权限, 使用invokedynamic指令时, JVM会自动自动填充这个参数, 这里JVM为我们填充为Lookup(HelloWorld.class, (PUBLIC | PRIVATE | PROTECTED | PACKAGE)</span>) 意思是这个Lookup实例可以访问HelloWorld类的所有成员.</span></span><br><span class="line"><span class="function">    String invokedName,  <span class="comment">//  要实现的方法的名字, 使用invokedynamic时, JVM自动帮我们填充(填充内容来自常量池InvokeDynamic.NameAndType.Name), 这里填充为run</span></span></span><br><span class="line"><span class="function">    MethodType invokedType,  <span class="comment">// 调用点期望的方法参数的类型和返回值的类型(方法signature). 使用invokedynamic指令时, JVM会自动自动填充这个参数，填充内容来自常量池InvokeDynamic.NameAndType.Type), 在这里参数为空, 返回值类型为java/lang/Runnable, 表示这个调用点的目标方法的参数为空, 然后invokedynamic执行完后会返回一个Runnable实例</span></span></span><br><span class="line"><span class="function">    MethodType samMethodType,  <span class="comment">// 函数对象将要实现的接口方法类型, 这里运行时, 值为()V，即Runnable.run()方法的类型</span></span></span><br><span class="line"><span class="function">    MethodHandle implMethod, <span class="comment">// 一个直接方法句柄(DirectMethodHandle), 描述在调用时将被执行的具体实现方法 (包含适当的参数适配, 返回类型适配,和在调用参数前附加上捕获的参数), 在这里为 HelloWorld.lambda$main$0:()V 方法的方法句柄. </span></span></span><br><span class="line"><span class="function">    MethodType instantiatedMethodType) <span class="comment">// 函数接口方法替换泛型为具体类型后的方法类型, 通常和samMethodType一样，除非发生了类型擦除</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> LambdaConversionException</span></span><br></pre></td></tr></table></figure>

<p>在执行<code>invokedynamic</code>时会执行其关联的引导方法，前三个参数由JVM自动填充，后三个参数来自属性表中的<code>bootstrap_arguments</code>。可以看到，lambda表达式的具体实现被编译成了<code>HelloWorld.lambda$main$0:()V</code>这样一个静态方法。执行完引导方法后，会返回一个<code>CallSite</code>对象，它的<code>target</code>属性关联了所调用的方法句柄，最后执行这个方法句柄。</p>
<p>值得一提的是，lambda表达式只是在“生成”的时候调用了<code>invokedynamic</code>，比如上面那个例子，即使没有<code>r.run();</code>这句，也会产生一条<code>invokedynamic</code>指令，换句话说实际上这里<code>invokedynamic</code>产生了一个<code>Runnable</code>对象，然后把它赋值到了一个局部变量。</p>
<h2 id="基于栈的字节码解释引擎"><a href="#基于栈的字节码解释引擎" class="headerlink" title="基于栈的字节码解释引擎"></a>基于栈的字节码解释引擎</h2><p>这段内容其实没啥好说的，举个例子，比如这样一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">4</span>;</span><br><span class="line">c = (a-c)*b;</span><br></pre></td></tr></table></figure>

<p>会翻译为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_1</span><br><span class="line">1: istore_1</span><br><span class="line">2: iconst_2</span><br><span class="line">3: istore_2</span><br><span class="line">4: iconst_4</span><br><span class="line">5: istore_3</span><br><span class="line">6: iload_1</span><br><span class="line">7: iload_3</span><br><span class="line">8: isub</span><br><span class="line">9: iload_2</span><br><span class="line">10: imul</span><br><span class="line">11: istore_3</span><br></pre></td></tr></table></figure>

<p>意思是把常量1入栈，出栈后保存到局部变量1；常量2入栈，出栈后保存到局部变量2；常量4入栈，出栈后保存到局部变量3；局部变量1和3分别入栈，出栈两个int、相减后入栈，将变量2入栈，出栈两个变量、相乘后出栈，此时栈里只有一个int（-6），最后出栈并保存到变量3。</p>
<p>可以看出真的这么跑的化执行效率很低，一般JVM都会对此进行优化。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/06/jvm5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/06/jvm5/" class="post-title-link" itemprop="url">JVM学习（5）类加载机制</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-06T00:00:00+08:00">2019-09-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-09 16:11:25" itemprop="dateModified" datetime="2019-09-09T16:11:25+08:00">2019-09-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有了.class文件后，还需要一系列步骤加载进JVM才能运行。简单来说，一个类从被加载至JVM，到卸载出内存为止，整个生命周期包括加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）、卸载（unloading）7个阶段。其中验证、准备、解析三个部分称为连接（linking），顺序如下图所示。</p>
<p><img src="/images/jvm_class_lifecycle.png" alt="类的生命周期"></p>
<p>JVM没有规定什么时候开始加载，但规定了5种情况必须对类进行初始化：</p>
<ol>
<li>遇到<code>new、getstatic、putstatic、invokestatic</code>这四条指令码。比如new一个对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法的时候。</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时</li>
<li>初始化一个类时，需要先初始化其父类</li>
<li>虚拟机启动时，用户指定的主类需要先被初始化</li>
<li>使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic、REF_putStatic、REF_invokeStatic</code>的方法句柄对应的类需要初始化</li>
</ol>
<p>这五种场景中的行为称为对一个类的主动引用，除此之外的引用类的方式都不会触发初始化，称为被动引用，比如</p>
<ol>
<li>通过子类引用父类的静态字段，不会触发子类的初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化（如<code>SomeClass[] arr= new SomeClass[];</code>）</li>
<li>引用某个类的静态常量</li>
</ol>
<p>其中2虽然不会导致这个类的初始化，但会触发一个<code>[Lorg.fenixsoft.classloading.SomeClass</code>的类初始化，它由JVM自动生成、直接继承自<code>java.lang.Object</code>，由newarray触发，代表了一个元素类型为<code>org.fenixsoft.classloading.SomeClass</code>的一维数组，数组中应有的属性和方法（如<code>length、clone</code>）都实现在这个类。Java中对数组的访问会使用这个类提供的方法（底层使用了<code>xaload、xastore</code>等指令保证不会越界），所以相对<code>C/C++</code>安全。</p>
<p>此外，接口在初始化时不要求父接口全部完成初始化，只有在真正使用父接口的时候（如引用接口中定义的常量）才会初始化。并且接口也会生成<code>&lt;cinit&gt;</code>的类构造器，用于初始化接口中定义的成员变量。</p>
<h2 id="加载（loading）"><a href="#加载（loading）" class="headerlink" title="加载（loading）"></a>加载（loading）</h2><p>加载阶段JVM需要做以下事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>常见的获取二进制字节流的方式有：</p>
<ol>
<li>从.class文件直接获得</li>
<li>从zip包中获得，比如JAR,EAR,WAR</li>
<li>从网络中获得，比如Applet</li>
<li>运行时计算生成，比如动态代理，java.lang.reflect.Proxy就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为”$Proxy”的代理类的二进制字节流</li>
<li>由其他文件生成，比如JSP</li>
<li>从数据库中读取<br>…</li>
</ol>
<p>除了获得字节流的方式外，开发人员还可以自定义个一个ClassLoader去控制如何读取字节流。</p>
<p>数组类比较特殊，它是由JVM直接创建的，一个数组类（简称为C）的创建过程需要遵循以下规则：</p>
<ol>
<li>如果数组的组件类型（Component Type，指数组去掉一个维度后的类型）是引用类型，则递归的加载这个组件类型，之后数组C将在这个组件类型所属的ClassLoader的类命名空间上被标志</li>
<li>如果组件类型不是引用类型，则会标识与Bootstrap Classloader关联。</li>
<li>数组类的可见性与它的组件的可见性保持一致，如果组件类型不是引用类型，则默认为public</li>
</ol>
<p>加载完成后，JVM外部的二进制字节流就按虚拟机所需的格式存储在方法区之中，方法区中的数据格式由JVM自行定义。然后在内存中实例化一个java.lang.Class对象（HotSpot将这个对象放在了方法区），这个对象将作为程序访问方法区中这些类型数据的外部接口。</p>
<h2 id="验证（verification）"><a href="#验证（verification）" class="headerlink" title="验证（verification）"></a>验证（verification）</h2><p>简单来说就是确保这些二进制字节流格式符合JVM规范，且不会对JVM有危害。</p>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>检验其是否符合Class文件规范，且能被当前JVM兼容，包括</p>
<ol>
<li>以<code>0xcafebabe</code>开头</li>
<li>主、次版本号能否被JVM兼容</li>
<li>常量池中的常量是否有不被支持的类型（检查常量tag标志）</li>
<li>指向常量的各种索引值中是否有指向不存在或不符合类型的常量</li>
<li><code>CONSTANT_Utf8_info</code>类型的常量中是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除或附加的其他信息<br>…</li>
</ol>
<p>只有经过文件格式验证后的字节流才会保存到方法区，后面三个验证阶段全部基于方法区的数据，不会直接操作字节流</p>
<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>确保Class数据描述的语义符合java语言规范要求，包括</p>
<ol>
<li>这个类是否有父类（除了<code>java.lang.Object</code>都应该有父类）</li>
<li>这个类是否继承了一个<code>final</code>类</li>
<li>如果这个类不是<code>abstract</code>，那么是否实现了所有父类/接口中要求实现的方法</li>
<li>类中的字段、方法是否与父类矛盾（如覆盖了父类的<code>final</code>字段、不符合规则的方法重载）<br>…</li>
</ol>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>验证操作码，包括</p>
<ol>
<li>确保任意时刻操作数栈的数据类型和指令代码序列都能配合工作，例如不会出现按<code>long</code>去读一个<code>int</code></li>
<li>确保跳转指令不会跳转到方法体以外的字节码上</li>
<li>确保方法体中的类型转换是有效的<br>…</li>
</ol>
<p>JDK1.6后为<code>Code</code>属性的属性表引入了一个<code>StackMapTable</code>属性，描述了方法体中所有基本块开始时本地变量表和操作栈应有的状态，那么验证期间只要检查<code>StackMapTable</code>属性即可，不需要重新推导这部分信息。JDK1.7后要求主版本号超过50的只能用这种形式。</p>
<p>（其实很奇怪，既然要验证就说明不信任代码提供方，那怎么能把一部分验证工作放在代码提供方呢？只能说JVM设计者认为代码提供方都是善意的，但工作做的比较糙，编译出来的东西不靠谱）</p>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>符号引用验证发生在解析之后，目的是检查对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，包括</p>
<ol>
<li>符号引用中的全限定名能否找到对应的类</li>
<li>指定类中有无描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性（<code>private、protected、public、default</code>）是否可以被当前类访问<br>…</li>
</ol>
<p>验证过程可以用<code>-XVerify:none</code>来取消</p>
<h2 id="准备（preparation）"><a href="#准备（preparation）" class="headerlink" title="准备（preparation）"></a>准备（preparation）</h2><p>准备阶段主要用来为类变量（被static修饰）分配内存（一般在方法区）并设置初始值，且初始值为0。比如<code>public static int value = 123;</code>这个变量在准备阶段过后的初始值为0，而在初始化后才被赋值为123。</p>
<p>如果类字段的属性表包含<code>ConstantValue</code>属性，那么准备阶段就会把变量定义为所指定的值。</p>
<h2 id="解析（resolution）"><a href="#解析（resolution）" class="headerlink" title="解析（resolution）"></a>解析（resolution）</h2><p>解析的目的是为了将常量池中的符号引用替换为直接引用的过程，</p>
<ul>
<li>符号引用（Symbolic References）：以一组符号来描述所引用的目标，符合可以是任何形式的字面量，只要在使用时能无歧义的定位到目标即可<ul>
<li>符号引用与JVM实现的内存布局无关</li>
<li>引用的目标不一定已被加载到内存</li>
<li>各种JVM的内存布局可以各不相同，但能接受的符号引用必须都是一致的</li>
</ul>
</li>
<li>直接引用（Direct References）：可以是直接指向目标的指针、相对偏移量或句柄<ul>
<li>与JVM内部实现相关</li>
<li>不同JVM的直接引用形式一般不同</li>
<li>如果有直接引用，那么引用目标一定在内存</li>
</ul>
</li>
</ul>
<p>JVM规范没有规定解析阶段发生的具体时间，只要求在执行<code>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic</code>这16个用于操作符号引用的字节码指令前，先对符号引用进行解析。所以JVM可以选择在加载的时候就解析还是在使用的时候才解析。JVM要求除<code>invokedynamic</code>外，在同一个实体中，如果一个符号引用被成功解析，那么之后也要能够成功解析；如果第一次解析失败，那么之后也应该收到同样的异常。而<code>invokedynamic</code>必须要等到实际执行时再解析，这条指令在JDK1.7中被引入，JDK1.8开始用来实现lambda表达式。</p>
<p>解析主要针对类或接口（CONSTANT_Class_info）、字段（CONSTANT_Fieldref_info）、类方法（CONSTANT_Methodref_info）、接口方法（CONSTANT_InterfaceMethodref_info）、方法类型（CONSTANT_MethodType_info）、方法句柄（CONSTANT_MethodHandle_info）、调用点（CONSTANT_Dynamic_info）这7类符号引用进行，后三种和动态调用相关，这里只解释前4种：</p>
<h3 id="类或接口"><a href="#类或接口" class="headerlink" title="类或接口"></a>类或接口</h3><p>假设当前代码所处的类为D，需要解析一个类或接口C的符号引用N，需要</p>
<ol>
<li>如果C不是一个数组类型，那么JVM会把N传给D的ClassLoader去加载C。</li>
<li>如果C是数组类型，且数组的组建类型是对象，那么会加载其组建类型，然后由JVM生成一个代表此数组维度和元素的数组对象。</li>
<li>在进行了1或2后，C已经在JVM中称为一个有效的类或接口了，然后验证D是否有对C的访问权限，没有则抛出异常</li>
</ol>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>解析字段的符号引用，首先要解析字段表里class_index项索引的<code>CONSTANT_Class_info</code>符号引用，解析成功后，假设这个类/接口是C，</p>
<ol>
<li>如果C本身就包含了包含简单名称和字段描述符都与目标项匹配的字段，则返回这个字段的直接引用</li>
<li>如果C中实现了接口，那么按照继承关系从下往上递归搜索各个接口和它的父接口，如果找到则返回</li>
<li>如果C不是<code>java.lang.Object</code>，那么会从下向上递归搜索其父类，如果找到则返回</li>
<li>都没找到则表示查找失败，返回<code>java.lang.NoSuchFieldError</code></li>
</ol>
<p>如果查找过程中返回了引用，但没有访问权限，也会抛出异常</p>
<p>如果一个同名字段同时出现在父类和子类，那么编译器可能会拒绝编译</p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>与字段解析类似，需要先解析所属的类/接口C，然后</p>
<ol>
<li>如果C是个接口，则报错<code>java.lang.IncompatibleClassChangeError</code></li>
<li>从下往上递归查找C和C的父类，如果找到相匹配的方法则返回</li>
<li>递归查找C的接口，如果找到相匹配的方法，说明C是个抽象类，抛出<code>java.lang.AbstractMethodError</code></li>
<li>查找失败，报错<code>java.lang.NoSuchMethodError</code></li>
</ol>
<p>最后会验证其访问权限</p>
<h3 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h3><p>与类方法解析类似，但需要保证C是个接口</p>
<ol>
<li>如果C不是接口，则报错<code>java.lang.IncompatibleClassChangeError</code></li>
<li>递归查找C和C的父接口，直到<code>java.lang.Object</code>，如果找到则返回</li>
<li>没找到报错<code>java.lang.NoSuchMethodError</code></li>
</ol>
<p>理论上接口方法都是<code>public</code>，所以应当不出现<code>java.lang.IllegalAccessError</code></p>
<h2 id="初始化（initialization）"><a href="#初始化（initialization）" class="headerlink" title="初始化（initialization）"></a>初始化（initialization）</h2><p>直到初始化阶段才开始执行自定义的java代码， 也就是<code>&lt;cinit&gt;()</code>方法</p>
<ol>
<li><code>&lt;cinit&gt;()</code>由所有类变量的赋值动作和静态语句块<code>static{}</code>中的语句合并而成，顺序由源文件顺序而定，且<code>static{}</code>只能访问到定义在之前的变量</li>
<li><code>&lt;cinit&gt;()</code>不需要显式的调用父类的<code>&lt;cinit&gt;()</code>，JVM会保证父类的肯定先执行完毕</li>
<li>如果没有相关代码，可以不生成<code>&lt;cinit&gt;()</code>语句</li>
<li>接口不能使用静态语句块，但也有变量初始化操作，故也会生成<code>&lt;cinit&gt;()</code>，但执行<code>&lt;cinit&gt;()</code>时不需要先执行父类的<code>&lt;cinit&gt;()</code>。同样的，接口的实现类初始化时也不会执行接口的<code>&lt;cinit&gt;()</code></li>
<li>JVM会保证<code>&lt;cinit&gt;()</code>能被正确加锁，这也意味着可能多个线程卡在某个类的<code>&lt;cinit&gt;()</code>上</li>
</ol>
<h2 id="类加载器（ClassLoader）"><a href="#类加载器（ClassLoader）" class="headerlink" title="类加载器（ClassLoader）"></a>类加载器（ClassLoader）</h2><p>从JVM的角度讲，只有两类加载器：一类是使用C++实现的启动类加载器<code>Bootstrap ClassLoader</code>，是JVM的一部分；另一种是其他的类加载器，由JAVA语言实现，独立于JVM，且全继承了<code>java.lang.ClassLoader</code>。</p>
<p>有三个系统提供的类加载器比较常见：</p>
<ol>
<li>启动类加载器（<code>Bootstrap ClassLoader</code>）：负责将<code>$JAVA_HOME/lib</code>中或<code>-Xbootclasspath</code>路径下，能被JVM识别的类库加载到JVM内存中，无法被java程序直接引用。用户自定义<code>ClassLoader</code>时需要需要<code>Bootstrap ClassLoader</code>加载，可以直接用<code>null</code>代替。</li>
<li>扩展类加载器（<code>Extension ClassLoader</code>）：由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>$JAVA_HOME/lib/ext</code>或<code>java.ext.dirs</code>系统变量所指定的路径下的所有类库，开发者也可以直接使用这个类加载器</li>
<li>应用程序加载器（<code>Application ClassLoader</code>）：由<code>sun.misc.Launcher$AppClassLoader</code>实现，负责加载用户类路径<code>ClassPath</code>上所指定的类库，也是<code>getSystemClassLoader()</code>方法的返回值，故一般也称为系统类加载器，开发者可以直接使用，默认的类加载器</li>
</ol>
<p>每一个类加载器都拥有一个独立的类名称空间，也就是说判断两个Class是否相等（包括<code>Class.equals(), isAssignableFrom(), isInstance()</code>的返回值）要判断两个<code>ClassLoader</code>是否相等。</p>
<p>开发人员也可以自定义类加载器，一般来说类加载器都应当有自己的父类加载器，且使用双亲委派模型（<code>Parents Delegation Model</code>）来复用父加载器代码：尽可能尝试让父类加载器去加载这个类。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
