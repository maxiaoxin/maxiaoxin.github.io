<!DOCTYPE html>





<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="读书笔记">
<meta property="og:url" content="https://maxiaoxin.github.io/page/2/index.html">
<meta property="og:site_name" content="读书笔记">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记">
  <link rel="canonical" href="https://maxiaoxin.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>读书笔记</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">读书笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/06/jvm5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/06/jvm5/" class="post-title-link" itemprop="url">JVM学习（5）类加载机制</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-06T00:00:00+08:00">2019-09-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-09 16:11:25" itemprop="dateModified" datetime="2019-09-09T16:11:25+08:00">2019-09-09</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有了.class文件后，还需要一系列步骤加载进JVM才能运行。简单来说，一个类从被加载至JVM，到卸载出内存为止，整个生命周期包括加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）、卸载（unloading）7个阶段。其中验证、准备、解析三个部分称为连接（linking），顺序如下图所示。</p>
<p><img src="/images/jvm_class_lifecycle.png" alt="类的生命周期"></p>
<p>JVM没有规定什么时候开始加载，但规定了5种情况必须对类进行初始化：</p>
<ol>
<li>遇到<code>new、getstatic、putstatic、invokestatic</code>这四条指令码。比如new一个对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法的时候。</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时</li>
<li>初始化一个类时，需要先初始化其父类</li>
<li>虚拟机启动时，用户指定的主类需要先被初始化</li>
<li>使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic、REF_putStatic、REF_invokeStatic</code>的方法句柄对应的类需要初始化</li>
</ol>
<p>这五种场景中的行为称为对一个类的主动引用，除此之外的引用类的方式都不会触发初始化，称为被动引用，比如</p>
<ol>
<li>通过子类引用父类的静态字段，不会触发子类的初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化（如<code>SomeClass[] arr= new SomeClass[];</code>）</li>
<li>引用某个类的静态常量</li>
</ol>
<p>其中2虽然不会导致这个类的初始化，但会触发一个<code>[Lorg.fenixsoft.classloading.SomeClass</code>的类初始化，它由JVM自动生成、直接继承自<code>java.lang.Object</code>，由newarray触发，代表了一个元素类型为<code>org.fenixsoft.classloading.SomeClass</code>的一维数组，数组中应有的属性和方法（如<code>length、clone</code>）都实现在这个类。Java中对数组的访问会使用这个类提供的方法（底层使用了<code>xaload、xastore</code>等指令保证不会越界），所以相对<code>C/C++</code>安全。</p>
<p>此外，接口在初始化时不要求父接口全部完成初始化，只有在真正使用父接口的时候（如引用接口中定义的常量）才会初始化。并且接口也会生成<code>&lt;cinit&gt;</code>的类构造器，用于初始化接口中定义的成员变量。</p>
<h2 id="加载（loading）"><a href="#加载（loading）" class="headerlink" title="加载（loading）"></a>加载（loading）</h2><p>加载阶段JVM需要做以下事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>常见的获取二进制字节流的方式有：</p>
<ol>
<li>从.class文件直接获得</li>
<li>从zip包中获得，比如JAR,EAR,WAR</li>
<li>从网络中获得，比如Applet</li>
<li>运行时计算生成，比如动态代理，java.lang.reflect.Proxy就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为”$Proxy”的代理类的二进制字节流</li>
<li>由其他文件生成，比如JSP</li>
<li>从数据库中读取<br>…</li>
</ol>
<p>除了获得字节流的方式外，开发人员还可以自定义个一个ClassLoader去控制如何读取字节流。</p>
<p>数组类比较特殊，它是由JVM直接创建的，一个数组类（简称为C）的创建过程需要遵循以下规则：</p>
<ol>
<li>如果数组的组件类型（Component Type，指数组去掉一个维度后的类型）是引用类型，则递归的加载这个组件类型，之后数组C将在这个组件类型所属的ClassLoader的类命名空间上被标志</li>
<li>如果组件类型不是引用类型，则会标识与Bootstrap Classloader关联。</li>
<li>数组类的可见性与它的组件的可见性保持一致，如果组件类型不是引用类型，则默认为public</li>
</ol>
<p>加载完成后，JVM外部的二进制字节流就按虚拟机所需的格式存储在方法区之中，方法区中的数据格式由JVM自行定义。然后在内存中实例化一个java.lang.Class对象（HotSpot将这个对象放在了方法区），这个对象将作为程序访问方法区中这些类型数据的外部接口。</p>
<h2 id="验证（verification）"><a href="#验证（verification）" class="headerlink" title="验证（verification）"></a>验证（verification）</h2><p>简单来说就是确保这些二进制字节流格式符合JVM规范，且不会对JVM有危害。</p>
<h3 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h3><p>检验其是否符合Class文件规范，且能被当前JVM兼容，包括</p>
<ol>
<li>以<code>0xcafebabe</code>开头</li>
<li>主、次版本号能否被JVM兼容</li>
<li>常量池中的常量是否有不被支持的类型（检查常量tag标志）</li>
<li>指向常量的各种索引值中是否有指向不存在或不符合类型的常量</li>
<li><code>CONSTANT_Utf8_info</code>类型的常量中是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除或附加的其他信息<br>…</li>
</ol>
<p>只有经过文件格式验证后的字节流才会保存到方法区，后面三个验证阶段全部基于方法区的数据，不会直接操作字节流</p>
<h3 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h3><p>确保Class数据描述的语义符合java语言规范要求，包括</p>
<ol>
<li>这个类是否有父类（除了<code>java.lang.Object</code>都应该有父类）</li>
<li>这个类是否继承了一个<code>final</code>类</li>
<li>如果这个类不是<code>abstract</code>，那么是否实现了所有父类/接口中要求实现的方法</li>
<li>类中的字段、方法是否与父类矛盾（如覆盖了父类的<code>final</code>字段、不符合规则的方法重载）<br>…</li>
</ol>
<h3 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h3><p>验证操作码，包括</p>
<ol>
<li>确保任意时刻操作数栈的数据类型和指令代码序列都能配合工作，例如不会出现按<code>long</code>去读一个<code>int</code></li>
<li>确保跳转指令不会跳转到方法体以外的字节码上</li>
<li>确保方法体中的类型转换是有效的<br>…</li>
</ol>
<p>JDK1.6后为<code>Code</code>属性的属性表引入了一个<code>StackMapTable</code>属性，描述了方法体中所有基本块开始时本地变量表和操作栈应有的状态，那么验证期间只要检查<code>StackMapTable</code>属性即可，不需要重新推导这部分信息。JDK1.7后要求主版本号超过50的只能用这种形式。</p>
<p>（其实很奇怪，既然要验证就说明不信任代码提供方，那怎么能把一部分验证工作放在代码提供方呢？只能说JVM设计者认为代码提供方都是善意的，但工作做的比较糙，编译出来的东西不靠谱）</p>
<h3 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h3><p>符号引用验证发生在解析之后，目的是检查对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，包括</p>
<ol>
<li>符号引用中的全限定名能否找到对应的类</li>
<li>指定类中有无描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性（<code>private、protected、public、default</code>）是否可以被当前类访问<br>…</li>
</ol>
<p>验证过程可以用<code>-XVerify:none</code>来取消</p>
<h2 id="准备（preparation）"><a href="#准备（preparation）" class="headerlink" title="准备（preparation）"></a>准备（preparation）</h2><p>准备阶段主要用来为类变量（被static修饰）分配内存（一般在方法区）并设置初始值，且初始值为0。比如<code>public static int value = 123;</code>这个变量在准备阶段过后的初始值为0，而在初始化后才被赋值为123。</p>
<p>如果类字段的属性表包含<code>ConstantValue</code>属性，那么准备阶段就会把变量定义为所指定的值。</p>
<h2 id="解析（resolution）"><a href="#解析（resolution）" class="headerlink" title="解析（resolution）"></a>解析（resolution）</h2><p>解析的目的是为了将常量池中的符号引用替换为直接引用的过程，</p>
<ul>
<li>符号引用（Symbolic References）：以一组符号来描述所引用的目标，符合可以是任何形式的字面量，只要在使用时能无歧义的定位到目标即可<ul>
<li>符号引用与JVM实现的内存布局无关</li>
<li>引用的目标不一定已被加载到内存</li>
<li>各种JVM的内存布局可以各不相同，但能接受的符号引用必须都是一致的</li>
</ul>
</li>
<li>直接引用（Direct References）：可以是直接指向目标的指针、相对偏移量或句柄<ul>
<li>与JVM内部实现相关</li>
<li>不同JVM的直接引用形式一般不同</li>
<li>如果有直接引用，那么引用目标一定在内存</li>
</ul>
</li>
</ul>
<p>JVM规范没有规定解析阶段发生的具体时间，只要求在执行<code>anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic</code>这16个用于操作符号引用的字节码指令前，先对符号引用进行解析。所以JVM可以选择在加载的时候就解析还是在使用的时候才解析。JVM要求除<code>invokedynamic</code>外，在同一个实体中，如果一个符号引用被成功解析，那么之后也要能够成功解析；如果第一次解析失败，那么之后也应该收到同样的异常。而<code>invokedynamic</code>必须要等到实际执行时再解析，这条指令在JDK1.7中被引入，JDK1.8开始用来实现lambda表达式。</p>
<p>解析主要针对类或接口（CONSTANT_Class_info）、字段（CONSTANT_Fieldref_info）、类方法（CONSTANT_Methodref_info）、接口方法（CONSTANT_InterfaceMethodref_info）、方法类型（CONSTANT_MethodType_info）、方法句柄（CONSTANT_MethodHandle_info）、调用点（CONSTANT_Dynamic_info）这7类符号引用进行，后三种和动态调用相关，这里只解释前4种：</p>
<h3 id="类或接口"><a href="#类或接口" class="headerlink" title="类或接口"></a>类或接口</h3><p>假设当前代码所处的类为D，需要解析一个类或接口C的符号引用N，需要</p>
<ol>
<li>如果C不是一个数组类型，那么JVM会把N传给D的ClassLoader去加载C。</li>
<li>如果C是数组类型，且数组的组建类型是对象，那么会加载其组建类型，然后由JVM生成一个代表此数组维度和元素的数组对象。</li>
<li>在进行了1或2后，C已经在JVM中称为一个有效的类或接口了，然后验证D是否有对C的访问权限，没有则抛出异常</li>
</ol>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>解析字段的符号引用，首先要解析字段表里class_index项索引的<code>CONSTANT_Class_info</code>符号引用，解析成功后，假设这个类/接口是C，</p>
<ol>
<li>如果C本身就包含了包含简单名称和字段描述符都与目标项匹配的字段，则返回这个字段的直接引用</li>
<li>如果C中实现了接口，那么按照继承关系从下往上递归搜索各个接口和它的父接口，如果找到则返回</li>
<li>如果C不是<code>java.lang.Object</code>，那么会从下向上递归搜索其父类，如果找到则返回</li>
<li>都没找到则表示查找失败，返回<code>java.lang.NoSuchFieldError</code></li>
</ol>
<p>如果查找过程中返回了引用，但没有访问权限，也会抛出异常</p>
<p>如果一个同名字段同时出现在父类和子类，那么编译器可能会拒绝编译</p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>与字段解析类似，需要先解析所属的类/接口C，然后</p>
<ol>
<li>如果C是个接口，则报错<code>java.lang.IncompatibleClassChangeError</code></li>
<li>从下往上递归查找C和C的父类，如果找到相匹配的方法则返回</li>
<li>递归查找C的接口，如果找到相匹配的方法，说明C是个抽象类，抛出<code>java.lang.AbstractMethodError</code></li>
<li>查找失败，报错<code>java.lang.NoSuchMethodError</code></li>
</ol>
<p>最后会验证其访问权限</p>
<h3 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h3><p>与类方法解析类似，但需要保证C是个接口</p>
<ol>
<li>如果C不是接口，则报错<code>java.lang.IncompatibleClassChangeError</code></li>
<li>递归查找C和C的父接口，直到<code>java.lang.Object</code>，如果找到则返回</li>
<li>没找到报错<code>java.lang.NoSuchMethodError</code></li>
</ol>
<p>理论上接口方法都是<code>public</code>，所以应当不出现<code>java.lang.IllegalAccessError</code></p>
<h2 id="初始化（initialization）"><a href="#初始化（initialization）" class="headerlink" title="初始化（initialization）"></a>初始化（initialization）</h2><p>直到初始化阶段才开始执行自定义的java代码， 也就是<code>&lt;cinit&gt;()</code>方法</p>
<ol>
<li><code>&lt;cinit&gt;()</code>由所有类变量的赋值动作和静态语句块<code>static{}</code>中的语句合并而成，顺序由源文件顺序而定，且<code>static{}</code>只能访问到定义在之前的变量</li>
<li><code>&lt;cinit&gt;()</code>不需要显式的调用父类的<code>&lt;cinit&gt;()</code>，JVM会保证父类的肯定先执行完毕</li>
<li>如果没有相关代码，可以不生成<code>&lt;cinit&gt;()</code>语句</li>
<li>接口不能使用静态语句块，但也有变量初始化操作，故也会生成<code>&lt;cinit&gt;()</code>，但执行<code>&lt;cinit&gt;()</code>时不需要先执行父类的<code>&lt;cinit&gt;()</code>。同样的，接口的实现类初始化时也不会执行接口的<code>&lt;cinit&gt;()</code></li>
<li>JVM会保证<code>&lt;cinit&gt;()</code>能被正确加锁，这也意味着可能多个线程卡在某个类的<code>&lt;cinit&gt;()</code>上</li>
</ol>
<h2 id="类加载器（ClassLoader）"><a href="#类加载器（ClassLoader）" class="headerlink" title="类加载器（ClassLoader）"></a>类加载器（ClassLoader）</h2><p>从JVM的角度讲，只有两类加载器：一类是使用C++实现的启动类加载器<code>Bootstrap ClassLoader</code>，是JVM的一部分；另一种是其他的类加载器，由JAVA语言实现，独立于JVM，且全继承了<code>java.lang.ClassLoader</code>。</p>
<p>有三个系统提供的类加载器比较常见：</p>
<ol>
<li>启动类加载器（<code>Bootstrap ClassLoader</code>）：负责将<code>$JAVA_HOME/lib</code>中或<code>-Xbootclasspath</code>路径下，能被JVM识别的类库加载到JVM内存中，无法被java程序直接引用。用户自定义<code>ClassLoader</code>时需要需要<code>Bootstrap ClassLoader</code>加载，可以直接用<code>null</code>代替。</li>
<li>扩展类加载器（<code>Extension ClassLoader</code>）：由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>$JAVA_HOME/lib/ext</code>或<code>java.ext.dirs</code>系统变量所指定的路径下的所有类库，开发者也可以直接使用这个类加载器</li>
<li>应用程序加载器（<code>Application ClassLoader</code>）：由<code>sun.misc.Launcher$AppClassLoader</code>实现，负责加载用户类路径<code>ClassPath</code>上所指定的类库，也是<code>getSystemClassLoader()</code>方法的返回值，故一般也称为系统类加载器，开发者可以直接使用，默认的类加载器</li>
</ol>
<p>每一个类加载器都拥有一个独立的类名称空间，也就是说判断两个Class是否相等（包括<code>Class.equals(), isAssignableFrom(), isInstance()</code>的返回值）要判断两个<code>ClassLoader</code>是否相等。</p>
<p>开发人员也可以自定义类加载器，一般来说类加载器都应当有自己的父类加载器，且使用双亲委派模型（<code>Parents Delegation Model</code>）来复用父加载器代码：尽可能尝试让父类加载器去加载这个类。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/09/02/jvm4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/09/02/jvm4/" class="post-title-link" itemprop="url">JVM学习（4）类文件结构</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-09-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-02T00:00:00+08:00">2019-09-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-05 18:24:17" itemprop="dateModified" datetime="2019-09-05T18:24:17+08:00">2019-09-05</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为了实现“Write Once, Run Anywhere”，JVM支持运行.class格式的字节码文件，这样可以保证JVM的平台无关性和语言无关性：即不管什么语言，只要能编译为符合规范的.class文件，就可以在JVM上运行。</p>
<h2 id="class类文件结构"><a href="#class类文件结构" class="headerlink" title="class类文件结构"></a>class类文件结构</h2><p>任何一个class文件都对应着唯一一个类或接口的定义信息。当然一来JVM可以动态生成class，不一定每个类都对应着一个.class文件；二来一个java源代码里可以定义多个类，每个类（包括子类）实际上都会生成一个.class文件。</p>
<p>一个典型的class文件分为：MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes这十个部分：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td align="center">magic</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">minor_version</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">major</td>
<td align="center">_version</td>
</tr>
<tr>
<td>u2</td>
<td align="center">constant_pool_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>cp_info</td>
<td align="center">constant_pool</td>
<td align="center">constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">this_class</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">super_class</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">interfaces_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>u2</td>
<td align="center">interfaces</td>
<td align="center">interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td align="center">fields_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>field_info</td>
<td align="center">fields</td>
<td align="center">fields_count</td>
</tr>
<tr>
<td>u2</td>
<td align="center">methods_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>method_info</td>
<td align="center">methods</td>
<td align="center">methods_count</td>
</tr>
<tr>
<td>u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td>attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<p>其中u1, u2, u4,u8分别表示1、2、4、8字节长度的标量，且以big-endian的方式保存。</p>
<p>不定长的区域，比如constant_pool，method_info等，基本都是count+info[count]这种形式。</p>
<p>先写一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> hello1;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHello1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hello1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Child</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3911120229867216339L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> hello2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHello2</span><span class="params">(<span class="keyword">int</span> hello2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hello2 = hello2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hello2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Child o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.hello2 - o.hello2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这段代码编译后生成两个class文件，这里只分析<a href="/files/Child.class">Child.class</a>。可以先用<code>javap -v -p -s -sysinfo -constants Child</code>看一下基本框架。然后依次分析每个区域。</p>
<h2 id="Magic-Numbers和版本号"><a href="#Magic-Numbers和版本号" class="headerlink" title="Magic Numbers和版本号"></a>Magic Numbers和版本号</h2><p>魔数，.class文件必须以0xcafebabe开头，这个跟.jpeg之类的文件类似。</p>
<p>接下来4个字节是版本号，其中后两个字节是主版本号，这里是0x0031，对应JDK1.5.0_11版本。一般高版本的JVM兼容低版本的.class文件，但反过来不行。</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>接下来是常量池（constant pool）部分，2字节的数字表示一共有多少个常量，接下来一共有constant_pool_count-1个实际常量。这里一共有0x002a-1=42-1=41个常量。且常量池索引以1开始，0被用来表示“不引用任何一个常量池项目”。</p>
<p>常量池主要包含两部分：字面量（literal）和符号引用（symbolic references）。字面量比如文本字符串、声明为final的常量值等。符号引用包含三部分：</p>
<ul>
<li>类和接口的全限定名（full qualified name）</li>
<li>字段的名称和描述符（descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>每个常量以1字节的类型描述开始，然后按这个类型定义的表去填充数据，具体参考<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">The class File Format</a>。以刚才编译好的.class文件为例，跳过重复的类型，大概有以下几个部分：</p>
<ul>
<li>第1个常量是<code>0a 0006 0023</code>，对应CONSTANT_Methodref_info，两个index分别指向第6和第35个常量，表明这个方法在第6个常量表示的类（Base），具体的名称和描述符参考第35个常量（<code>&quot;&lt;init&gt;&quot;:()V</code>）</li>
<li>第2个常量是<code>09 0004 0024</code>，对应CONSTANT_Fieldref_info，与CONSTANT_Methodref_info类似，表明这个字段在第4个常量表示的类（Child），具体的名称和描述符参考第36个常量（<code>hello2:I</code>）</li>
<li>第4个常量是<code>07 0026</code>，对应CONSTANT_Class_info，这个类的名称指向第38个常量，这个常量是个字符串，值为<code>Child</code></li>
<li>第8个常量是<code>01 0010 73657269616c56657273696f6e554944</code>，对应CONSTANT_Utf8_info，是一个utf8字符串，此字符串长为16（32字节），用python3的<code>bytes.fromhex(&quot;73657269616c56657273696f6e554944&quot;)</code>解码得到字符串是<code>serialVersionUID</code></li>
<li>第11个常量是<code>05 c9b8e8df78eba22d</code>，对应CONSTANT_Long_info，是一个long型常量，对应十进制数字为<code>-3911120229867216339</code></li>
<li>第35个常量是<code>0c 000f 0010</code>，对应CONSTANT_NameAndType_info，表示它的名字为第15个常量（<code>&lt;init&gt;</code>），类型为第16个常量<code>()V</code></li>
</ul>
<p>总的来说常量池还是以字符串、数字为主。</p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池结束后是两个字节的访问标志，用以声明这个类/接口/注解…的访问类型。这个类是0x0021，为<code>ACC_PUBLIC|ACC_SUPER</code>，ACC_PUBLIC容易理解，即这个类声明为public的；而ACC_SUPER主要是为了向下兼容，因为invokespecial这个指令的语义在JDK1.0.2发生过变化（可以参考<a href="https://blog.csdn.net/xinaij/article/details/38872851" target="_blank" rel="noopener">ACC_SUPER和早期的invokespecial</a>），那么新版JDK编译出来的类都需要带上这个flag。</p>
<h2 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h2><p>还是指向常量池的信息，这里类是第4个常量（Child类），父类是第6个常量（Base类）。由于所有java class都至少有个一个基类Object，故父类索引一定不为0。</p>
<p>这个类的接口集合大小为1，之后是一系列2字节的常量索引（长度为1），可以看到Child类继承了7号常量描述的接口（java/lang/Comparable）。</p>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>相比于接口，字段包含的信息比较多，除了名字和类型外，还包含诸如是否被static、final、public、volatile等修饰符修饰等信息。因此一个字段被定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">  u2 access_flags;</span><br><span class="line">  u2 name_index;</span><br><span class="line">  u2 descriptor_index;</span><br><span class="line">  u2 attributes_count;</span><br><span class="line">  attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里一共有2个字段，第一个字段为<code>001A 0008 0009 0001 000A 00000002 000B</code>，被声明为<code>0x1A=ACC_PRIVATE|ACC_STATIC|ACC_FINAL</code>，名称为第8个常量（字符串<code>serialVersionUID</code>），描述符为第9个常量（字符串<code>J</code>，表示基本类型long）。</p>
<p>所谓描述符(descriptor)是描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）和返回值。基本类型和void都用一个大写字母表示，而对象用L+对象的全限定名来表示，比如<code>Ljava/lang/Object;</code>（一般全限定名后加个分号以示区分）。数组则是加个<code>[</code>，比如<code>[[Ljava/lang/String;</code>表示<code>String[][]</code>这样的二位数组，<code>[I</code>表示<code>int[]</code>这样的int数组。描述方法时，先写参数列表，后写返回值。例如方法<code>int indexOf(char[] source, int sourceOffset, char[] target, int targetOffset, int targetCount, int from Index)</code>的描述符为<code>([CII[CIII]])I</code>。</p>
<p>最后，这个字段包含1个属性（attribute），属性用来保存一些额外信息，每个attribute_info被定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个字段有一个attribute_info，name为第10个常量<code>ConstantValue</code>，其内容长为2字节，但需要联合起来表示指向第11个常量(一个long型的数字-3911120229867216339l)。</p>
<p>第二个字段为<code>0082 000D 000E 0000</code>，被声明为<code>0x82=ACC_PRIVATE|ACC_TRANSIENT</code>，名称为第13个常量<code>hello2</code>，描述符为第14个常量<code>I</code>，没有额外属性。</p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>方法表和字段表结构很类似，不过由于字段和方法的访问标志不太一样，所以实际含义不太一样。此外方法表一般会有一个属性指向Code类型，需要参考属性集合表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">     u2 access_flags;</span><br><span class="line">     u2 name_index;</span><br><span class="line">     u2 descriptor_index;</span><br><span class="line">     u2 attributes_count;</span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Child里有6个方法，如下表所示，其中bridge表示这个方法是桥接方法，synthetic表示这个方法由编译器生成。</p>
<table>
<thead>
<tr>
<th>二进制码</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>0001 000f 0010 0001 0011 0000002f...</code></td>
<td><code>public &lt;init&gt; ()V</code></td>
</tr>
<tr>
<td><code>0001 0016 0017 0001 0011 0000003e...</code></td>
<td><code>public setHello2 (I)V</code></td>
</tr>
<tr>
<td><code>0001 0018 0019 0001 0011 0000002f...</code></td>
<td><code>public getHello2 ()I</code></td>
</tr>
<tr>
<td><code>0001 001a 001b 0001 0011 0000003e...</code></td>
<td><code>public compareTo (LChild;)I</code></td>
</tr>
<tr>
<td><code>1041 001d 0019 0001 0011 0000002f...</code></td>
<td><code>public bridge synthetic getHello1 ()I</code></td>
</tr>
<tr>
<td><code>1041 001a 001e 0001 0011 00000033...</code></td>
<td><code>public bridge synthetic compareTo (Ljava/lang/Object;)I</code></td>
</tr>
</tbody></table>
<p>JSL对<a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html" target="_blank" rel="noopener">bridge method</a>的定义为：</p>
<blockquote>
<p>When compiling a class or interface that extends a parameterized class or implements a parameterized interface, the compiler may need to create a synthetic method, called a bridge method, as part of the type erasure process. You normally don’t need to worry about bridge methods, but you might be puzzled if one appears in a stack trace.</p>
</blockquote>
<p>比较奇怪的是<code>getHello1</code>也生成了一个桥接方法，我在网上查到的说法是只有类型擦除的时候才会生成bridge method，但实际上我试下来只要Child继承了Base，无论是否继承了Comparable，都会生成一个bridge的<code>getHello1()</code>。看了下反编译后的字节码，似乎bridge方法都会invokespecial/invokevirtual另一个方法，也就是说会把具体实现代理到其他方法去。</p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p>可以看出，每个方法都有一个Code类型的属性，实际上的字节码也保存在这个属性里。之前也提到过一个ConstantValue属性。JVM对属性的规定比较宽泛，也允许编译器向属性表写入自己定义的属性信息。这里只记录一些常见的属性。</p>
<h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>完整的Code_attribute定义如下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 max_stack;</span><br><span class="line">    u2 max_locals;</span><br><span class="line">    u4 code_length;</span><br><span class="line">    u1 code[code_length];</span><br><span class="line">    u2 exception_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上一节中的<code>compareTo (LChild;)I</code>方法为例，其完整二进制代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0011 0000003e 0002 0002 0000000a </span><br><span class="line">2a b4 00 02 2b b4 00 02 64 ac </span><br><span class="line">0000 </span><br><span class="line">0002</span><br><span class="line">0012 00000006 0001 0000 0019 </span><br><span class="line">0013 00000016 0002 0000 000a 0014 0015 0000 0000 000a 001c 0015 0001</span><br></pre></td></tr></table></figure>

<p>可以看出，这个方法允许的最大操作数栈的最大深度为2，允许最多2个局部变量（包括形参）：max_locals参数的单位是slot，对于小于双字节的类型（如byte,char…）需要1个slot，而对double和long则需要2个slot。方法参数包括this，所以这个方法实际上参数是2。代码长度为10（<code>2a b4 00 02 2b b4 00 02 64 ac</code>），分别表示：</p>
<table>
<thead>
<tr>
<th>字节码</th>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>2a</td>
<td><code>aload_0</code></td>
<td>将第一个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>b4 0002</td>
<td><code>getfield</code></td>
<td>获取指定类的实例域, 并将其压入栈顶。这里操作数为0x0002，查询常量池可知要把Child.hello2压栈</td>
</tr>
<tr>
<td>2b</td>
<td><code>aload_1</code></td>
<td>将第二个引用类型本地变量推送至栈顶</td>
</tr>
<tr>
<td>b4 0002</td>
<td><code>getfield</code></td>
<td>获取指定类的实例域, 并将其压入栈顶</td>
</tr>
<tr>
<td>64</td>
<td><code>isub</code></td>
<td>将栈顶两int型数值相减并将结果压入栈顶</td>
</tr>
<tr>
<td>ac</td>
<td><code>ireturn</code></td>
<td>从当前方法返回int</td>
</tr>
</tbody></table>
<p>之后exception_table为空，有两个额外属性，分别是<code>LineNumberTable</code>和<code>LocalVariableTable</code>。</p>
<h3 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h3><p>用于描述java源代码行号和字节码行号之间的对应关系，定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 line_number;	</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这段代码偏移量为0的代码对应源代码的第25行，且只有一行代码。</p>
<h3 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h3><p>非必须属性，用来记录每个变量的名字，方便别人调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码一共记录了两个变量名，分别是<code>this</code>和<code>o</code>，对应两个形参名。</p>
<p>此外Child类中还有SourceFile、Signature属性，这里就不多说了。</p>
<p>Child类基本就分析到这了，实际上少分析了几个比较重要的分析，比如执行过程中的异常处理流程、异常抛出列表等、引导方法（BootstrapMethods）、各种字节码指令（特别是异常指令和同步指令）等，之后再补充。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/30/jvm3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/30/jvm3/" class="post-title-link" itemprop="url">JVM学习（3）垃圾回收器和内存分配策略</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-30T00:00:00+08:00">2019-08-30</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-01 16:19:28" itemprop="dateModified" datetime="2019-09-01T16:19:28+08:00">2019-09-01</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>垃圾回收（Garbage Collection,GC）机制是JVM的核心之一，而GC时需要考虑几个问题：</p>
<ol>
<li>回收哪些内存</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>判断一个object是否死亡主要有两种方式：引用计数和可达性分析。引用计数相对简单，但在object互相引用时会造成内存泄漏，所以JVM使用了可达性分析：一个存活的object所引用的object也是存活的。最初的存活对象被称为GC Roots，包含以下几类：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ol>
<h3 id="引用（reference）"><a href="#引用（reference）" class="headerlink" title="引用（reference）"></a>引用（reference）</h3><p>值得一提的是“引用”，Java中的引用分为以下几类：</p>
<ol>
<li>强引用（strong reference）：正常代码中的引用，比如Object a = new Object()</li>
<li>软引用（soft reference）：SoftReference类，描述一些还有用但非必须的对象。这类引用一般不会回收，但如果GC时判断可能会OOM，则会回收这类引用，如果回收失败时还可能OOM，则报错。</li>
<li>弱引用（weak reference）：WeakReference类，和SoftReference类似，但只能存活到下一次GC前。</li>
<li>虚引用（phantom reference）：最弱的引用，不对对象生存周期有任何影响，这类引用返回的对象总是null，不过如果GC回收这个对象，那么会接收到一个消息。</li>
</ol>
<p>SoftReference主要用于缓存，比如google的LoadingCache。PhantomReference主要用来实现类似析构函数之类的功能。这里又牵扯到finalize()方法，JVM规定如果object没有覆写finalize()或者finalize()已被JVM调用过，那么GC时就不用管finalize()。而如果JVM判断需要执行finalize()方法，那么会把这个object扔到一个叫F-Queue的队列里，由一个低优先级的Finalizer线程去依次执行各个finalize()方法：最关键的地方在于这个Finalizer不保证finalize()能被执行完，毕竟如果一个finalize()死循环或者超时了会影响整个JVM的工作，所以可能执行到一半就停了。此外，如果finalize()里又和其他对象建立了引用关系，执行完finalize()，GC会判断这个object又重新可达了，会不去回收这个对象，相当于c++中一个object在执行完析构函数后还正常存活。</p>
<p>总的来说因为finalize()有各种各样的坑，所以在需要类似析构函数的地方采用PhantomReference来代替。一个最典型的例子是DIrectBuffer，这个类有一个成员是cleaner，它是PhantomReference的子类，当一个DIrectBuffer被GC时会把这个对象塞到指定的ReferenceQueue里，然后再释放引用的堆外内存。</p>
<h3 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h3><p>方法区主要有两种数据可能会被回收：废弃常量和无用的类。常量回收和普通object回收很类似，只是这些常量放在方法区而已；无用的类判断起来很严格，要求</p>
<ol>
<li>没有该类的任何实例</li>
<li>加载该类的ClassLoader已被回收</li>
<li>该类对应的java.lang.Class对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法</li>
</ol>
<p>一般来说类还是不需要被回收的，但对于大量使用反射、动态代理、cglib等ByteCode框架、动态生成JSP以及OSGi这些频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，保证永久代不会溢出。值得一提的是JDK1.8以后取消了永久代，取而代之的是元空间（metaspace），metaspace使用的是native memory，且可以动态增加（当然也有上限，通过MaxMetaspaceSize配置）。这样可以极大降低永久代溢出的风险。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除（mark-sweep）算法"><a href="#标记-清除（mark-sweep）算法" class="headerlink" title="标记-清除（mark-sweep）算法"></a>标记-清除（mark-sweep）算法</h3><p>简单来说就是标记哪些部分的内存需要回收（见前文），标记完后统一回收。问题显而易见：运行一段时间后会产生大量的内存碎片，导致内存利用率降低。此外单线程的mark-sweep必然效率低。</p>
<h3 id="复制（copy）算法"><a href="#复制（copy）算法" class="headerlink" title="复制（copy）算法"></a>复制（copy）算法</h3><p>这种算法需要将内存分成（等大的）A，B两部分，分配内存时从A开始顺序分配，GC的时候把A中判定为存活的object复制到B，然后再从B开始顺序分配。好处是简单高效，缺点也显而易见：有一半内存被闲置了。</p>
<p>一般新生代采用这种回收方法，即将内存分成一大块的eden区和两块较小的survivor区，每次使用eden区和一个survivor区。内存从eden区开始顺序分配，假设eden区能回收绝大部分内存，那么GC的时候就把eden区和survivorA区的内存copy到survivorB区即可，这样就可以在只闲置一个survivor内存的情况下保证内存分配和回收足够高效。</p>
<p>在某些情况下可能survivor区不够大，需要依赖其他部分内存（老年代）进行分配担保（handle promotion），即把一部分对象直接扔到老年代。</p>
<h3 id="标记-整理（mark-compact）算法"><a href="#标记-整理（mark-compact）算法" class="headerlink" title="标记-整理（mark-compact）算法"></a>标记-整理（mark-compact）算法</h3><p>mark-sweep的改进，在标记完后把所有存活object向一个方向移动，可以避免内存闲置。</p>
<h3 id="分代收集（generational-collection）算法"><a href="#分代收集（generational-collection）算法" class="headerlink" title="分代收集（generational collection）算法"></a>分代收集（generational collection）算法</h3><p>根据对象生存周期的不同把内存划成几块（一般是分为新生代和老年代），在各部分内存采用不同的回收算法。比如在年轻代可以用复制算法，而老年代可以用标记-清理或标记-整理算法。</p>
<h2 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h2><h3 id="GC-Roots和OopMap"><a href="#GC-Roots和OopMap" class="headerlink" title="GC Roots和OopMap"></a>GC Roots和OopMap</h3><p>进行可达性分析时有两个问题：</p>
<ol>
<li>GC Roots包括两部分：全局性引用（如常量和类静态属性）和执行上下文（如栈帧中的本地变量表）。但这两部分内存包含的不仅是reference，还有比如方法，int，long型变量等，逐个检查这些内存中的引用会比较费时。</li>
<li>可达性分析时需要保证分析过程中的对象引用关系不变，这点是GC需要停顿所有java执行线程（stop the world）的重要原因之一。</li>
</ol>
<p>针对第一个问题，HotSpot采用了一种称为OopMap的数据结构来记录对象内哪些地方存放着reference，在类加载完后就可以把对象内什么偏移量上是什么类型的数据计算出来。这种GC方式被称为准确式GC，准确式GC和保守式GC的区别可以参考<a href="https://blog.csdn.net/woaigaolaoshi/article/details/51439227" target="_blank" rel="noopener">我爱学Java之JVM中的OopMap</a>。HotSpot在JIT（just in time）编译过程中，会插入相关指令来标明哪些地方是对象引用，如下图中0x026eb730到0x026eb7be这段区间内，exb寄存器和栈中偏移为16的内存区域各有一个普通对象指针的引用。</p>
<p><img src="/images/jvm_oopmap_sample.png" alt="String.hashCode()方法编译后的本地代码"></p>
<h3 id="安全点（safe-point）"><a href="#安全点（safe-point）" class="headerlink" title="安全点（safe point）"></a>安全点（safe point）</h3><p>OopMap能加速GC Roots枚举，但本身也会占用一定空间，因此不是所有指令都生成对应的OopMap，只在特定位置生成OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用，这样的位置称为安全点（safe point）。一般safe point选在可能“长时间执行”的地方，包括</p>
<ol>
<li>循环的末尾 </li>
<li>方法临返回前 / 调用方法的call指令后 </li>
<li>可能抛异常的位置</li>
</ol>
<p>另一个问题在于如何在GC时让所有线程（除JNI）外都跑到最近的safe point再停下来，有两种方式：</p>
<ol>
<li>抢先式中断（Preemptive Suspension）：GC发生时，先把所有线程中断，如果发现线程部在safe point上，则恢复执行，让它跑到安全点上</li>
<li>主动式中断（Voluntary Suspension）：GC时先设一个标志，各个线程会轮询这个标志，如果这个标志为true时就自己中断</li>
</ol>
<p>现在一般都用主动式中断，比如下边这个代码，GC需要暂停线程时会把0x160100内存页设置为不可读，那么线程执行到test时会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程，从而实现等待。</p>
<p><img src="/images/jvm_safe_point_sample.png" alt="轮询指令"></p>
<p>话说回来，让线程主动自陷的前提是线程本身正在运行，但如果线程并没有执行，比如正在sleep、blocked等等，因此引入安全区域（safe region）的概念。所谓safe region，是指这段代码片段中引用关系不会发生变化。线程进入safe region后就不管GC设置的标志了，但出safe region时需要检查GC是否已经完成了根节点枚举或者整个GC过程，没有的话就等到GC结束。</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>HotSpot提供了很多垃圾回收器，方便用户在特定情况下使用合适的垃圾回收方式。下图列出了适合新生代和老年代的各个垃圾回收器，注意并不是所有垃圾回收器可以配合使用。</p>
<p><img src="/images/jvm_gc_types.png" alt="HotSpot虚拟机的垃圾收集器"></p>
<h3 id="Serial-Serial-Old收集器"><a href="#Serial-Serial-Old收集器" class="headerlink" title="Serial/Serial Old收集器"></a>Serial/Serial Old收集器</h3><p>最简单的单线程垃圾回收器，新生代使用Serial，采用复制算法；老年代使用Serial Old，采用标记-整理算法。好处是simple is the best，坏处是并行度不够，且stop the world时间很长。一般用在client模式下。</p>
<p><img src="/images/jvm_serial.png" alt="Serial收集器"></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>简单来说就是Serial的多线程版本。由于CMS只能和Serial和ParNew配合使用，故ParNew也是Server模式下首选的新生代收集器。</p>
<h3 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge/Parallel Old收集器"></a>Parallel Scavenge/Parallel Old收集器</h3><p>看介绍和ParNew差不多，但更关注吞吐量，即尽可能降低GC总时间。相对应的Parallel Old可以认为是Parallel Scavenge的老年代版本，两者可以配合使用，适用于吞吐量敏感的场合（比如离线任务）</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器的目标是降低GC停顿，适用于重视响应时间的服务。CMS基于mark-sweep算法，想法也很简单：很多时候stop-the-world是为了避免引用变更，但毕竟不是所有引用在GC期间都会改，所以如果能侦测到哪些引用没变且没被引用，就可以和其他用户线程同步进行回收。CMS步骤分为以下4步：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>其中1和3还是需要stop-the-world，而耗时最长的2和4可以和用户线程并发执行，显然GC停顿时间变短了。 </p>
<p><img src="/images/jvm_cms.png" alt="CMS执行流程"></p>
<p>当然CMS也有缺点，</p>
<ol>
<li>对CPU资源敏感，因为和用户线程并发执行会占用一部分CPU资源，导致用户程序执行变慢</li>
<li>无法处理浮动垃圾（floating garbage），由于和用户线程并发执行，在此期间产生的垃圾无法被检测和回收，导致CMS不能等到老年代几乎完全被填满了再进行收集，需要预留一部分。当CMS运行期间内存不足，会报“concurrent mode failure”，此时JVM会临时采用Serial Old来进行回收，触发full GC，导致响应时间变长</li>
<li>CMS基于mark-sweep，会导致大量内存碎片，对此可以选择在CMS执行几次不压缩的full GC后，执行一次带压缩的full GC。压缩的full GC过程无法和用户线程并发执行。</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage first）的基本思想是把内存预先划分成若干大小的region，在每个region独立执行GC，这样有几个好处：</p>
<ol>
<li>可以和用户线程并发执行</li>
<li>可以分代回收</li>
<li>内存碎片较少</li>
<li>停顿可预测</li>
</ol>
<p><img src="/images/jvm_g1_memory.png" alt="G1收集器的内存分布"></p>
<p>那么如何判断一个region的object是否被其他region引用？G1采用了Remembered Set来避免全堆扫描，每个region都配一个对应的remembered set，当JVM发现应用程序对reference类型进行写操作时，会产生一个write barrier暂时中断写操作，检查reference引用的对象是否在其他region，如果是的话就通过CardTable把相关引用信息记录到被引用对象所属的region的remembered set中，这样在扫region的时候可以避免全堆扫描。</p>
<p>更详细的可以参考<a href="https://blog.csdn.net/coderlius/article/details/79272773" target="_blank" rel="noopener">详解 JVM Garbage First(G1) 垃圾收集器</a></p>
<h2 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h2><h3 id="对象优先在eden分配"><a href="#对象优先在eden分配" class="headerlink" title="对象优先在eden分配"></a>对象优先在eden分配</h3><p>对象优先在eden分配，如果eden区不足，则会触发一次minor GC。</p>
<ul>
<li>Minor GC是新生代GC，指发生在新生代的垃圾收集动作，minor GC发生的比较频繁，且回收速度也比较快</li>
<li>Full GC（Major GC）指发生在老年代的GC。Full GC的速度一般比Minor GC慢10倍以上</li>
</ul>
<h3 id="大对象直接进老年代"><a href="#大对象直接进老年代" class="headerlink" title="大对象直接进老年代"></a>大对象直接进老年代</h3><p>比如byte[]数组。一般假定大对象的存活时间会比较长。分配连续的大内存可能会不成功，提前触发GC，应当尽量避免存活时间短的大对象。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>JVM中每个对象有一个age计数器，对象每经过一次minor GC，age加1，超过一定年龄后（比如15）就扔到老年代。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>不一定非要等到MaxTenuringThreshold才升级到老年代，如果survivor区相同年龄所有对象大小的总和超过survivor空间的一半，那么大于等于这个年龄的object也可以进入老年代</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>发生minor GC前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立的化minor GC就是安全的，否则会查看HandelPromotionFailure是否设置，如果设置的话会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果大于，会尝试一次有风险的minor GC；如果小于，或者HandelPromotionFailure未设置，则进行full GC。</p>
<p>所谓的风险是指survivor区可能无法容纳所有幸存object，会扔到老年代，而老年代如果也放不下，minor GC自然就失败了。</p>
<p>感觉这一章内容还没完全看懂，以后再详细了解一下。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/26/megastore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/26/megastore/" class="post-title-link" itemprop="url">megastore阅读笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-26 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-26T00:00:00+08:00">2019-08-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-30 16:38:22" itemprop="dateModified" datetime="2019-08-30T16:38:22+08:00">2019-08-30</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前粗略浏览过一遍megastore论文，对其中数据模型有点印象，但后面没太细看，今天补上。</p>
<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>Megastore的目标是为了服务交互式线上服务，比如gmail、picasa。当然google后来已经改用spanner&amp;F1了。基本架构如下图所示。</p>
<p><img src="/images/megastore1.png" alt="图1"></p>
<p>Megastore将数据分为一个个Entity Group（怎么分得看具体业务）。每个数据中心都保存了完整的数据副本（为了便于理解，其实按说也不一定）。在同一数据中心内部，如果在同一个EG里的事务，可以只用一阶段提交即可保证ACID语义；如果是跨EG的事务，可以用两阶段提交，也可以用消息队列，如下图所示。</p>
<p><img src="/images/megastore2.png" alt="图2"></p>
<p>而跨数据中心则基于paxos进行备份，这意味着可以直接从本地数据中心进行的读操作是有效的（且通常是最新的），但写操作非常的重。我之前读到这的时候很奇怪，毕竟大多数情况写进某个DC再慢慢传播就行了，但megastore确实是这么干的，只能认为这些DC之间的带宽和延迟都非常给力。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="物理布局"><a href="#物理布局" class="headerlink" title="物理布局"></a>物理布局</h3><p>Megasotre的数据模型介于RDBMS和NoSQL之间，spanner的论文没有详细描述数据模型，但估计和megastore差不多。一方面，megastore要求数据的每个字段是强类型的（具体格式很像protobuf，毕竟是google自家的产品），另一方面可能也和megastore依赖于BigTable有关，很难完全支持各种联表查询。考虑到megastore主要用于读远多于写的情况，故采用pre-join的方式，将读代价转移到写上（其实megastore采用paxos保持每个集群数据总是最新/较新也是为了保证高可读性），如下图所示。</p>
<p><img src="/images/megastore3.png" alt="图3"></p>
<p>Megastore的table分为root table和child table两种，child table必须要引用其root table的某个键（必须是主键？）：那么，一个entity group包含了一系列entity，每个entity有root table及其sub table中的数据。对于每个entity，具体数据被存放到Bigtable中的某一行，其所有主键按字符串顺序连接起来作为BigTable的row key，其他列则保存在column中。由于child table引用了root  table的某个键，因此child table的数据也选择这个键作为主键，而利用BigTable的row key按字典序存放可以保证这些数据紧邻，如下图所示。当然也可以声明为SCATTER，这样的entity会在rowkey前加两个字节的hash code，以避免热点。</p>
<p><img src="/images/megastore4.png" alt="图4"></p>
<p>其实我觉得还是有问题，比如root table的主键是K1,K2,K3，child table引用了K2,K3，主键是K4。假如有两个root entity A:(a1,a2,a3)和B:(b1,b2,b3)，其中a2=b2,a3=b3；一个child entity C(c4)，有属性(a2,a3)，需要在BigTable里加两行(a1-a2-a3-c4)和(b1-a2-a3-c4)？修改的时候也要对这两行同时修改？或者又建了一层索引？又或者完全不管(直接用c4当row key)？看了下tidb的实现，主键还是就这样连接起来，但tidb不支持foreign key，所以也没法参考。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`test_primary_keys`</span>(</span><br><span class="line">    <span class="string">`k1`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`k2`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`k3`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`k4`</span> <span class="built_in">INT</span>,</span><br><span class="line">   PRIMARY <span class="keyword">KEY</span> ( <span class="string">`k1`</span>,  <span class="string">`k2`</span>, <span class="string">`k3`</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_primary_keys <span class="keyword">values</span>(<span class="string">"hello"</span>, <span class="string">"my"</span>, <span class="string">"tidb"</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>

<p>实际存储到tikv里的数据是</p>
<blockquote>
<p>key: zt\200\000\000\000\000\000\000\377-_r\200\000\000\000\000\377\000\000\001\000\000\000\000\000\372<br>    write cf value: MvccWrite { r_type: Put, start_ts: 410775417252216833, commit_ts: 410775417278431233, short_value: [8, 2, 2, 10, 104, 101, 108, 108, 111, 8, 4, 2, 4, 109, 121, 8, 6, 2, 8, 116, 105, 100, 98, 8, 8, 8, 144, 7], unknown_fields: UnknownFields { fields: None }, cached_size: CachedSize { size: 0 } }</p>
</blockquote>
<p>同时，在Root Table的BigTable单行中，还存储了transaction,replication元数据以及Transaction Log。下图是整个MegaTable Table在BigTable之上的布局图。</p>
<p><img src="/images/megastore6.png" alt="图6"></p>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>二级索引主要分为两种：local index和global index。所谓的local和global取决于是否跨EG，如图3中的PhotosByTime和PhotosByTag。Local index实际上被放在同一个entity group里，可以保证强ACID语义。Global index可以在不知道具体哪个EG的情况下找到特定的entity，但更新可能会不及时。此外Megastore还支持一些特性：</p>
<h4 id="存储子句（storing-clause）"><a href="#存储子句（storing-clause）" class="headerlink" title="存储子句（storing clause）"></a>存储子句（storing clause）</h4><p>一般索引用法是先通过索引确定哪一行，再访问这一行得到结果。Storing clause允许把一些数据保存到索引里，比如图3中的PhotosByTag.thumbnail_url。</p>
<p>不是很确定megastore是怎么存index的。但在tidb里，索引其实也是一行数据，和普通的数据行没有本质区别，每次更新时都会影响所有索引行。那么往这些行里加点附加数据加速查询，也很是很自然的想法。</p>
<h4 id="重复索引（repeated-indexes）"><a href="#重复索引（repeated-indexes）" class="headerlink" title="重复索引（repeated indexes）"></a>重复索引（repeated indexes）</h4><p>如图3中的PhotosByTag.tag，每个tag都有个索引。很正常的想法，毕竟一张图可能有很多个tag，总不能把所有tag连接起来当索引吧。</p>
<h4 id="内联索引（inline-indexes）"><a href="#内联索引（inline-indexes）" class="headerlink" title="内联索引（inline indexes）"></a>内联索引（inline indexes）</h4><p>Local index的一种，个人理解是同一个EG里foreign key的反向映射，保存在root table里新加的几列里。如下图所示，PhotosByTime.user_id是User表的主键，因此在索引PhotosByTime(user_id, time)时，可以在user_id行，PhotosByTime.time列，找到对应的photo_id。</p>
<p><img src="/images/megastore5.png" alt="图5"></p>
<p>总的来说创建索引后要么新建一行，要么新建一列，具体怎么做还得看情况。</p>
<h2 id="事务处理和并发控制"><a href="#事务处理和并发控制" class="headerlink" title="事务处理和并发控制"></a>事务处理和并发控制</h2><p>如前所述，同一个EG内的事务处理保持严格的ACID语义，和大多数数据库一样，写数据前会写一条WAL（write-ahead  log），然后再按照这个WAL落盘。</p>
<p>又因为BigTable天然的支持MVCC（multiversion concurrency control），所以只要在写事务时加上对应的timestamp就自然可以让megastore支持MVCC，这也意味着可以不用加锁就能快照读，甚至写操作也不一定要加锁。</p>
<p>Megastore提供了三种级别读：当前读（current），快照读（snapshot），立即读（inconsistent）。Megastore的做法是对于current读，要求当前entity group内（原文是the scope of a single entity group，应理解为要读的行所涉及的事务？）所有已committed的写操作落盘，然后用最近一次提交的事务所带的timestamp去读；而对于快照读就没有要求落盘操作了，可以认为是用最后一次已成功落盘的事务的timestamp去读。立即读就是不管timestamp直接读，显然这么读最快，对一致性要求不高的时候可以这么来。</p>
<p>所有的写事务都需要先进行一次current read，以此确定下一个log的position，这点非常重要。接着生成一个足够大的timestamp，遵循paxos协议尝试追加log。如前文所属，megastore主要用于读远多余写的情况，因此采用乐观锁：如果多个写操作向同一个log position写，只有一个能成功，其他失败的写操作会推倒重来一遍。完整的事务流程如下：</p>
<ol>
<li>Current read：获得最近一次事务的timestamp和log position</li>
<li>应用逻辑：读取BigTable数据，然后把所有写操作合并到一个log entry里</li>
<li>提交：遵循paxos协议，把log追加到日志队列里</li>
<li>生效：将日志中的修改写到BigTable的对应行，并修改相关索引</li>
<li>清理：清理掉不需要的数据</li>
</ol>
<p>实际上走完第三步就可以通知客户端写成功了，毕竟理论上日志被committed后等价于写成功，当然megastore会尽可能让距离客户端最近的副本生效这个事务，确保用户能读到最新的修改。</p>
<p>之前提到megastore支持跨entity group事务，可以用消息队列或者二阶段提交实现，见图2。消息队列简单来说就是先在EG1上进行事务，然后EG1将事务打包成一个消息塞到EG2的队列里，EG2原子的消费这个消息，事务从而继续在EG2上执行。论文上没更详细的讲这部分，比如如果事务跨了三个EG该怎么发送消息？EG之间来回读、来回写呢？一个事务在这三个EG上timestamp是否要保持一致？二阶段提交应该就是先拿写锁再写。</p>
<h2 id="副本同步"><a href="#副本同步" class="headerlink" title="副本同步"></a>副本同步</h2><p>副本同步是megastore的核心，它使用了一个基于paxos的低延迟的复制策略，保证各个集群的副本是一致的：显然，写操作需要至少在一个quorum数量的数据中心上commit才算成功，这也意味着一个写操作几乎要把所有DC跑一遍。当然，严格的写操作可以保证一个current read能有以下保证：</p>
<ol>
<li>一旦一个write成功，那么这个时刻之后的current read一定能读到这个write（可见性）</li>
<li>一旦某个current read读到一个write，那么之后的读操作都可以读到这个write（持久性）</li>
</ol>
<h3 id="副本架构"><a href="#副本架构" class="headerlink" title="副本架构"></a>副本架构</h3><p>首先megastore允许每个position的log彼此独立，且log可以有空洞，这个和raft不太一样。下面这张图列出了大多数可能的日志冲突的情况。按我理解，日志冲突时具体恢复成哪个版本也说不定，和paxos运行有关，比如102，如果δ的proposal_id足够高，γ又没抢到更高的proposal_id，可能到最后会以δ为准。</p>
<p><img src="/images/megastore9.png" alt="图9"></p>
<p>一般来说副本应该包括log和具体数据，但实际上paxos要求多个acceptor只是为了达成一致，所以可以让一些副本只保留log信息（这类副本称为witness）。此外，有时候也不太需要特别新的副本，只要保留某一时刻强一致性的数据就可以支持read，这类副本称为read-only副本。总的来说，megastore的架构如下图所示，论文描述的是“Each application server has a designated local replica”，应理解为每个应用都指定了一个本地副本，然后通过megastore library来和其他副本进行同步。</p>
<p><img src="/images/megastore8.png" alt="图8"></p>
<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><p>之前提到，write操作需要先进行一次current read，从而决定write的timestamp，设这个timestamp为t0。那么，对于t&lt;t0的快照读，write<sub>t0</sub>是一定不会看到的；write<sub>t0</sub>被commit后，对于current read，它的timestamp一定&gt;t0，且要求write<sub>t0</sub>落盘后才能继续，因此current read不会读到写到一半的数据。故current read的隔离级别至少是可重复读的。类似的，由于snapshot读会选择最后一个落盘的事务的timestamp读，而一个事务落盘意味着它之前的事务也落盘了，故snapshot读也至少是可重复读的。</p>
<p>显然，如果写操作非常少的情况下，我们可以直接从任意副本读取最新数据，不需要RPC。那么问题就在于如何判断一个副本是最新的？为了解决这个问题，对于一个特定的entity集合，Megastore在每个DC都起了一个coordinator的服务，来管理这个entity集合内的副本状态。更准确的说，coordinator维持了一个最新的副本列表，如果某个写操作被某个副本拒绝，那么这个副本上的coordinator就会把对应的entity group key移除，这一过程称为invalidation。</p>
<p>完整的current read流程如下：</p>
<ol>
<li>本地查询（query local）：查询本地的coordinator确定本地副本是否最新</li>
<li>寻找log position（find position）确定最高的可能的已被commited的log position，然后选择一个已经成功应用这个log的副本，<ul>
<li>a. 如果1已确定本地副本是最新的，那么直接以最后一个已committed的事务的timestamp读本地副本即可。</li>
<li>b. 如果本地副本不是最新的，或者2a超时了，那么会发起一次majority read（paxos保证多数派副本是一致的），找到大多数副本中最大的Log Position信息以及Timestamp信息，然后选择一个通常能快速响应的Replica或者是数据最新的Replica去读。</li>
</ul>
</li>
<li>数据追赶（catch up）：当知道本地副本已经不是最新，且在2b中选择了一个副本的情况下，会尝试补全数据：<ul>
<li>a. 对于某个position，如果选定的副本能确定已经有共识值的情况下，就按共识值填，不确定的话再找个副本接着读；如果都确定不了，则用no-op或者之前某个候选值填充这个position。</li>
<li>b. 当所有log被补齐后，依次apply这些log</li>
</ul>
</li>
<li>校验（validate）：如果选择了本地副本且之前不是最新的，那么通知coordinator，(entity group, replica)已更新至最新，且通知所有相关的write操作该副本部分已更新。</li>
<li>数据查询（query data）：使用已知的最大timestamp去读已选中的副本，如果这个副本已过期，那么再找个副本执行一遍catch up</li>
</ol>
<p>其中1和2a可以并发执行，时序流程图如下。</p>
<p><img src="/images/megastore10.png" alt="图10"></p>
<h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>可以看到，current read可以得到下一个可用的log position，最新的timestamp，以及下一个leader副本。因此Write操作会先进行一次current read，然后去竞争写这个position log。在write被committed并准备apply前，需要所有集群的副本，要么接受这个write，要么对应的coordinator失效相关的entity。完整的write流程如下：</p>
<ol>
<li>请求Leader（ Accept Leader）：请求leader将自己的提议的值作为0号提议，如果成功转3</li>
<li>准备（Prepare）：即basic paxos prepare阶段，找到有最大proposal_id的value，并生成一个更大的proposal_id去提交</li>
<li>接受（Accept）：即basic paxos accept阶段。如果失败则转2。</li>
<li>失效（Invalidate）：要求所有没接受这个值的副本上的coordinator对相关entity进行invalidate处理</li>
<li>落盘（Apply）：在尽可能多的副本上落实这个log，如果选中的值和初始值不同，则报一个conflict error</li>
</ol>
<p>其实整个流程就是paxos，其中第一阶段是fast write，时序流程图如下。值得注意的是，一般数据库的commit point和visibility point一样，即一旦一个write被committed，用户就可以看到相关变更。而在megastore里，commit point在3，而visibility  point则在4。至于leader的选择，一般会按照某个启发式规则来确定，比如某个地区的application写操作比较多，那么离这些地方最近的副本就可以被选为leader。显然，如果leader一直有效且各个副本响应的足够快，那么整个写操作就退化为master-slave架构；如果leader总是挂，那么整个过程就退化为basic paxos流程。</p>
<p><img src="/images/megastore11.png" alt="图11"></p>
<h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>最后一个问题是coordinator，因为几乎所有的读写请求都要过coordinator，且对整个系统的正确性有决定性的影响，所以megastore把coordinator做成一个轻量级、无状态的服务，且只有coordinator拿到过半数的chubby锁时才被认为有效。如果没拿到足够多的锁，那么coordinator就认为所有entity group都过期了。如果一个coordinator突然挂了（比如失去了锁），那么在这个副本上的current read和write都得等coordinator重新上线后才能跑，但实际上coordinator宕机恢复期间，客户端可以其他副本进行current read和write操作。</p>
<p>由于megastore允许乱序log，对于position n,m，n&gt;m，如果m处日志写入失败而n写入成功，那么coordinator会报一个crash。不过我没太看懂coordinator检测crash的机制，原文如下。</p>
<blockquote>
<p>We detect crashes using a unique epoch number for each incarnation of the coordinator: validates are only allowed to modify the coordinator state if the epoch remains unchanged since the most recent read of the coordinator.</p>
</blockquote>
<p>其实想也知道megastore的写操作异常的重，吞吐量肯定不会高，</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="/files/Megastore.pdf">原文</a></li>
<li>Google Megastore分布式存储技术全揭秘：<a href="https://www.cnblogs.com/yako/archive/2011/02/18/1957790.html" target="_blank" rel="noopener">https://www.cnblogs.com/yako/archive/2011/02/18/1957790.html</a></li>
<li>Google-MegaStore的解读：<a href="https://www.iteye.com/blog/57832638-2028003" target="_blank" rel="noopener">https://www.iteye.com/blog/57832638-2028003</a></li>
<li>Google Megastore读写的架构分析：<a href="https://www.oipapio.com/cn/article-1701115" target="_blank" rel="noopener">https://www.oipapio.com/cn/article-1701115</a></li>
<li>Megastore详解：<a href="http://www.nosqlnotes.com/tag/megastore/" target="_blank" rel="noopener">http://www.nosqlnotes.com/tag/megastore/</a></li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/jvm2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/jvm2/" class="post-title-link" itemprop="url">JVM学习（2）JVM内存布局</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:03" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:03+08:00">2019-08-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-31 18:25:13" itemprop="dateModified" datetime="2019-08-31T18:25:13+08:00">2019-08-31</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>在学习垃圾回收前需要了解JVM内存的各个区域，如下图所示。</p>
<p><img src="/images/jvm_mem.png" alt="JVM运行时数据区"></p>
<p>还是蛮容易理解的，很多区域可以和实机的区域对应上，实现的目的也相似。</p>
<h3 id="程序技术器（Program-Counter-Register）"><a href="#程序技术器（Program-Counter-Register）" class="headerlink" title="程序技术器（Program Counter Register）"></a>程序技术器（Program Counter Register）</h3><p>JAVA的处理单元是线程，那么为了线程切换，需要为每个线程保存一个独立内存区域以便恢复，这类区域成为“线程私有”的内存区域。本区域可以看作当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。简单来说模拟了CPU（运行时保存的数据）</p>
<p>如果线程执行的是一个java方法，那么这个计数器指向正在执行的虚拟机字节码指令的地址。如果执行的是native方法，则为空(undefined)。</p>
<p>本区域在JVM规范里没有规定任何OOM情况。</p>
<h3 id="JAVA虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#JAVA虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="JAVA虚拟机栈（Java Virtual Machine Stacks）"></a>JAVA虚拟机栈（Java Virtual Machine Stacks）</h3><p>模拟的是栈区，每个方法在执行时会创建一个栈帧（stack frame），保存了局部变量表、操作数栈、动态链接、方法出口等。</p>
<p>局部变量表存放了编译期可知的各种基本类型、对象引用、返回地址，其长度在编译器可以确定，运行时不能改变变量表的大小。（这点似乎与C不同，C和JAVA都支持数量可变的参数方法，但JAVA是通过数组模拟的，而C是真的压栈传参的。）</p>
<p>有两种异常情况，</p>
<ul>
<li>StackOverflowError：请求深度超过JVM允许的最大深度。</li>
<li>OutOfMemoryError：虚拟机栈扩展时如果申请不到足够的内存就会报OOM。当然JVM规范也允许固定长度的虚拟机栈。</li>
</ul>
<h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>与JAVA虚拟机栈相似，只不过方法是本地方法。JVM规范没有强制规定本地方法栈使用的语言、方法、数据结构，所以可以自由实现，甚至可以和JAVA虚拟机栈合二为一（比如hotspot）。也会报StackOverflowError和OOM。</p>
<h3 id="JAVA堆（Java-Heap）"><a href="#JAVA堆（Java-Heap）" class="headerlink" title="JAVA堆（Java Heap）"></a>JAVA堆（Java Heap）</h3><p>专门为了存放对象实例的内存区域，被所有线程共享（但可能划分出线程私有分配缓存区，Thread Local Allocation Buffer TLAB）。理论上所有对象实例和数组都应该分配在堆上，但实现时可以优化到别的地方。</p>
<p>JAVA堆是垃圾收集器的主要区域。由于现在收集器基本都采用分代收集算法，从内存回收的角度看，还可以细分为新生代和老年代，更细致一点可以分为eden、from survivor、to survivor空间等。</p>
<p>JAVA堆在物理上可以不连续，但在逻辑上必须连续。其大小可以固定，但一般是可扩展的，通过-Xmx和-Xms控制，申请不到新内存时会报OOM。</p>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>存放已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，被所有线程共享。JVM规范把方法区描述为堆的一个逻辑部分，但有个别名non-heap以区分对待。</p>
<p>Hotspot实现时将GC分代回收机制扩展至方法区，故方法区又成为永久代（Permanent Generation），其他虚拟机不一定这么实现。JVM规范没有强制规定怎么实现，用永代区实现的话可能会更容易遇到OOM，使用native memory似乎更好。</p>
<p>此外，JVM规范可以允许不在方法区实现GC，毕竟GC也就只能回收常量池和被卸载的类型。</p>
<h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>方法区的一部分，用于存放编译期生成的各种字面量和符号引用，在类被加载后放到常量池；事实上也可以动态添加，比如String.intern()。</p>
<h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>为执行本地方法提供的内存区域，可以认为是给本地方法提供的堆区。显然，由于Direct Memory和Java Heap是两个独立的区域，而Java方法无法直接访问Direct Memory，所以某些情况下会在两个区域间来回复制数据，导致性能下降。</p>
<p>在JDK1.4以后新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）和缓存区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，从而避免数据复制。</p>
<p>另外，通过<code>-XX:MaxDirectMemorySize</code>只能阻止java代码分配DirectBuffer，对在JNI里调用malloc之类的内存分配函数无效。之前做过一个实验，给<code>MaxDirectMemorySize</code>设置了一个很小的值，然后不断在jni里malloc，结果过了一会把机器打爆了。。。</p>
<h2 id="对象机制"><a href="#对象机制" class="headerlink" title="对象机制"></a>对象机制</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>JVM遇到new指令时，</p>
<ol>
<li>检查这个类有没有被加载，没有的话执行一遍类加载过程</li>
<li>确定对象大小，JAVA的继承机制导致类型一旦确定，则大小可以完全确定</li>
<li>为对象分配内存。两种方式，具体用哪种取决于GC支不支持压缩整理<ul>
<li>指针碰撞（Bump the Pointer）：假设内存以指针P为界分为两部分，&lt;P的部分为已使用的内存，&gt;=P的部分为空闲内存，则分配时只要移动P即可。</li>
<li>空闲列表（Free List）：维护一个所有空闲内存的列表，分配时找一个足够大的内存分配过去并更新列表。</li>
</ul>
</li>
<li>另外内存分配可能是线程不安全的，要么加同步处理，要么为每个线程预留一块本地线程分配缓冲（Thread Local Allocation Buffer TLAB），用完并重新分配时进行同步处理。</li>
<li>对对象内存置零。如果用TLAB，可以把这个动作提前至TLAB分配时进行。</li>
<li>设置对象头</li>
<li>调用方法</li>
</ol>
<p>和C++相比，共同点是都要分配内存和调用init()，不同点是JAVA可以实现类动态加载、对象有对象头之类的填充内容，且内存分配方案与GC直接相关。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>简单来说是由对象头（Header）、实例数据（Instance Data）和对齐信息（Padding）组成。对齐信息就是单纯为了让object按内存对齐，没有特别用处；实例信息是这个对象保存的实际信息，值得注意的是实际的内存分布和代码顺序、继承顺序没有必然关系，子类的较小变量也可能被插在父类的变量之间，为了对齐的更整齐、更紧致一些。</p>
<p><img src="/images/Synchronization.gif" alt="JVM运行时数据区"></p>
<p>重点是对象头，分为两部分。第一部分为标记字段（Mark Word），其长度为32/64 bits，和JVM有关，所保存的数据含义根据object状态不同而不同，比如在下图unlocked non-biasale object的32位中，前25bit表示该object的hash code，4bit保存分代年龄，1bit固定为0,后两位存储锁标志位。</p>
<p>第二部分为类型指针（Klass Pointer），用以确定这个实例来自哪个类。但如果JVM实现时可以通过别的方式查找到所属类，那么也可以没有这个字段。</p>
<p>另外如果是数组，还需要一个字段记录数组长度。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>如何定位对象的address取决于我们使用的是句柄还是直接指针。句柄的话就得先访问句柄再访问内存，直接指针可以直接访问内存。不过句柄的好处是GC的时候不用改太多东西。HotSpot用第二种方式。</p>
<p><img src="/images/jvm_visit_by_handle.png" alt="通过句柄访问对象"></p>
<p><img src="/images/jvm_visit_by_pointer.png" alt="通过指针访问对象"></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/arthas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/arthas/" class="post-title-link" itemprop="url">阿里Arthas学习</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:01 / Modified: 16:51:04" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:01+08:00">2019-08-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前几天同事分享了一个巨流弊的工具<a href="https://alibaba.github.io/arthas/" target="_blank" rel="noopener">Arthas</a>，可以在线上花式调试/监控JVM上的代码运行状况，excited!这里记录几个常用命令。</p>
<p>启动命令: <code>wget https://alibaba.github.io/arthas/arthas-boot.jar &amp;&amp; java -jar arthas-boot.jar</code></p>
<h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><p>就是dashboard</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>流弊！watch可以监视某个方法的运行状况，但缺点是它不能像断点一样阻塞这个线程。一般调用方法为watch $class_name $method $watch_express $cond_express $flags, 其中观察表达式（watch_express）和条件表达式（cond_express）为<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">OGNL表达式</a>，个人还不太会用，基本元素可以参考表达式核心变量。</p>
<p>class_name需要把路径写全，某个类的子类要写成parentClass$subClass，用$符号隔开</p>
<p>-b -e -s 分别表示在方法运行前、异常返回后、正常返回后监控。-f或者什么都不写表示返回后监控。</p>
<p>-x表示观察递归深度。比如某个参数p有内部变量p1，p1有内部变量p2，那么要打印出p2，需要指定-x 3</p>
<h3 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h3><p>查看JVM已加载的类信息</p>
<h3 id="redefine"><a href="#redefine" class="headerlink" title="redefine"></a>redefine</h3><p>流弊！<a href="https://alibaba.github.io/arthas/redefine.html" target="_blank" rel="noopener">redefine</a>可以加载外部某个.class文件进jvm，redefine后的原来的类不能恢复，redefine有可能失败（比如增加了新的field），参考jdk本身的文档。有两个限制：</p>
<ul>
<li>不允许新增加field/method</li>
<li>正在跑的函数，没有退出不能生效，比如下面新增加的System.out.println，只有run()函数里的会生效</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MathGame game = <span class="keyword">new</span> MathGame();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            game.run();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这个不生效，因为代码一直跑在 while里</span></span><br><span class="line">            System.out.println(<span class="string">"in loop"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 这个生效，因为run()函数每次都可以完整结束</span></span><br><span class="line">        System.out.println(<span class="string">"call run()"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> number = random.nextInt();</span><br><span class="line">            List&lt;Integer&gt; primeFactors = primeFactors(number);</span><br><span class="line">            print(number, primeFactors);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"illegalArgumentCount:%3d, "</span>, illegalArgumentCount) + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简单来说可以不用每次修改完后重新打包-上传-重启了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/cheat1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/cheat1/" class="post-title-link" itemprop="url">页游辅助思路</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:00 / Modified: 16:40:53" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:00+08:00">2019-08-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实我玩过的页游也就是舰C，这游戏最大的特点就是制作者恨不得让玩家每天996的肝游戏（如果玩家稍微有点追求），发展到现在可以说没辅助没法玩。不过这个游戏也可以很简单的进行辅助操作，因为页面之间变化不大，操作简单：玩家也就只能点点鼠标。</p>
<p>原理简单来说还是模拟人类玩家的操作方式：根据页面图像来进行下一步操作。</p>
<p>页面图像获取一般还是用GetPixel之类的API。在windows上，可能用DX系列的API更好一些，但调用实在太复杂，且兼容性比较差。话说自从舰C改版到HTML5后，基本只能用chrome或者chromium内核来玩了，而这个浏览器似乎不支持PrintWindow等可以通过窗口DC直接获取截图的方法——或者说DX窗口都不支持PrintWindow，导致我只能用全屏截图的API或者类似的API，而不能把游戏窗口隐藏到后端：毕竟挂机的时候也希望干点别的事。个人猜测可能是因为DX截图是基于显示设备的，没办法获取被隐藏的窗口。</p>
<p>图像获取后的另一个问题是”判断“，往大了说是图像识别，但通常只要判断子图是否一致，甚至某几个像素是否一致就可以了。按键精灵这种外挂似乎可以通过子图识别来确定，不过我觉得舰C不太需要这么高端的功能，毕竟几乎所有按钮出现的位置都不会变，因此不需要去”找“，而只需要在特定位置”判断“某个子图是否出现即可。</p>
<p>模拟操作相对而言很简单，获取到窗口句柄后PostMessage就可以了。</p>
<p>”输入“和”输出“手段就这样愉快的决定了，接下来是辅助器的设计思路。由于舰C这种页游的页面显示变化很小，场景间处理逻辑差别很大，关联很小，故可以用状态机模型来进行编程：维持一个context，将每一个场景视为”state“，出现某个图像/自定义函数作为”condition“，如果满足条件则进行状态切换/改变上下文/进行操作。舰C的context比较好获得，大部分可以通过游戏内部数据获取，可以通过截取解析HTTP包获得，或者干脆用现成的工具74EO解析。一般的页游也差不多，如果不想解析包，也可以直接处理图像获得（比如血条什么的），但毕竟不如直接解包来的准确。</p>
<p>举个例子，比如在舰C里刷闪，涉及到的场景大致有主页面、队伍编成页面、补给页面、地图选择页面、战斗页面，切换条件分别为：</p>
<ul>
<li>主页面：如果编成未结束进入编程场景；如果没补给完则通过补给按钮进入补给场景；否则进入地图选择场景</li>
<li>队伍编成场景：选择要刷闪的船，选完后返回主页面。没有要刷闪的船则在返回后跳出。</li>
<li>补给场景：能补给则补给，补给完则返回主页面。</li>
<li>地图选择场景：进入1-1，切换至战斗场景。</li>
<li>战斗场景：不停出击，直至返回主页面。<br>每个场景内的操作相对简单，比如在战斗场景里，如果出现阵型选择则点击单纵（实际上刷闪因为只有三艘船不会选择阵型），出现战后结算则随便点一下，出现是否前进则点击前进，出现是否入夜则点击不入夜。</li>
</ul>
<p>可以思考一下如何在刷闪的时候收发远征？</p>
<p>在构筑好状态机后，我们需要两个协程，协程A每隔一段时间（比如3秒）截图，将截图放入上下文，控制权交给协程B；协程B跑上面这个状态机，根据上下文进行一轮条件判断和操作，再交给协程A。</p>
<p>我一开始的代码逻辑是顺序的：判断图像-进行操作-判断图像-进行操作。。。。这种编程思路的坏处是，如果某个判断/操作失败了（比如窗口没收到点击消息、某个图片迟迟没弹出等），需要进行异常处理的逻辑会变得非常复杂。而页游中同一场景中的条件判断几乎不重复，即使某次判断/操作失败了也可以再一次正确处理。另外，如果游戏机制改变了，需要插入的逻辑也会比较简单。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/java-dynamic-proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/java-dynamic-proxy/" class="post-title-link" itemprop="url">Java动态代理笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:00 / Modified: 16:46:34" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:00+08:00">2019-08-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天重构代码时遇到一个可能需要动态代理的地方，感觉自己对代理模式理解还是不够，做点笔记。</p>
<p>代理模式（Proxy Pattern）是程序设计中的一种设计模式，定义为：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>在不希望直接调用方法/访问对象A时，希望变成操作A’，间接影响A，这样可以降低代码逻辑的复杂度。无论如何在调用者看来，它还是在访问A：即代理对调用者透明，至少调用者不需要关心proxy的实现细节和副作用。常见的使用代理的场合有：</p>
<ol>
<li>远程代理（Remote Proxy）：将一个远程对象包装成本地对象。WIKI的例子是ATM，ATM保存了银行信息，用户访问ATM等同于访问银行。</li>
<li>虚拟代理（Virtual Proxy）：对象可以不实际存在，只有当访问时才会真正生成（也可以实现一部分）。参考延迟加载。</li>
<li>保护代理（Protection Proxy）：在实际调用前/中/后进行资源安全性的检查。</li>
<li>Copy-on-Write代理：虚拟代理的一种。把复制（克隆）拖延到只有在客户端需要时，才真正采取行动。</li>
<li>Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙（Firewall）代理：保护目标，不让恶意用户接近。</li>
<li>同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。</li>
</ol>
<p>组合/继承都可以实现代理模式，当然静态代理在JAVA里使用继承会简单一些。即A’继承A，在每个父方法调用前后做一些操作。</p>
<p>JAVA也支持动态代理，按我理解应该是组合模式。对于真实对象object，需要实现一个InvocationHandler接口，再通过Proxy.newProxyInstance(classLoader,interfaces,handler)来创建代理对象。</p>
<ol>
<li>classLoader: 生成的代理类所在的classLoader。（下次学习一下classLoader）。</li>
<li>interfaces：想要代理的接口的集合。</li>
<li>handler：我们刚才创建的handler，使用它来实际调用object，并做一些其他操作。</li>
</ol>
<p>第二个参数interfaces很重要，JAVA动态代理会动态创建一个类似<code>com.sun.proxy.$Proxy0</code>的类，这个类实现了所有的interfaces。在继承关系比较复杂的情况下，个人建议写死会比较好，使用object.getClass().getInterfaces()会出现一些意想不到的情况。比如有接口I1,I2,I3,C1实现了I1,I2，C2继承了C1，且实现了I3，那么一个C2的实例c2.getClass().getInterfaces()返回结果只有I3，无法代理I1和I2。</p>
<p>在实现InvocationHandler接口时，我们需要实现invoke(proxy, method, args)方法，其中可能会调用method.invode(object,args)，当object因为某些原因报错时，method.invode会抛出InvocationTargetException异常：这与所预想抛出的异常不一致，从而导致上层调用者捕捉不到对应的异常。因此最好写成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> method.invoke(client, args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e)&#123;</span><br><span class="line">  <span class="keyword">throw</span> e.getCause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个实现代理的第三方库是<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">cglib</a>。暂时还没看，据说相比于java内置的动态代理，这个库可以不用非要实现某些接口，可以直接拦截。Spring的AOP就是用cglib实现的。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/jvm1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/jvm1/" class="post-title-link" itemprop="url">JVM学习（1）事前准备</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:00 / Modified: 16:35:20" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:00+08:00">2019-08-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在线上调试时发现对JVM了解还是不足，找了本书（《深入理解Java虚拟机》）补习一下，并做些笔记。不过这本书只到java 1.7，缺少1.8之后的一些特性，需要之后再学习一个。</p>
<h2 id="代码获取"><a href="#代码获取" class="headerlink" title="代码获取"></a>代码获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hg clone http:<span class="comment">//hg.openjdk.java.net/jdk7u/jdk7u-dev</span></span><br><span class="line">cd jdk7u-dev</span><br><span class="line">chmode <span class="number">755</span> get_source.sh</span><br><span class="line">./get_source.sh</span><br></pre></td></tr></table></figure>

<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>首先需要自己配一大堆环境变量，特别是把JAVA_HOME、CLASSPATH、LD_LIBRARY_PATH这几个unset掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export LANG=C</span><br><span class="line">export ALT_BOOTDIR=/opt/soft/jdk1.6.0_35</span><br><span class="line">export ALT_JDK_IMPORT_PATH=/opt/soft/jdk1.6.0_35</span><br><span class="line">export BUILD_JDK_IMPORT_PATH=/opt/soft/jdk1.6.0_35</span><br><span class="line">export ALLOW_DOWNLOADS=<span class="keyword">true</span></span><br><span class="line">export HOTSPOT_BUILD_JOBS=<span class="number">6</span></span><br><span class="line">export ALT_PARALLEL_COMPILE_JOBS=<span class="number">6</span></span><br><span class="line">export SKIP_COMPARE_IMAGES=<span class="keyword">true</span></span><br><span class="line">export USE_PRECOMPILED_HEADER=<span class="keyword">true</span></span><br><span class="line">export BUILD_LANGTOOLS=<span class="keyword">true</span></span><br><span class="line">export BUILD_HOTSPOT=<span class="keyword">true</span></span><br><span class="line">export BUILD_JDK=<span class="keyword">true</span></span><br><span class="line">export SKIP_DEBUG_BUILD=<span class="keyword">false</span></span><br><span class="line">export SKIP_FASTDEBUG_BUILD=<span class="keyword">true</span></span><br><span class="line">export DEBUG_NAME=debug</span><br><span class="line">export BUILD_DEPLOY=<span class="keyword">false</span></span><br><span class="line">export BUILD_INSTALL=<span class="keyword">false</span></span><br><span class="line">export ALT_OUTPUTDIR=/home/maxiaoxin/workspace/github/jdk7u-dev/output/</span><br><span class="line">export ALT_FREETYPE_LIB_PATH=/opt/soft/freetype2/lib</span><br><span class="line">export ALT_FREETYPE_HEADERS_PATH=/opt/soft/freetype2/include/freetype2</span><br><span class="line">export ALT_CUPS_HEADERS_PATH=/opt/soft/cups/include/</span><br><span class="line">export DISABLE_HOTSPOT_OS_VERSION_CHECK=ok </span><br><span class="line">export DEBUG_BINARIES=<span class="keyword">true</span></span><br><span class="line">unset JAVA_HOME</span><br><span class="line">unset CLASSPATH</span><br><span class="line">unset LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>然后运行<code>make sanity &amp;&amp; make DISABLE_HOTSPOT_OS_VERSION_CHECK=ok</code><br>编译成功后<code>output-debug/j2sdk-image</code>即为jdk的目录，执行<code>export JAVA_HOME=$path &amp;&amp; ./bin/java -version</code>可以验证下JVM的版本<br>可以只编译hotspot，需要执行<code>cd hotspot/make &amp;&amp; make DEBUG_BINARIES=true</code><br>在<code>/home/maxiaoxin/workspace/github/jdk7u-dev/output-debug/hotspot/outputdir/linux_amd64_compiler2/jvmgd64_compiler2/product</code>目录下，找到env.sh文件，修改</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/maxiaoxin/workspace/github/jdk7u-dev/output-debug/j2sdk-image</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=/home/maxiaoxin/workspace/github/jdk7u-dev/output-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg:<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre/lib/rt.jar:<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre/lib/i18n.jar</span><br><span class="line"><span class="built_in">export</span> HOTSPOT_BUILD_USER=<span class="string">"maxiaoxin in hotspot"</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=:&#123;JAVA_HOME&#125;/jre/lib/amd64</span><br></pre></td></tr></table></figure>

<p>然后运行<code>source env.sh &amp;&amp; ./gamma -version</code>可以验证一下虚拟机版本，执行<code>./gamma Queens</code>可以测试一下用编译好的虚拟机解决八皇后问题，其中Queens.class如果不存在可以自己找到源代码并编译一下</p>
<h2 id="部分错误"><a href="#部分错误" class="headerlink" title="部分错误"></a>部分错误</h2><p>有各种依赖需要自己手动装一下，忘了记录下来了，比如cups和freetype2需要自己安装一下，并设置环境变量（不一定要设置在系统变量里）</p>
<h3 id="undefined-reference-to-‘void-G1SATBCardTableModRefBS-write-ref-array-pre-work-oopDesc-int-’"><a href="#undefined-reference-to-‘void-G1SATBCardTableModRefBS-write-ref-array-pre-work-oopDesc-int-’" class="headerlink" title="undefined reference to ‘void G1SATBCardTableModRefBS::write_ref_array_pre_work(oopDesc*, int)’"></a>undefined reference to ‘void G1SATBCardTableModRefBS::write_ref_array_pre_work<oopdesc>(oopDesc*, int)’</oopdesc></h3><p>参考<a href="https://www.cnblogs.com/abaoge/p/7932612.html" target="_blank" rel="noopener">编译虚拟机jvm——openjdk的编译</a><br>解决：将hotspot/src/share/vm/gc_implementation/g1里的g1SATBCardTableModRefBS.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">G1SATBCardTableModRefBS</span>:</span>:write_ref_array_pre_work(T* dst, <span class="keyword">int</span> count) &#123; </span><br><span class="line">  <span class="keyword">if</span> (!JavaThread::satb_mark_queue_set().is_active()) <span class="keyword">return</span>; </span><br><span class="line">  T* elem_ptr = dst; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++, elem_ptr++) &#123; </span><br><span class="line">    T heap_oop = oopDesc::load_heap_oop(elem_ptr); </span><br><span class="line">    <span class="keyword">if</span> (!oopDesc::is_null(heap_oop)) &#123; </span><br><span class="line">      enqueue(oopDesc::decode_heap_oop_not_null(heap_oop)); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内容下加上如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2017-10-19 Vicent_Chen added </span></span><br><span class="line"><span class="keyword">void</span> G1SATBCardTableModRefBS::write_ref_array_pre(oop* dst, <span class="keyword">int</span> count, <span class="keyword">bool</span> dest_uninitialized) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!dest_uninitialized) &#123; </span><br><span class="line">    write_ref_array_pre_work(dst, count); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> G1SATBCardTableModRefBS::write_ref_array_pre(narrowOop* dst, <span class="keyword">int</span> count, <span class="keyword">bool</span> dest_uninitialized) &#123; </span><br><span class="line">  <span class="keyword">if</span> (!dest_uninitialized) &#123; </span><br><span class="line">    write_ref_array_pre_work(dst, count); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; <span class="comment">//2017-10-19 Vicent_Chen added</span></span><br></pre></td></tr></table></figure>

<p>将hotspot/src/share/vm/gc_implementation/g1里的g1SATBCardTableModRefBS.hpp如下部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write_ref_array_pre</span><span class="params">(oop* dst, <span class="keyword">int</span> count, <span class="keyword">bool</span> dest_uninitialized)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!dest_uninitialized) &#123; </span><br><span class="line">    write_ref_array_pre_work(dst, count); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write_ref_array_pre</span><span class="params">(narrowOop* dst, <span class="keyword">int</span> count, <span class="keyword">bool</span> dest_uninitialized)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!dest_uninitialized) &#123; </span><br><span class="line">    write_ref_array_pre_work(dst, count); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释掉，然后再加入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write_ref_array_pre</span><span class="params">(oop* dst, <span class="keyword">int</span> count, <span class="keyword">bool</span> dest_uninitialized)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write_ref_array_pre</span><span class="params">(narrowOop* dst, <span class="keyword">int</span> count, <span class="keyword">bool</span> dest_unintialized)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="“classes-javax-management-remote-rmi-RMIConnectionImpl-Stub-class”-failed"><a href="#“classes-javax-management-remote-rmi-RMIConnectionImpl-Stub-class”-failed" class="headerlink" title="“classes/javax/management/remote/rmi/RMIConnectionImpl_Stub.class” failed"></a>“classes/javax/management/remote/rmi/RMIConnectionImpl_Stub.class” failed</h3><p>参考<a href="https://segmentfault.com/q/1010000010420043" target="_blank" rel="noopener">ubuntu openjdk jmx编译异常,无法继续</a>，需要手动编译两个类</p>
<p>不过我试下来这个错误是随机出现的。。。实在崩溃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $&#123;OUTPUT_DIR&#125;/classes/javax/management/remote/rmi/</span><br><span class="line">javac RMIServerImpl_Stub.java</span><br><span class="line">javac RMIConnectionImpl_Stub.java</span><br></pre></td></tr></table></figure>

<h3 id="其他错误"><a href="#其他错误" class="headerlink" title="其他错误"></a>其他错误</h3><p>参考<a href="https://blog.csdn.net/beswkwangbo/article/details/38757677" target="_blank" rel="noopener">Ubuntu 14.04 64 bit 编译 openjdk 7</a></p>
<ul>
<li>第一个是 fatal error: sys/cdefs.h: No such file or directory。与gcc版本有关，解决办法：sudo apt-get install libc6-dev-i386</li>
<li>第二个是 bits/c++config.h: No such file or directory。与g++版本有关，解决办法：sudo apt-get install g++-4.8-multilib</li>
<li>第三个是cc1plus: error: the “stabs” debug format cannot be used with pre-compiled headers [-Werror=deprecated]，因为高版本的gcc不再支持stabs，解决办法：在make命令中加上 DEBUG_BINARIES=true</li>
<li>第四个是，cc1plus all warnings being treated as errors ubuntu。解决办法：在hotspot/make/makefiles/gcc.make 中，把 -Werror 选项去掉。</li>
</ul>
<p>很麻烦，因为CLion只支持CMake，所以编译还得自己编译。不过调试还是没问题，自己写一个简单的CMakelists.txt，就可以调试了。</p>
<h2 id="导入CLion"><a href="#导入CLion" class="headerlink" title="导入CLion"></a>导入CLion</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line">project(jdk7u CXX)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 11)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_VERBOSE_MAKEFILE 1)</span><br><span class="line"></span><br><span class="line">add_custom_target(gamma</span><br><span class="line">        WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>启动clion之前需要把刚才那一堆环境变量搞进去，在执行前还需要把JVM环境变量设置好。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
      
          <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="https://maxiaoxin.github.io/2019/08/23/jni/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="maxiaoxin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="读书笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/08/23/jni/" class="post-title-link" itemprop="url">JNI使用中的一些注意事项</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-08-23 00:00:00 / Modified: 16:41:05" itemprop="dateCreated datePublished" datetime="2019-08-23T00:00:00+08:00">2019-08-23</time>
            </span>
          
            

            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很多时候需要在JAVA中调用C/C++库，最简单的做法是使用JNI（Java Native Interface）。相关概念可以参考wiki，这里只记录一些我使用时遇到的问题。</p>
<h3 id="内存模型和参数传递"><a href="#内存模型和参数传递" class="headerlink" title="内存模型和参数传递"></a>内存模型和参数传递</h3><p>比较麻烦的是一般Java代码中的变量保存在堆区/方法区，而JNI所调用的代码访问的变量保存在native区，这导致我们无法在本地代码中直接访问JAVA变量。如果要传递的参数/返回值比较简单、量比较少，可以直接用参数传过来。如果数据量比较大，或者不是基本类型，可能需要用byte[]传。如果数据量巨大，只能用文件等形式传递了。个人目前处理的文件一般是不超过20MB的小文件，因此选择第二种方式传递参数（虽然数据在heap区和native区来回复制也有一定代价），不过好在数据量不是很大，可以接受——另外一个使用byte[]而非DirectByteBuffer的重要原因是我还是有可能会用java代码来处理数据，而java处理DirectByteBuffer有时候很麻烦。。如果是非常大的文件（比如视频文件），使用临时文件/DirectBuffer更好一些。</p>
<p>流数据的处理更复杂一些。现在似乎没有非常方便的在本地代码中读InputStream等的方法（当然可以做到，比如使用<code>GetMethodID&amp;Call??Method</code>等），但我没试过这种方式——即使不考虑效率因素，在本地代码中调用JAVA方法也不是一个好选择，毕竟本地代码处理JAVA运行中的各种异常实在太复杂了。最好还是将数据预处理后，交由本地代码处理，本地代码尽量保持简洁。</p>
<p>当然最重要的还是保证内存不泄漏，本地代码中new/malloc自不必说，记得在最后调用DeleteLocalRef、ReleaseByteArrayElements等函数释放JAVA对象的引用。</p>
<h3 id="加载动态库"><a href="#加载动态库" class="headerlink" title="加载动态库"></a>加载动态库</h3><p>我用的是org.scijava:native-lib-loader。本质上调用的还是System.load，这个库的做法是将动态库extract提取到一个临时文件，然后System.load()，不想引入新的库的话可以自己手动实现一下。</p>
<h3 id="编译和调试"><a href="#编译和调试" class="headerlink" title="编译和调试"></a>编译和调试</h3><p>首先编译环境最好和目标运行环境一致，否则可能会出现各种意想不到的状况，比如系统库版本不兼容等。</p>
<p>如果是自己重新写一个库可以规避掉很多问题。我遇到的情况通常是需要改写现有的库的接口，方便JAVA调用，那么至少需要</p>
<ul>
<li>修改源代码，暴露出可供调用的JNI外部函数</li>
<li>改写MakeFile/CMakeLists，将原本的可执行文件编译为动态链接库</li>
</ul>
<p>只调试本地代码相对简单，但有些错误只有带JAVA调用时才会出现。我使用的IDE是CLion，暂时没找到比较方便的调试方法，目前的做法是加上DEBUG参数编译动态库后，</p>
<ol>
<li>在调用native方法前打个断点，运行至断点</li>
<li>找到java进程的ID（ps，jps或者在程序里打印出来）</li>
<li>CLion中Run - Attach to Local Process，选择对应的PID，在要调试的地方打断点</li>
<li>继续java进程，进入本地代码中的断点，开始调试</li>
</ol>
<p>尽管GDB Remote Debug可以远程调试，但似乎不支持远程调试JNI？</p>
<h3 id="代码编写时的注意事项"><a href="#代码编写时的注意事项" class="headerlink" title="代码编写时的注意事项"></a>代码编写时的注意事项</h3><ol>
<li>很多库实现时只支持FILE<em>，改写为读内存很麻烦。这里推荐fmemopen和open_memstream，可以将数组转变为FILE</em>。</li>
<li>很多C/C++代码逻辑中没有异常处理，我个人也不建议使用throw/catch。但JAVA中使用异常捕捉机制会方便很多，且有时候本地代码中遇到错误时也需要把异常信息传给java进程，那么在C/C++代码运行结束且发现运行出错时，手动抛出一个JAVA异常（调用(*env)-&gt;ThrowNew()），可能是一个比较好的风格。</li>
</ol>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>有些库可能只支持单线程，或者可能最初设计的情景仅仅是程序运行，输入一个文件，处理，输出，程序结束：而内部实现可能是多线程。要处理多个文件，需要同时启动多个程序。</p>
<p>如果简单的用JNI调用，很可能会在并行调用时产生冲突，因为这种库会有大量的全局/静态变量，而没有任何线程同步操作，甚至不可能同步。</p>
<p>简单的处理方法是把JNI函数加锁，即同一时刻一个库暴露出的所有函数至多只有一个调用。复杂的处理方法就是自己手动改代码，把所有全局/静态变量统计出来放在一个struct里，调用时new一个，调用结束时delete掉。</p>
<p>当然如果对库的了解比较深的话可以改写的更优雅一些；如果库本身很复杂，改造起来很麻烦，那就直接加锁吧。</p>
<h3 id="避免使用较高版本的glibc"><a href="#避免使用较高版本的glibc" class="headerlink" title="避免使用较高版本的glibc"></a>避免使用较高版本的glibc</h3><p>使用时发现由于线上机器的gilbc版本可能低于本地编译环境,而glibc升级非常麻烦且会引起一系列问题,所以尽量避免使用较高版本glibc提供的函数</p>
<p>一种避免使用较高版本glibc的办法见(Linux程序兼容),适用于低版本glibc也有此函数的情况</p>
<ul>
<li>查看线上环境支持的glibc版本 <code>strings /lib64/libc.so.6 | grep GLIBC_</code></li>
<li>查看编译出来的二进制库/程序引用的glibc版本,检查有无冲突,及冲突的glibc版本 <code>readelf -s $libname | grep -oP “GLIBC_[\d.]*” | sort | uniq</code></li>
<li>查看使用这个版本glibc的函数 <code>readelf -s $libname | grep GLIBC_2.x</code></li>
<li>找到后在对应位置添加<code>__asm__(&quot;.symver func,func@GLIBC_2.2.5&quot;);</code>,其中glibc版本可以指定为线上机器允许的版本</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

      
    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">maxiaoxin</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">maxiaoxin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  





















  

  

  

</body>
</html>
